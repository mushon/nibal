<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Inflect SVG Viewer</title>
<link rel="icon" type="image/png" sizes="32x32" href="img/favicon-32.png">
<link rel="icon" type="image/png" sizes="16x16" href="img/favicon-16.png">
<link rel="apple-touch-icon" sizes="180x180" href="img/favicon-180.png">
<style>
  html,body{height:100%;margin:0;background:transparent;color:#fff;font-family:Helvetica,Arial,sans-serif}
  #app{position:relative;height:100vh;overflow:hidden}
  #canvas{width:100%;height:100%;position:relative}
  #referenceFrame{position:absolute;pointer-events:none;border:1px solid #0B99FF;box-sizing:border-box;z-index:10}
  #svgContainer{position:absolute;left:0;top:0;right:0;bottom:0;overflow:visible}
  /* HTML overlays container sits above the SVG and follows its transforms */
  #overlays{position:absolute;left:0;top:0;right:0;bottom:0;pointer-events:none;z-index:9}
  #overlays .overlay{position:absolute;transform-origin:0 0;pointer-events:auto}
  /* Ensure video iframes/players fill their container */
  #overlays .overlay iframe,
  #overlays .overlay .plyr,
  #overlays .overlay .plyr__video-wrapper{position:absolute!important;top:0!important;left:0!important;width:100%!important;height:100%!important;max-width:none!important;max-height:none!important;object-fit:cover!important;touch-action:auto!important}
  /* Hide Plyr controls completely */
  #overlays .overlay .plyr__controls{display:none!important}
  #overlays .overlay .plyr__poster{display:none!important}
  #overlays .overlay .plyr--video{background:transparent!important}
  
  /* Sidebar panel matching map design */
  #controls{
    position:absolute;right:0;top:0;bottom:0;
    width:280px;background:rgba(0,0,0,0.85);
    color:#fff;font-size:14px;
    display:flex;flex-direction:column;
    backdrop-filter:blur(10px);
    box-shadow:-2px 0 8px rgba(0,0,0,0.3);
    z-index:100;
  }
  
  #controls-header {
    padding:16px;
    border-bottom:1px solid rgba(255,255,255,0.1);
  }
  
  #controls-header h3 {
    margin:0 0 8px 0;
    font-size:18px;
    font-weight:600;
  }
  
  #controls-header .hint {
    font-size:12px;
    color:rgba(255,255,255,0.6);
  }
  
  #layerList {
    flex:1;
    overflow-y:auto;
    padding:8px 0;
  }
  
  #layerList label {
    display:flex;align-items:center;gap:8px;
    padding:8px 16px;margin:0;
    cursor:pointer;
    transition:background 0.15s;
    user-select:none;
  }
  
  #layerList .layer-thumbnail {
    width:40px;
    height:40px;
    object-fit:cover;
    border-radius:4px;
    background:rgba(255,255,255,0.05);
    flex-shrink:0;
  }
  
  #layerList label:hover {
    background:rgba(255,255,255,0.08);
  }
  
  #controls-footer {
    padding:12px 16px;
    border-top:1px solid rgba(255,255,255,0.1);
  }
  
  #reset, #copyLink {
    width:100%;
    padding:10px;
    background:rgba(255,255,255,0.1);
    border:1px solid rgba(255,255,255,0.2);
    border-radius:6px;
    color:#fff;
    cursor:pointer;
    font-size:13px;
    transition:all 0.2s;
  }
  
  #reset:last-child, #copyLink:last-child {
    margin-top:8px;
  }
  
  #reset:hover, #copyLink:hover {
    background:rgba(255,255,255,0.15);
    border-color:rgba(255,255,255,0.3);
  }
  
  #reset:active, #copyLink:active {
    transform:scale(0.98);
  }
  
  #copyLink.copied {
    background:rgba(11,153,255,0.3);
    border-color:rgba(11,153,255,0.5);
  }
  
  #copyLink.copied {
    background:rgba(11,153,255,0.3);
    border-color:rgba(11,153,255,0.5);
  }
  
  #status{position:absolute;left:8px;top:8px;background:rgba(0,0,0,0.5);padding:6px 8px;border-radius:6px;font-size:12px}
  /* when embedded in an iframe we hide the UI chrome and reference frame */
  .embedded #controls, .embedded #status, .embedded #referenceFrame{ display:none !important; }
  /* Ensure the embedded SVG is not resized by CSS; we control size via transforms */
  #svgContainer > svg{position:absolute;left:0;top:0;max-width:none;max-height:none;width:auto;height:auto}
  
  /* Hide UI chrome when .ui-hidden is set on body */
  body.ui-hidden #status,
  body.ui-hidden #referenceFrame {
    display: none !important;
  }
  /* Sidebar slides out/in, never display:none so transition works */
  body:not(.embedded) #controls {
    transition: transform 0.35s cubic-bezier(0.22,1,0.36,1), opacity 0.25s;
    transform: translateX(0);
    opacity: 1;
  }
  body:not(.embedded).ui-hidden #controls {
    transform: translateX(100%);
    opacity: 0;
    pointer-events: none;
  }
  body.embedded #controls {
    transition: none !important;
    transform: none !important;
    opacity: 1 !important;
  }
  
  /* Hide SVG elements by adding the .hide class */
.hide {
    opacity: 0 !important;
    pointer-events: none !important;
    transition: opacity 0.3s ease;
}

  /* Video button styles */
  .video-btn {
    color: rgba(255, 255, 255, 0.7) !important;
    transition: color 0.2s ease;
  }
  
  .video-btn:hover {
    color: #4caf50 !important;
  }
  
  .video-btn.active {
    color: #4caf50 !important;
  }
</style>
<style>
  /* Force an exception child to remain visible without transitions to avoid flicker */
  .inflect-exception-visible { opacity: 1 !important; visibility: visible !important; transition: none !important; }
</style>
</head>
<body>
<div id="app">
  <div id="canvas">
    <div id="referenceFrame"></div>
    <div id="svgContainer"></div>
    <div id="overlays" aria-hidden="false"></div>
  </div>
  <div id="controls">
    <div id="controls-header">
      <h3>Layers</h3>
      <div class="hint">Toggle visibility</div>
    </div>
    <div id="layerList" aria-live="polite"></div>
    <div id="controls-footer">
      <button id="reset">Reset view</button>
      <button id="copyLink">Copy link</button>
    </div>
  </div>
  <div id="status">loading...</div>
</div>
<script>
// detect if running inside an iframe and toggle embedded UI
try {
  if (window.top && window.top !== window.self) {
      document.documentElement.classList.add('embedded');
  }
} catch(e) {
  // cross-origin top access may throw; assume embedded in that case
  try { document.documentElement.classList.add('embedded'); } catch(e){}
}

// Set initial UI state: hidden if embedded, shown if not
if (document.documentElement.classList.contains('embedded')) {
  document.body.classList.add('ui-hidden');
} else {
  document.body.classList.remove('ui-hidden');
}

// Simple inflect-style hash parser: fields separated by & with url in 5th slot.
// Parse hash and tolerate a url token that may include @param pairs: url@k=v@k2=v2
function parseUrlField(urlField) {
  if (!urlField) return { url: '', params: {}, vis: { show: [], hide: [] } };
  // support optional trailing visibility tokens after a slash, e.g. 'file.svg/~layer+other'
  let base = String(urlField);
  let vis = { show: [], hide: [] };
  const slashIdx = base.indexOf('/');
  if (slashIdx !== -1) {
    const visPart = base.slice(slashIdx + 1);
    base = base.slice(0, slashIdx);
    // tokens start with + or ~; capture sequences like +name, ~name
    const re = /([+~])([^+~\/]+)/g;
    let m;
    while ((m = re.exec(visPart)) !== null) {
      const sym = m[1]; const name = decodeURIComponent(m[2]);
        // resolve short label (no slash) to full hierarchical key if unique
        let resolved = name;
        if (!name.includes('/')){
          // find keys whose last segment matches name
          const matches = [];
          for (const k of layerKeyMap.keys()){
            if (String(k).split('/').pop() === name) matches.push(k);
          }
          if (matches.length === 1) resolved = matches[0];
        }
        if (sym === '+') vis.show.push(resolved);
        else if (sym === '~') vis.hide.push(resolved);
    }
  }
  const parts = base.split('@').map(s => s.trim()).filter(Boolean);
  const url = parts[0] || '';
  const params = {};
  parts.slice(1).forEach(p => {
    const eq = p.indexOf('=');
    if (eq === -1) return;
    const k = p.slice(0, eq);
    const v = p.slice(eq+1);
    if (!k) return;
    params[k] = isNaN(Number(v)) ? v : Number(v);
  });
  return { url, params, vis };
}

function buildUrlField(url, params, vis){
  let token = url || '';
  if (params) for (const k of Object.keys(params)) token += `@${k}=${encodeURIComponent(String(params[k]))}`;
  // Hide-only semantics: only serialize hidden layer keys as ~key
    if (vis) {
      let seg = '';
      // helper to pick a short label if unique (last segment), otherwise use full key
      function shortOrFull(k) {
        if (!k) return k;
        const last = String(k).split('/').pop();
        // check uniqueness among layerKeyMap keys' last segments
        let count = 0;
        for (const kk of layerKeyMap.keys()) if ((String(kk).split('/').pop()) === last) count++;
        return count === 1 ? last : k;
      }
      // Hide-only semantics: by default serialize hidden layers as ~key. However,
      // when there are explicit show (+) tokens present we prefer to serialize only
      // the +tokens (so additional checks produce +A+B) and omit explicit ~ siblings
      // that would otherwise be emitted like +A+B~C~D.
      let hideList = (vis.hide || []).slice();
      let showList = (vis.show || []).slice();
      try {
        // Only attempt compression when there are no explicit shows; if shows are
        // present, skip compression and we will omit ~ tokens below.
        if (!showList.length) {
          const hideSet = new Set(hideList);
          for (const parentKey of Array.from(layerKeyMap.keys())){
            const children = getDirectChildrenKeys(parentKey);
            if (children.length < 2) continue;
            const hiddenChildren = children.filter(c => hideSet.has(c));
            const shownChildren = children.filter(c => showList.includes(c));
            if (hiddenChildren.length === children.length - 1 && shownChildren.length === 1){
              hideList = hideList.filter(h => !hiddenChildren.includes(h));
              hideList.push(parentKey);
            }
          }
        }
      } catch(e) { /* ignore compression failures */ }

      // If explicit shows are present, prefer emitting only +tokens and skip ~tokens
      if (showList && showList.length) {
        showList.forEach(s => { seg += `+${encodeURIComponent(String(shortOrFull(s)))}`; });
      } else {
        if (hideList && hideList.length) hideList.forEach(h => { seg += `~${encodeURIComponent(String(shortOrFull(h)))}`; });
      }
      if (seg) token += '/' + seg;
  }
  return token;
}

function parseHash(){
  const raw = location.hash.slice(1).trim();
  if (!raw) return { url: '', params: {}, view: null };
  // Compact formats supported:
  // - file.svg
  // - file.svg/layers
  // - file.svg/x,y,scale
  // - file.svg/x,y,scale/layers
  // filename may be a path containing .svg
  const compactRe = /^(?<file>.+?\.svg)(?:\/(?:(?<xyzoom>[\d\-.]+,[\d\-.]+,[\d\-.]+)(?:\/(?<layers>.*))?|(?<layersOnly>.*)))?$/i;
  const m = raw.match(compactRe);
  if (m && m.groups && m.groups.file){
    const file = m.groups.file;
    const xyzoom = m.groups.xyzoom || '';
    const layers = (m.groups.layers || m.groups.layersOnly || '').trim();
    let x = null, y = null, s = null;
    if (xyzoom) {
      const parts = xyzoom.split(',').map(Number);
      x = !isNaN(parts[0]) ? parts[0] : null;
      y = !isNaN(parts[1]) ? parts[1] : null;
      s = !isNaN(parts[2]) ? parts[2] : null;
    }
    // parse layers section which follows +/~/@ tokens
    // + = show layer (image only for vimeo layers)
    // ~ = hide layer
    // @ = show video (load iframe for vimeo layers)
    const vis = { show: [], hide: [], video: [] };
    if (layers) {
      // Split by comma first, then process each token
      const tokens = layers.split(',').map(t => t.trim()).filter(t => t);
      tokens.forEach(token => {
        // Support combined tokens like +@vimeo-id, @+vimeo-id, etc.
        if (token.startsWith('+@')) {
          vis.show.push(decodeURIComponent(token.slice(2)));
          vis.video.push(decodeURIComponent(token.slice(2)));
        } else if (token.startsWith('@')) {
          vis.video.push(decodeURIComponent(token.slice(1)));
        } else if (token.startsWith('+')) {
          vis.show.push(decodeURIComponent(token.slice(1)));
        } else if (token.startsWith('~')) {
          vis.hide.push(decodeURIComponent(token.slice(1)));
        }
      });
    }
    const params = {};
    if (s !== null) params.s = s;
    if (x !== null) params.x = x;
    if (y !== null) params.y = y;
    return { url: file, params: params, view: null, vis: vis };
  }

  // backward compatibility: old ampersand-separated format
  if (!raw.includes('&') && (raw.indexOf('.svg') !== -1 || raw.startsWith('/') || /^\w[\w\-\.]*\.svg$/i.test(raw))) {
    const parsed = parseUrlField(raw);
    return { url: parsed.url, params: parsed.params || {}, view: null, vis: parsed.vis || { show: [], hide: [] } };
  }
  const parts = raw.split('&');
  let rawUrlField = parts[4] || '';
  // tolerant shift
  if (!rawUrlField && parts.length>=5 && parts[3] && (parts[3].includes('.svg')||parts[3].startsWith('svg/'))) {
    rawUrlField = parts[3];
  }
  const parsed = parseUrlField(rawUrlField);
  return { url: parsed.url, params: parsed.params || {}, view: null, vis: parsed.vis || { show: [], hide: [] } };
}
function layersToUrlField(u){ return u || ''; }

function buildCompactHash(file, params, vis){
  // params: { x, y, s }
  // x,y are normalized offsets in reference-frame units; keep 2 decimals
  const x = (params && typeof params.x === 'number') ? (Math.round(params.x*100)/100) : 0;
  const y = (params && typeof params.y === 'number') ? (Math.round(params.y*100)/100) : 0;
  const s = (params && typeof params.s === 'number') ? (Math.round(params.s*100)/100) : 1;
  // If params match the default canonical view (0,0,1), omit them from the hash
  let token = String(file || '');
  const paramsAreDefault = (x === 0 && y === 0 && (Math.abs(s - 1) < 1e-6));
  if (!paramsAreDefault) token += `/${x},${y},${s}`;
  // append visibility tokens after either the params (if present) or the filename
  // + = show layer (image), @ = show video (iframe), ~ = hide layer
  if (vis && ((Array.isArray(vis.show) && vis.show.length) || (Array.isArray(vis.hide) && vis.hide.length) || (Array.isArray(vis.video) && vis.video.length))){
    let seg = '';
    // When serializing layer keys into the compact hash, only include the
    // local label (last path segment) to keep tokens short and avoid
    // exposing group prefixes. If the short label is non-unique the
    // parser will resolve it against available keys on load.
    function shortLabel(k){
      if (!k) return k;
      const s = String(k).split('/').pop();
      return s;
    }
    
    const tokens = [];
    
    // If we have any +@ tokens, output those first
    if (vis.show && vis.video && vis.show.length && vis.video.length) {
      for (const k of vis.show) {
        if (vis.video.includes(k)) {
          tokens.push(`+@${encodeURIComponent(String(shortLabel(k)))}`);
        } else {
          tokens.push(`+${encodeURIComponent(String(shortLabel(k)))}`);
        }
      }
      for (const k of vis.video) {
        if (!vis.show.includes(k)) {
          tokens.push(`@${encodeURIComponent(String(shortLabel(k)))}`);
        }
      }
    } else if (vis.show && vis.show.length) {
      for (const k of vis.show) {
        tokens.push(`+${encodeURIComponent(String(shortLabel(k)))}`);
      }
    } else if (vis.hide && vis.hide.length) {
      for (const k of vis.hide) {
        tokens.push(`~${encodeURIComponent(String(shortLabel(k)))}`);
      }
    } else if (vis.video && vis.video.length) {
      for (const k of vis.video) {
        tokens.push(`@${encodeURIComponent(String(shortLabel(k)))}`);
      }
    }
    
    if (tokens.length > 0) {
      seg = tokens.join(',');
    }
    if (seg) token += `/${seg}`;
  }
  return token;
}

let svgContainer = document.getElementById('svgContainer');
let status = document.getElementById('status');
let resetBtn = document.getElementById('reset');

let svgEl = null; // the embedded svg root
let wrapperG = null; // group we apply transforms to
let bbox = null;
// animation timing (ms) for fades; make configurable
// Use a longer duration and a soft cubic-bezier to produce buttery transitions
const FADE_DURATION = 1800;
const SOFT_EASE = 'cubic-bezier(0.22,1,0.36,1)';
let state = { tx:0, ty:0, scale:1 };
let view = null; // { topLeft:[x,y], bottomRight:[x,y] } in svg coords
let isDragging=false, dragStart=null, dragStartState=null;
 let pendingVis = null; // visibility instructions to apply after load
let layerKeyMap = new Map();
let showExceptions = new Set(); // keys explicitly shown despite ancestor hide
let defaultSvgParams = null; // captured after load to represent the 'fit' defaults

function getDirectChildrenKeys(parentKey){
  const res = [];
  const prefix = parentKey + '/';
  for (const k of layerKeyMap.keys()){
    if (!k.startsWith(prefix)) continue;
    const rest = k.slice(prefix.length);
    if (rest.indexOf('/') === -1) res.push(k);
  }
  return res;
}

function getKeyForElement(el){
  for (const [k, v] of layerKeyMap.entries()){
    if (v === el) return k;
  }
  return null;
}

function setStatus(s){ status.textContent = s; }

async function loadSVG(url){
  if (!url) { setStatus('no url'); return; }
  try {
    setStatus('loading '+url);
    const res = await fetch(url);
    if (!res.ok) throw new Error('fetch failed '+res.status);
    const text = await res.text();
    svgContainer.innerHTML = text;
    svgEl = svgContainer.querySelector('svg');
    if (!svgEl) throw new Error('no <svg> in file');
    // Store the filename for later hash updates
    svgEl.setAttribute('data-filename', url);
    // ensure width/height viewBox exists
    if (!svgEl.getAttribute('viewBox')) {
      const w = parseFloat(svgEl.getAttribute('width')) || svgEl.clientWidth || 300;
      const h = parseFloat(svgEl.getAttribute('height')) || svgEl.clientHeight || 150;
      svgEl.setAttribute('viewBox','0 0 '+w+' '+h);
    }
    // Hide SVG initially
    svgEl.style.opacity = '0';
    svgEl.style.transition = 'opacity 0.6s cubic-bezier(0.22,1,0.36,1)';
    // We manipulate the SVG using CSS transforms on the svg element.
    // Anchor everything to the canvas' top-left and avoid CSS auto-scaling.
    try {
      const canvas = document.getElementById('canvas');
      if (canvas && canvas.style) canvas.style.position = canvas.style.position || 'relative';
      if (svgContainer && svgContainer.style) {
        svgContainer.style.position = 'absolute';
        svgContainer.style.left = '0';
        svgContainer.style.top = '0';
        svgContainer.style.right = '0';
        svgContainer.style.bottom = '0';
        svgContainer.style.overflow = 'visible';
      }
    } catch(e){}
    svgEl.style.position = 'absolute';
    svgEl.style.left = '0';
    svgEl.style.top = '0';
    svgEl.style.maxWidth = 'none';
    svgEl.style.maxHeight = 'none';
    svgEl.style.width = 'auto';
    svgEl.style.height = 'auto';
    svgEl.style.display = 'block';
    svgEl.style.transformOrigin = '0 0';
    // compute bbox after a tick and derive initial fit values
    await new Promise(r => setTimeout(r,20));
    try { bbox = svgEl.getBBox(); } catch(e) { bbox = { x:0,y:0,width:svgEl.clientWidth||300,height:svgEl.clientHeight||150 }; }
    fitToContainer();
    // leave scale as default; caller may override via params
    // UI sliders removed — keep internal state but do not update controls
    render();
    // Capture the default params (scale/tx/ty) after fitting so
    // missing hash params can animate toward these defaults.
    try { defaultSvgParams = { s: state.scale, x: state.tx, y: state.ty }; } catch(e){}
    setStatus('ready');
    window.viewerReady = true;
    // build layer list UI so user can show/hide layers
    try { buildLayerList(); } catch(e) { /* build layer list failed */ }
    // apply any pending visibility instructions now that layers exist
    try { if (pendingVis) { applyVisibilityFromVis(pendingVis, { animate: false }); pendingVis = null; } } catch(e) { /* apply pending vis failed */ }
    try { window.layerKeyMap = layerKeyMap; } catch(e){}
    // auto-attach video overlays for layers with vimeo-* or embed-* IDs
    try { autoAttachVideoOverlays(); } catch(e) { /* auto-attach videos failed */ }
    // Ensure overlays are positioned correctly after attachment
    try { if (window.overlayManager && typeof window.overlayManager.update === 'function') window.overlayManager.update(); } catch(e){}
    // Fade in SVG after a tick (ensures positioned)
    setTimeout(() => { if (svgEl) svgEl.style.opacity = '1'; }, 60);
  } catch (e) {
    setStatus('error');
    window.viewerReady = false;
  }
}

// build a simple layer list UI from top-level svg children
function buildLayerList(){
  if (!svgEl) return;
  const layerList = document.getElementById('layerList');
  if (!layerList) return;
  layerList.innerHTML = '';

  // exclude non-visual/definition tags and elements defined under <defs>
  const excluded = new Set([
    'SCRIPT','STYLE','DEFS','METADATA','TITLE','PATTERN',
    'LINEARGRADIENT','RADIALGRADIENT','CLIPPATH','MASK','FILTER','MARKER','SYMBOL','VIEW','FONT'
  ]);

  function getLabel(el, idx){
    // Only include elements that have an explicit id
    return el.id || null;
  }

  // Fetch Vimeo thumbnail via oEmbed API
  async function getVimeoThumbnail(videoId) {
    try {
      if (!videoId || !/^\d+$/.test(String(videoId))) {
        console.warn('[vimeo] Invalid video ID:', videoId);
        return null;
      }
      const response = await fetch(`https://vimeo.com/api/oembed.json?url=https://vimeo.com/${videoId}`);
      if (!response.ok) {
        console.warn('[vimeo] API response not OK:', response.status);
        return null;
      }
      const data = await response.json();
      return data.thumbnail_url || null;
    } catch(e) {
      console.warn('[vimeo] Thumbnail fetch failed:', e.message);
      return null;
    }
  }

  // Get thumbnail URL for a layer element
  async function getLayerThumbnail(el, baseKey) {
    const vimeoMatch = baseKey.match(/^vimeo-(\d+)$/i);
    if (vimeoMatch) {
      const videoId = vimeoMatch[1];
      return await getVimeoThumbnail(videoId);
    }
    
    const img = el.querySelector('image');
    if (img) {
      const href = img.getAttribute('href') || img.getAttributeNS('http://www.w3.org/1999/xlink', 'href');
      if (href) return href;
    }
    
    return null;
  }

  function makeNode(el, idx, parentKey){
    const baseKey = getLabel(el, idx);
    if (!baseKey) return null;

    // Compute stable unique key
    let key = parentKey ? `${parentKey}/${baseKey}` : baseKey;
    let uniqueKey = key; 
    let suffix = 1;
    while (layerKeyMap.has(uniqueKey)) { 
      uniqueKey = key + '_' + (suffix++); 
    }
    key = uniqueKey;
    layerKeyMap.set(key, el);

    // Create layer item container
    const li = document.createElement('div');
    li.className = 'layer-item';
    li.dataset.layerKey = key;
    
    // Create controls row
    const controls = document.createElement('div');
    controls.className = 'layer-controls';
    controls.style.display = 'flex';
    controls.style.alignItems = 'center';
    controls.style.gap = '4px';
    controls.style.marginBottom = '4px';
    
    // Checkbox
    const cb = document.createElement('input');
    cb.type = 'checkbox';
    cb.dataset.layerKey = key;
    cb.id = `layer-cb-${key.replace(/[^a-zA-Z0-9]/g, '-')}`;
    
    // Label with thumbnail and text
    const label = document.createElement('label');
    label.htmlFor = cb.id;
    label.style.display = 'flex';
    label.style.alignItems = 'center';
    label.style.gap = '6px';
    label.style.cursor = 'pointer';
    label.style.flex = '1';
    
    // Thumbnail
    const thumb = document.createElement('img');
    thumb.className = 'layer-thumbnail';
    thumb.style.display = 'none';
    thumb.style.width = '24px';
    thumb.style.height = '24px';
    thumb.style.objectFit = 'cover';
    
    // Text
    const textSpan = document.createElement('span');
    textSpan.textContent = baseKey;
    
    label.appendChild(thumb);
    label.appendChild(textSpan);
    
    // Fetch thumbnail asynchronously
    getLayerThumbnail(el, baseKey).then(thumbnailUrl => {
      if (thumbnailUrl) {
        thumb.src = thumbnailUrl;
        thumb.style.display = 'block';
      }
    }).catch(() => {});
    
    // Assemble controls: checkbox + label
    controls.appendChild(cb);
    controls.appendChild(label);
    
    // Add video button for vimeo layers (before "Only" button)
    const isVimeoLayer = baseKey.match(/^vimeo-(\d+)$/i);
    if (isVimeoLayer) {
      const videoBtn = document.createElement('button');
      videoBtn.type = 'button';
      videoBtn.className = 'video-btn';
      videoBtn.title = 'Toggle video';
      videoBtn.innerHTML = '&#9656;';
      videoBtn.dataset.layerKey = key;
      videoBtn.style.padding = '4px 8px';
      videoBtn.style.background = 'transparent';
      videoBtn.style.border = 'none';
      videoBtn.style.borderRadius = '3px';
      videoBtn.style.color = 'inherit';
      videoBtn.style.cursor = 'pointer';
      videoBtn.style.fontSize = '16px';
      controls.appendChild(videoBtn);
    }
    
    // Add "Only" button (focus button) after video button
    const onlyBtn = document.createElement('button');
    onlyBtn.type = 'button';
    onlyBtn.className = 'only-btn';
    onlyBtn.title = 'Show only this layer';
    onlyBtn.textContent = '⊙';
    onlyBtn.style.padding = '4px 8px';
    onlyBtn.style.background = 'transparent';
    onlyBtn.style.border = 'none';
    onlyBtn.style.borderRadius = '3px';
    onlyBtn.style.color = 'inherit';
    onlyBtn.style.cursor = 'pointer';
    onlyBtn.style.fontSize = '16px';
    controls.appendChild(onlyBtn);
    
    
    li.appendChild(controls);
    
    // Add children if any
    const childElems = Array.from(el.children).filter(c => 
      c.nodeType === 1 && 
      !excluded.has((c.tagName || '').toUpperCase()) && 
      !c.closest('defs')
    );
    
    if (childElems.length > 0){
      const container = document.createElement('div');
      container.className = 'layer-children';
      container.style.marginLeft = '20px';
      
      childElems.reverse().forEach((c, ci) => {
        const node = makeNode(c, ci, key);
        if (node) container.appendChild(node);
      });
      li.appendChild(container);
    }
    
    return li;
  }

  // Build layer list
  const topChildren = Array.from(svgEl.children).filter(c => 
    c.nodeType === 1 && 
    !excluded.has((c.tagName || '').toUpperCase()) && 
    !c.closest('defs')
  );
  
  layerKeyMap.clear();
  topChildren.reverse().forEach((el, idx) => {
    const node = makeNode(el, idx, null);
    if (node) layerList.appendChild(node);
  });
  
  // Set up event delegation for all layer list interactions
  setupLayerListEvents();
  
  // Initial state sync
  refreshLayerListCheckboxes();
  try { window.layerKeyMap = layerKeyMap; } catch(e){}
}

// Set up event delegation for layer list
function setupLayerListEvents() {
  const layerList = document.getElementById('layerList');
  if (!layerList || layerList._eventsSetup) return;
  layerList._eventsSetup = true;
  
  // Handle checkbox changes
  layerList.addEventListener('change', (e) => {
    if (e.target.type !== 'checkbox') return;
    const key = e.target.dataset.layerKey;
    if (!key) return;
    
    const parsed = parseHash();
    const vis = parsed.vis || { show: [], hide: [], video: [] };
    const shortKey = key.split('/').pop();
    const isShowMode = Array.isArray(vis.show) && vis.show.length > 0;
    
    if (e.target.checked) {
      if (isShowMode) {
        // In + (show-only) mode: add to shows
        if (!vis.show) vis.show = [];
        if (!vis.show.includes(shortKey) && !vis.show.includes(key)) vis.show.push(shortKey);
        // Remove from hides just in case
        if (vis.hide) vis.hide = vis.hide.filter(h => h !== shortKey && h !== key);
      } else {
        // In default/hide-only mode: remove from hides only; do NOT add to shows
        if (vis.hide) vis.hide = vis.hide.filter(h => h !== shortKey && h !== key);
      }
    } else {
      if (isShowMode) {
        // In + (show-only) mode: remove from shows
        if (vis.show) vis.show = vis.show.filter(s => s !== shortKey && s !== key);
      } else {
        // In default/hide-only mode: add to hides
        if (!vis.hide) vis.hide = [];
        if (!vis.hide.includes(shortKey) && !vis.hide.includes(key)) vis.hide.push(shortKey);
      }
    }
    
    // If both show and hide become empty arrays, normalize to no tokens (show all)
    if (Array.isArray(vis.show) && vis.show.length === 0 && Array.isArray(vis.hide) && vis.hide.length === 0) {
      vis.show = [];
      vis.hide = [];
    }
    
    // Apply immediately to DOM to avoid waiting for hashchange (which can be suppressed)
    try { applyVisibilityFromVis(vis, { animate: true }); } catch(_) {}
    try { if (window.overlayManager && typeof window.overlayManager.update === 'function') window.overlayManager.update(); } catch(_) {}
    
    // Update the hash with only the layer tokens changed
    suppressHashFor(120);
    const newHash = updateHashLayers(vis);
    if (newHash) location.hash = '#' + newHash;
  });
  
  // Handle "Only" button clicks
  layerList.addEventListener('click', (e) => {
    if (!e.target.classList.contains('only-btn')) return;
    e.preventDefault();
    e.stopPropagation();
    
    const layerItem = e.target.closest('[data-layer-key]');
    if (!layerItem) return;
    const key = layerItem.dataset.layerKey;
    const shortKey = key.split('/').pop();
    
    const parsed = parseHash();
    // If this is a root layer, reset to show all
    if (!key.includes('/')) {
      parsed.vis = { show: [], hide: [], video: [] };
    } else {
      // Show only this layer
      parsed.vis = { show: [shortKey], hide: [], video: parsed.vis?.video || [] };
    }
    
    // Apply immediately and write compact layer tokens
    try { applyVisibilityFromVis(parsed.vis, { animate: true }); } catch(_) {}
    try { if (window.overlayManager && typeof window.overlayManager.update === 'function') window.overlayManager.update(); } catch(_) {}
    suppressHashFor(120);
    const newHash = updateHashLayers(parsed.vis);
    if (newHash) location.hash = '#' + newHash;
  });
  
  // Handle video button clicks
  layerList.addEventListener('click', (e) => {
    if (!e.target.classList.contains('video-btn')) return;
    e.preventDefault();
    e.stopPropagation();
    
    const key = e.target.dataset.layerKey;
    if (!key) return;
    const shortKey = key.split('/').pop();
    
    const parsed = parseHash();
    const vis = parsed.vis || { show: [], hide: [], video: [] };
    if (!vis.video) vis.video = [];
    
    const hasVideo = vis.video.includes(shortKey) || vis.video.includes(key);
    
    if (hasVideo) {
      // Remove video token
      vis.video = vis.video.filter(v => v !== shortKey && v !== key);
    } else {
      // Add video token
      if (!vis.video.includes(shortKey) && !vis.video.includes(key)) {
        vis.video.push(shortKey);
      }
    }
    
    // Apply immediately and write compact layer tokens
    try { applyVisibilityFromVis(vis, { animate: true, skipOverlayUpdate: true }); } catch(_) {}
    // Attach/remove video overlays based on updated vis
    try { if (typeof autoAttachVideoOverlays === 'function') autoAttachVideoOverlays(vis); } catch(_) {}
    try { if (window.overlayManager && typeof window.overlayManager.update === 'function') window.overlayManager.update(); } catch(_) {}
    suppressHashFor(120);
    const newHash = updateHashLayers(vis);
    if (newHash) location.hash = '#' + newHash;
  });
}

// Helper function to update just the layer tokens in the hash, leaving filename and params intact
function updateHashLayers(vis) {
  const currentHash = location.hash.slice(1); // Remove #
  if (!currentHash) return;
  
  // Parse the hash to find where the layer section starts
  // Format: filename.svg/x,y,scale/layers or filename.svg/layers
  const parts = currentHash.split('/');
  
  if (parts.length === 0) return;
  
  // Determine if we have params (x,y,scale) section
  // parts[0] = filename.svg
  // parts[1] = either x,y,scale OR layer tokens
  // parts[2] = layer tokens (if parts[1] was x,y,scale)
  
  let baseHash = parts[0]; // filename.svg
  let hasParams = false;
  
  if (parts.length >= 2) {
    // Check if parts[1] looks like x,y,scale (numbers with commas)
    if (/^[\d\-.]+,[\d\-.]+,[\d\-.]+$/.test(parts[1])) {
      hasParams = true;
      baseHash += '/' + parts[1]; // Add back the x,y,scale
    }
  }
  
  // Build layer tokens
  function shortLabel(k) {
    if (!k) return k;
    return String(k).split('/').pop();
  }
  
  const tokens = [];
  
  // Handle combined +@ tokens
  if (vis.show && vis.video && vis.show.length && vis.video.length) {
    for (const k of vis.show) {
      if (vis.video.includes(k)) {
        tokens.push(`+@${encodeURIComponent(String(shortLabel(k)))}`);
      } else {
        tokens.push(`+${encodeURIComponent(String(shortLabel(k)))}`);
      }
    }
    for (const k of vis.video) {
      if (!vis.show.includes(k)) {
        tokens.push(`@${encodeURIComponent(String(shortLabel(k)))}`);
      }
    }
  } else if (vis.show && vis.show.length) {
    for (const k of vis.show) {
      tokens.push(`+${encodeURIComponent(String(shortLabel(k)))}`);
    }
  } else if (vis.hide && vis.hide.length) {
    for (const k of vis.hide) {
      tokens.push(`~${encodeURIComponent(String(shortLabel(k)))}`);
    }
  } else if (vis.video && vis.video.length) {
    for (const k of vis.video) {
      tokens.push(`@${encodeURIComponent(String(shortLabel(k)))}`);
    }
  }
  
  // Append layer tokens if any
  if (tokens.length > 0) {
    baseHash += '/' + tokens.join(',');
  }
  
  return baseHash;
}

function toggleLayerVisibility(el, show, opts){
  if (!el) return;
  // If this element is explicitly marked as an exception-visible, never hide it
  try { if (!show && el.classList && el.classList.contains('inflect-exception-visible')) return; } catch(e){}
  // If this element corresponds to a parent (has direct children), do not hide the parent
  try {
    const key = getKeyForElement(el);
    if (!show && key && getDirectChildrenKeys(key).length > 0) return;
  } catch(e){}
  // Determine current computed visibility so we can avoid re-animating
  // elements whose visible state already matches the requested state.
  function isCurrentlyVisible(element){
    try {
      const cs = window.getComputedStyle(element);
      const op = parseFloat(cs.opacity || '1');
      return cs.display !== 'none' && cs.visibility !== 'hidden' && op > 0.001;
    } catch(e) { return true; }
  }
  const animate = !(opts && opts.animate === false);
  const currentlyVisible = isCurrentlyVisible(el);
  // Detect if a fade transition is in progress for this element. If so, we should
  // not early-return when toggling back to the opposite state (e.g., re-check during fade-out),
  // but instead cancel and start the opposite animation immediately.
  const animating = (typeof __fadeCancels !== 'undefined' && __fadeCancels && typeof __fadeCancels.has === 'function') ? __fadeCancels.has(el) : false;
  // If the element is already in the desired visibility state, skip animation.
  // However, do NOT skip if an opposite animation is currently running; we need to flip it.
  if (!animating) {
    if (currentlyVisible && show) {
      return animate ? Promise.resolve() : undefined;
    }
    if (!currentlyVisible && !show) {
      return animate ? Promise.resolve() : undefined;
    }
  }
  if (animate) {
    return animateLayerVisibility(el, show);
  } else {
    // immediate apply without animation
    if (show) {
      el.style.transition = '';
      el.style.opacity = '';
      el.style.display = '';
      el.style.visibility = '';
    } else {
      // If this is a parent (has children), don't remove it — children will be hidden individually.
      try {
        const key = getKeyForElement(el);
        if (key && getDirectChildrenKeys(key).length > 0) {
          // leave parent visible but non-interactive; children control visibility
          el.style.pointerEvents = 'none';
          // do not set opacity/display so children remain rendered
        } else {
          el.style.transition = '';
          el.style.opacity = '';
          el.style.display = 'none';
        }
      } catch(e) {
        el.style.display = 'none';
      }
    }
  }
}

// animate opacity for an element when showing/hiding
const __fadeCancels = new WeakMap();
function animateLayerVisibility(el, show, duration = FADE_DURATION){
  if (!el) return;
  // If this element maps to a parent node with direct children, do not animate it;
  // children will be animated individually. Avoid setting parent opacity which
  // would affect child rendering.
  try {
    const key = getKeyForElement(el);
    if (!show && key && getDirectChildrenKeys(key).length > 0) return Promise.resolve();
  } catch(e){}
  // if element is marked as an exception visible, don't animate hiding it or toggling
  if (el.classList && el.classList.contains('inflect-exception-visible')) {
    if (show) {
      // ensure visible immediately
      el.style.transition = '';
      el.style.opacity = '';
      el.style.display = '';
      el.style.visibility = '';
    } else {
      // do not hide exception-marked elements
      return Promise.resolve();
    }
  }
  return new Promise((resolve) => {
  // cancel previous transition if any
  const prevCancel = __fadeCancels.get(el);
  if (prevCancel) prevCancel();

  const computedDisplay = window.getComputedStyle(el).display;
  // show: ensure element is displayed and fade to opacity 1
  if (show) {
  // make element visible before starting fade. For SVG elements there may
  // be an explicit display="none" attribute; remove it and set an inline
  // CSS display so the element becomes visible.
  try { el.removeAttribute && el.removeAttribute('display'); } catch(e){}
  el.style.display = 'inline';
    el.style.visibility = '';
    // Start with no transition and opacity 0
    el.style.transition = 'none';
    el.style.opacity = '0';
    // Force layout
    void el.getBoundingClientRect();
    // Update overlays to get opacity:0 with no transition
    try { if (window.overlayManager && typeof window.overlayManager.update === 'function') window.overlayManager.update(); } catch(e){}
    // Now set up the transition
  el.style.transition = `opacity ${duration}ms ${SOFT_EASE}`;
    // Force layout again so transition is registered
    void el.getBoundingClientRect();
    // Update overlays to copy the transition property (opacity still at 0)
    try { if (window.overlayManager && typeof window.overlayManager.update === 'function') window.overlayManager.update(); } catch(e){}
    let finished = false;
    const onEnd = (ev) => {
      if (ev && ev.propertyName !== 'opacity') return;
      if (finished) return;
      finished = true;
      el.removeEventListener('transitionend', onEnd);
      // cleanup
      el.style.transition = '';
      el.style.opacity = '';
      __fadeCancels.delete(el);
      // Update overlays after visibility change completes
      try { if (window.overlayManager && typeof window.overlayManager.update === 'function') window.overlayManager.update(); } catch(e){}
      resolve();
    };
    el.addEventListener('transitionend', onEnd);
    // start fade
    requestAnimationFrame(() => { 
      el.style.opacity = '1';
      // Double RAF to ensure overlay updates after opacity change has been committed
      requestAnimationFrame(() => {
  try { if (typeof autoAttachVideoOverlays === 'function') autoAttachVideoOverlays(); } catch(e){}
  try { if (window.overlayManager && typeof window.overlayManager.update === 'function') window.overlayManager.update(); } catch(e){}
      });
    });
    // store cancel function
    __fadeCancels.set(el, () => {
      if (finished) return;
      el.removeEventListener('transitionend', onEnd);
      finished = true;
      __fadeCancels.delete(el);
      el.style.transition = '';
      el.style.opacity = '';
      // Update overlays when animation is cancelled
      try { if (window.overlayManager && typeof window.overlayManager.update === 'function') window.overlayManager.update(); } catch(e){}
      resolve();
    });
    return;
  }

  // hide: fade to 0 then set display none
  // Start with no transition, just ensure opacity is 1
  el.style.transition = 'none';
  if (!el.style.opacity) {
    // if no inline opacity, set to computed value or 1
    const comp = window.getComputedStyle(el).opacity;
    el.style.opacity = comp || '1';
  }
  // Force layout
  void el.getBoundingClientRect();
  // Update overlays to get opacity:1 with no transition
  try { if (window.overlayManager && typeof window.overlayManager.update === 'function') window.overlayManager.update(); } catch(e){}
  // Now set up the transition
  el.style.transition = `opacity ${duration}ms ${SOFT_EASE}`;
  // Force layout so transition is registered
  void el.getBoundingClientRect();
  // Update overlays to copy the transition property (opacity still at 1)
  try { if (window.overlayManager && typeof window.overlayManager.update === 'function') window.overlayManager.update(); } catch(e){}
  let finished = false;
  const onEndHide = (ev) => {
    if (ev && ev.propertyName !== 'opacity') return;
    if (finished) return;
    finished = true;
    el.removeEventListener('transitionend', onEndHide);
    el.style.transition = '';
    el.style.opacity = '';
    // If this element is a parent with direct children, avoid removing it
    // from layout (display:none) because that would hide its children
    // momentarily. Instead keep it in the DOM but make it non-interactive.
    try {
      const key = getKeyForElement(el);
      if (key && getDirectChildrenKeys(key).length > 0) {
        el.style.pointerEvents = 'none';
        // ensure opacity remains 0
        try { el.style.opacity = '0'; } catch(e){}
  // avoid setting SVG display attribute; rely on inline styles only
      } else {
        el.style.display = 'none';
  // avoid setting SVG display attribute; rely on inline styles only
      }
    } catch(e) {
      el.style.display = 'none';
      try { el.setAttribute && el.setAttribute('display', 'none'); } catch(e){}
    }
    __fadeCancels.delete(el);
    // Update overlays after visibility change completes
    try { if (window.overlayManager && typeof window.overlayManager.update === 'function') window.overlayManager.update(); } catch(e){}
    resolve();
  };
  el.addEventListener('transitionend', onEndHide);
  // start fade out
  requestAnimationFrame(() => { 
    el.style.opacity = '0';
    // Double RAF to ensure overlay updates after opacity change has been committed
    requestAnimationFrame(() => {
      try { if (window.overlayManager && typeof window.overlayManager.update === 'function') window.overlayManager.update(); } catch(e){}
    });
  });
  __fadeCancels.set(el, () => {
    if (finished) return;
    el.removeEventListener('transitionend', onEndHide);
    finished = true;
    __fadeCancels.delete(el);
    el.style.transition = '';
    el.style.opacity = '';
    try {
      const key = getKeyForElement(el);
      if (key && getDirectChildrenKeys(key).length > 0) {
        el.style.pointerEvents = 'none';
        try { el.style.opacity = '0'; } catch(e){}
  // avoid setting SVG display attribute; rely on inline styles only
      } else {
        el.style.display = 'none';
  // avoid setting SVG display attribute; rely on inline styles only
      }
    } catch(e) {
      el.style.display = 'none';
      try { el.setAttribute && el.setAttribute('display', 'none'); } catch(e){}
    }
    // Update overlays when animation is cancelled
    try { if (window.overlayManager && typeof window.overlayManager.update === 'function') window.overlayManager.update(); } catch(e){}
    resolve();
  });
  });
}

// apply vis object { show:[], hide:[] } to the SVG layers (matching by id/data-name/prefix)
function applyVisibilityFromVis(vis, opts){
  const animateGlobally = opts && opts.animate === true;
  const skipOverlayUpdate = opts && opts.skipOverlayUpdate === true;
  if (!svgEl) return;
  
  // First, remove ALL video overlays to ensure clean state based on hash
  if (window.overlayManager && window.overlayManager.items) {
    const allKeys = Array.from(layerKeyMap.keys());
    allKeys.forEach(key => {
      if (window.overlayManager && typeof window.overlayManager.remove === 'function') {
        window.overlayManager.remove(key);
      }
    });
  }
  
  // Resolve short vis tokens (like 'princess') against layerKeyMap by last-segment
  const rawHides = (vis && Array.isArray(vis.hide)) ? vis.hide.slice() : [];
  const rawShows = (vis && Array.isArray(vis.show)) ? vis.show.slice() : [];
  const rawVideos = (vis && Array.isArray(vis.video)) ? vis.video.slice() : [];
  const resolveToken = (tok) => {
    if (!tok) return tok;
    if (String(tok).includes('/')) return tok;
    // find keys whose last segment matches tok
    const matches = [];
    for (const k of layerKeyMap.keys()){
      if (String(k).split('/').pop() === String(tok)) matches.push(k);
    }
    return matches.length === 1 ? matches[0] : tok;
  };
  
  // Resolve all tokens to full keys
  const hides = rawHides.map(resolveToken);
  const shows = rawShows.map(resolveToken);
  const videos = rawVideos.map(resolveToken);
  
  // If a layer has both + and @ (like +@vimeo or separate +vimeo,@vimeo), ensure it's in shows
  videos.forEach(v => {
    if (!shows.includes(v)) {
      // Check if this video layer was explicitly shown with +
      const shortV = String(v).split('/').pop();
      const wasShown = rawShows.some(s => s === v || s === shortV);
      if (wasShown && !shows.includes(v)) {
        shows.push(v);
      }
    }
  });
  
  // Ensure all ancestors of shown layers are also visible
  function addAncestors(key, arr) {
    const parts = String(key).split('/');
    for (let i = 1; i < parts.length; i++) {
      const ancestor = parts.slice(0, i).join('/');
      if (!arr.includes(ancestor)) arr.push(ancestor);
    }
  }
  
  // Add ancestors for all shown layers
  const originalShows = shows.slice();
  originalShows.forEach(k => addAncestors(k, shows));
  
  // When @ token is used alone (without +), ensure video layers are visible
  // by NOT hiding them, but don't add them to shows (which would hide siblings)
  const videoLayersToShow = [];
  if (videos.length > 0 && shows.length === 0) {
    // @ only: video layers should be visible
    videos.forEach(v => videoLayersToShow.push(v));
  }
  
  // Store original shows for exception tracking
  showExceptions = new Set(originalShows);
  
  // Visibility logic:
  // - If +tokens exist: show ONLY those layers (and ancestors)
  // - If ~tokens exist: show ALL layers EXCEPT those
  // - If @tokens exist without +: show ALL layers (video overlays added separately)
  // - If no tokens: show ALL layers
  
  for (const [key, el] of layerKeyMap.entries()) {
    let visible = true;
    
    if (shows.length > 0) {
      // + tokens: show ONLY listed layers and their ancestors
      visible = shows.includes(key);
    } else if (hides.length > 0) {
      // ~ tokens: hide ONLY listed layers (check both full key and descendants)
      visible = !hides.includes(key);
      // Also hide if any ancestor is in hides
      for (const h of hides) {
        if (key.startsWith(h + '/')) {
          visible = false;
          break;
        }
      }
    } else if (videos.length > 0) {
      // @ tokens only: show ALL layers (video overlays handled separately)
      visible = true;
    } else {
      // No tokens: show all
      visible = true;
    }
    
    toggleLayerVisibility(el, visible, { animate: animateGlobally ? true : false });
    try { const cb = document.querySelector(`input[data-layer-key="${key}"]`); if (cb) cb.checked = Boolean(visible); } catch(e){}
    if (!visible && window.overlayManager && typeof window.overlayManager.remove === 'function') window.overlayManager.remove(key);
  }
  // Ancestor-preserve behavior for +/@ tokens: for each shown key, walk up its
  // ancestor chain and hide all direct sibling branches at each ancestor level
  // (unless those siblings are explicitly shown or marked as exceptions).
  try {
    const ancestorHideAdditions = new Set();
    function addDescendantsToSet(baseKey, set){
      for (const k of layerKeyMap.keys()){
        if (k === baseKey || k.startsWith(baseKey + '/')) set.add(k);
      }
    }
    for (const s of shows){
      if (!s) continue;
      const parts = String(s).split('/');
      // top-level: hide other top-level keys
      if (parts.length === 1){
        for (const k of layerKeyMap.keys()){
          if (String(k).split('/').length !== 1) continue;
          if (k === s) continue;
          if (shows.includes(k)) continue; // don't hide other requested shows
          if (showExceptions.has(k)) continue;
          addDescendantsToSet(k, ancestorHideAdditions);
        }
      } else {
        // for each ancestor (parent, grandparent, ...)
        for (let i = parts.length - 1; i >= 1; i--) {
          const ancestorKey = parts.slice(0, i).join('/');
          const nextSeg = parts[i];
          const childToKeep = ancestorKey + '/' + nextSeg;
          const children = getDirectChildrenKeys(ancestorKey);
          for (const childKey of children) {
            if (childKey === childToKeep) continue;
            if (shows.includes(childKey)) continue;
            if (showExceptions.has(childKey)) continue;
            addDescendantsToSet(childKey, ancestorHideAdditions);
          }
        }
      }
    }
    // merge additions into hides (avoid duplicates)
    for (const k of ancestorHideAdditions) if (!hides.includes(k) && !shows.includes(k)) hides.push(k);
  } catch(e){ /* ancestor-preserve merge failed */ }
  // Build sets for quick lookup
  const hideSet = new Set();
  const showSet = new Set();
  for (const h of hides) {
    for (const k of layerKeyMap.keys()){
      if (k === h || k.startsWith(h + '/')) hideSet.add(k);
    }
    // also hide the parent itself if it's a key
    if (layerKeyMap.has(h)) hideSet.add(h);
  }
  // Ensure ~parent hides the entire subtree: explicitly expand hides to include
  // all descendant keys (in case some logic later treats parents specially).
  const expandedHideSet = new Set(hideSet);
  for (const h of hides) {
    if (!h) return;
    for (const k of layerKeyMap.keys()){
      if (k.startsWith(h + '/')) expandedHideSet.add(k);
    }
    if (layerKeyMap.has(h)) expandedHideSet.add(h);
  }
  for (const s of shows) {
    for (const k of layerKeyMap.keys()){
      if (k === s || k.startsWith(s + '/')) showSet.add(k);
    }
    if (layerKeyMap.has(s)) showSet.add(s);
  }

  // detect parents that are hidden but have a shown descendant
  const parentsWithExceptions = new Set();
  for (const h of hides){
    for (const s of shows){
      if (s === h) continue;
      if (String(s).startsWith(String(h) + '/')) parentsWithExceptions.add(h);
    }
  }

  // Apply initial visibility: default visible unless hidden, but show parents that have exceptions
  for (const [key, el] of layerKeyMap.entries()){
    // If this key is a parent (has direct children), check if it or any of its children should be visible
    const directChildren = getDirectChildrenKeys(key);
    if (directChildren.length > 0) {
      const parentIsHidden = expandedHideSet.has(key) && !(showSet.has(key) || showExceptions.has(key));
      if (parentIsHidden) {
        // hide parent immediately (no animation)
        try {
          el.style.transition = '';
          el.style.opacity = '0';
          el.style.pointerEvents = 'none';
        } catch(e){}
        try { const cb = document.querySelector(`input[data-layer-key="${key}"]`); if (cb) cb.checked = false; } catch(e){}
        // Remove overlay if present
        if (window.overlayManager && typeof window.overlayManager.remove === 'function') window.overlayManager.remove(key);
        continue;
      }
      // In show-only mode (+tokens), only keep parent visible if it or a child is in the show set
      if (shows.length > 0) {
        const parentOrChildInShows = showSet.has(key) || directChildren.some(childKey => showSet.has(childKey));
        if (parentOrChildInShows) {
          toggleLayerVisibility(el, true, { animate: false });
          try { const cb = document.querySelector(`input[data-layer-key="${key}"]`); if (cb) cb.checked = true; } catch(e){}
        } else {
          // Hide immediately (no animation) to prevent fade-in
          try {
            el.style.transition = '';
            el.style.opacity = '0';
            el.style.pointerEvents = 'none';
          } catch(e){}
          try { const cb = document.querySelector(`input[data-layer-key="${key}"]`); if (cb) cb.checked = false; } catch(e){}
          // Remove overlay if present
          if (window.overlayManager && typeof window.overlayManager.remove === 'function') window.overlayManager.remove(key);
        }
        continue;
      }
      // In hide mode or default mode, keep parent visible; children control their own visibility
      toggleLayerVisibility(el, true, { animate: false });
      try { const cb = document.querySelector(`input[data-layer-key="${key}"]`); if (cb) cb.checked = true; } catch(e){}
      // Ensure overlay is attached if needed (autoAttachVideoOverlays will handle this)
      continue;
    }

    // Non-parent layers: handle based on mode
    // In show-only mode, skip this - already handled in first loop
    if (shows.length > 0) {
      continue;
    }

    let visible = true;
    if (showExceptions.has(key) || showSet.has(key)) visible = true;
    else if (parentsWithExceptions.has(key)) visible = true;
    else if (expandedHideSet.has(key)) visible = false;
    else visible = true;
    toggleLayerVisibility(el, visible, { animate: animateGlobally ? true : false });
    // update corresponding checkbox immediately if present
    try { const cb = document.querySelector(`input[data-layer-key="${key}"]`); if (cb) cb.checked = Boolean(visible); } catch(e){}
    // Remove overlay if hiding, ensure attached if showing (autoAttachVideoOverlays will re-attach)
    if (!visible && window.overlayManager && typeof window.overlayManager.remove === 'function') window.overlayManager.remove(key);
  }
  // After all visibility changes, re-attach overlays for visible layers (unless caller will do it)
  if (!skipOverlayUpdate) {
    if (typeof autoAttachVideoOverlays === 'function') autoAttachVideoOverlays();
    if (window.overlayManager && typeof window.overlayManager.update === 'function') window.overlayManager.update();
  }

  // Skip parentsWithExceptions and expandedHideSet passes in show-only mode
  if (shows.length === 0) {
    // For each parent with exceptions, hide its direct children except the ones explicitly shown
    parentsWithExceptions.forEach(parentKey => {
      const children = getDirectChildrenKeys(parentKey);
      children.forEach(childKey => {
        const childEl = layerKeyMap.get(childKey);
        if (!childEl) return;
        const vis = (showSet.has(childKey) || showExceptions.has(childKey));
        toggleLayerVisibility(childEl, vis, { animate: animateGlobally ? true : false });
        try { const cb = document.querySelector(`input[data-layer-key="${childKey}"]`); if (cb) cb.checked = Boolean(vis); } catch(e){}
      });
    });
    // Additionally, for any parent that is explicitly hidden (~parent), hide its direct
    // children as well (unless those children are explicitly shown). This ensures
    // that ~parent hides the entire subtree even when parents remain visible to
    // avoid layout blinking.
    for (const parentKey of Array.from(layerKeyMap.keys())){
      const children = getDirectChildrenKeys(parentKey);
      if (!children.length) continue;
      if (!expandedHideSet.has(parentKey)) continue;
      children.forEach(childKey => {
        const childEl = layerKeyMap.get(childKey);
        if (!childEl) return;
        // If the child is explicitly shown, respect that
        const shouldShow = showSet.has(childKey) || showExceptions.has(childKey);
        toggleLayerVisibility(childEl, shouldShow, { animate: animateGlobally ? true : false });
        try { const cb = document.querySelector(`input[data-layer-key="${childKey}"]`); if (cb) cb.checked = Boolean(shouldShow); } catch(e){}
      });
    }
  }
  // finally refresh checkboxes to set disabled/indeterminate states
  refreshLayerListCheckboxes(vis);
  
  // Always re-attach video overlays based on current hash after all visibility changes
  if (typeof autoAttachVideoOverlays === 'function') autoAttachVideoOverlays(vis);
  if (window.overlayManager && typeof window.overlayManager.update === 'function') window.overlayManager.update();
}

function refreshLayerListCheckboxes(overrideVis){
  const layerList = document.getElementById('layerList'); if (!layerList) return;
  const inputs = Array.from(layerList.querySelectorAll('input[type=checkbox]'));
  let vis = {};
  if (overrideVis) {
    vis = overrideVis;
  } else {
    const parsed = parseHash();
    vis = parsed.vis || {};
  }
  
  // Resolve short keys to full keys for comparison
  const resolveToken = (tok) => {
    if (!tok) return tok;
    if (String(tok).includes('/')) return tok;
    const matches = [];
    for (const k of layerKeyMap.keys()){
      if (String(k).split('/').pop() === String(tok)) matches.push(k);
    }
    return matches.length === 1 ? matches[0] : tok;
  };
  
  const showSet = new Set((vis.show || []).map(resolveToken));
  const hideSet = new Set((vis.hide || []).map(resolveToken));
  for (const cb of inputs) {
    const key = cb.dataset.layerKey;
    if (!key) continue;
    // Only + and ~ affect checkbox state
    if (showSet.size) {
      cb.checked = showSet.has(key);
    } else if (hideSet.size) {
      cb.checked = !hideSet.has(key);
    } else {
      cb.checked = true;
    }
    cb.disabled = false;
    cb.indeterminate = false;
  }
  // Update video buttons independently for @
  const videoBtns = Array.from(layerList.querySelectorAll('button.video-btn'));
  const videoSet = new Set((vis.video || []).map(resolveToken));
  for (const btn of videoBtns) {
    const key = btn.dataset.layerKey;
    if (!key) continue;
    const shortKey = key.split('/').pop();
    const hasVideoToken = videoSet.has(key) || videoSet.has(shortKey);
    if (hasVideoToken) {
      btn.innerHTML = '&#9656;';
      btn.classList.add('active');
      btn.title = 'Video playing (click to hide)';
    } else {
      btn.innerHTML = '&#9656;';
      btn.classList.remove('active');
      btn.title = 'Show image only (click to play video)';
    }
  }
  // Optionally, you can add indeterminate logic for parents if needed
  // Add delegated event listener for checkboxes to update hash with new syntax
  // Legacy layerList change handler removed in favor of setupLayerListEvents()
  // which preserves the filename and params while only updating layer tokens.
}

function findElementByLabel(name){
  // prefer layerKeyMap lookup
  if (layerKeyMap.has(name)) return layerKeyMap.get(name);
  // fallback: prefix match
  for (const [k, el] of layerKeyMap.entries()){
    if (k === name || k.startsWith(name)) return el;
  }
  return null;
}

function collectVisibilityFromList(){
  const layerList = document.getElementById('layerList'); if (!layerList) return { show:[], hide:[] };
  // Hide-only: collect only the keys that are currently unchecked (i.e., hidden)
  const res = { hide: [], show: [] };
  const inputs = Array.from(layerList.querySelectorAll('input[type=checkbox]'));
  inputs.forEach(cb => {
    const key = cb.dataset.layerKey; if (!key) return;
    if (!cb.checked) res.hide.push(key);
  });
  // include explicit exceptions
  for (const k of showExceptions) res.show.push(k);
  return res;
}

function updateHashFromLayerList(){
  // read existing parsed hash to preserve params
  const parsed = parseHash();
  const vis = collectVisibilityFromList();
  /* [updateHashFromLayerList] vis log removed */
  const token = buildCompactHash(parsed.url || '', parsed.params || {}, vis);
  /* [updateHashFromLayerList] token log removed */
  // we need to preserve original 6-field style when present; if not, just write #token
  // Debounce writing the hash so ongoing animations are not cancelled by an
  // immediate hashchange handler. We still mark the write as originating
  // locally so the next hashchange is ignored.
  try { if (__hashWriteTimeout) clearTimeout(__hashWriteTimeout); } catch(e){}
  __hashWriteTimeout = setTimeout(() => {
    try {
      suppressHashFor(150);
      // Write the new compact token directly
      if (location.hash !== '#'+token) {
  /* [updateHashFromLayerList] Writing hash log removed */
        location.hash = '#'+token;
      } else {
  /* [updateHashFromLayerList] Hash unchanged log removed */
      }
    } catch(e) {
  /* Failed to update hash */
    }
    __hashWriteTimeout = null;
  }, 100);
}

document.addEventListener('DOMContentLoaded', ()=>{
  const cp = document.getElementById('copyLink');
  if (cp) {
    cp.addEventListener('click', (ev) => {
      try {
        // Copy the current URL starting with 'svg/#' format (relative path)
        let text = '';
        if (location && location.hash && location.hash.length > 1) {
          text = `svg/${location.hash}`;
        } else {
          const url = currentUrl || '';
          const params = { s: Math.round(state.scale*100)/100, x: Math.round(state.tx*100)/100, y: Math.round(state.ty*100)/100 };
          const vis = collectVisibilityFromList();
          const token = buildCompactHash(url, params, vis);
          text = `svg/#${token}`;
        }
        if (navigator.clipboard && navigator.clipboard.writeText) {
          navigator.clipboard.writeText(text).then(()=> setStatus('link copied'))
            .catch(() => { throw new Error('clipboard failed'); });
        } else {
          // fallback
          const ta = document.createElement('textarea'); ta.value = text; document.body.appendChild(ta); ta.select(); document.execCommand('copy'); document.body.removeChild(ta); setStatus('link copied');
        }

      } catch(e){
        try { setStatus('copy failed'); } catch(e){}
      }
    });
  }
});

// Get the reference frame dimensions - this is the FIXED coordinate system
// that all transformations are relative to
function getReferenceFrame(){
  // Use the #canvas element which is sized to the full viewport
  const canvas = document.getElementById('canvas');
  const canvasRect = canvas ? canvas.getBoundingClientRect() : null;
  const cw = canvasRect ? canvasRect.width : window.innerWidth;
  const ch = canvasRect ? canvasRect.height : window.innerHeight;
  
  // The reference frame is a centered square that fills the viewport as much as possible (no margins)
  const refSize = Math.min(cw, ch);
  const refLeft = (cw - refSize) / 2;
  const refTop = (ch - refSize) / 2;
  
  return {
    size: refSize,
    left: refLeft,
    top: refTop,
    centerX: refLeft + refSize / 2,
    centerY: refTop + refSize / 2
  };
}

function fitToContainer(){
  if (!svgEl || !bbox) return;
  
  // In the reference frame coordinate system:
  // - state.scale 1.0 means the SVG exactly fits the reference square
  // - state.tx=0, state.ty=0 means the SVG is centered in the reference square
  
  // Set state to scale 1.0 (SVG fits perfectly in reference frame) at position 0,0 (centered)
  state.scale = 1.0;
  // Normalized pan offsets relative to ref.size
  state.tx = 0;
  state.ty = 0;
  
  // update reference frame display
  updateReferenceFrame();
  // Re-render SVG and overlays after fitting
  render();
}

function updateReferenceFrame(){
  // The reference frame is a SQUARE that represents the safe area visible
  // across all screen resolutions. The SVG's transformations are all relative
  // to this square: scale 1.0 = fits the square, x=0/y=0 = centered in square.
  const refFrame = document.getElementById('referenceFrame');
  if (!refFrame) return;
  
  const ref = getReferenceFrame();
  
  refFrame.style.width = `${ref.size}px`;
  refFrame.style.height = `${ref.size}px`;
  refFrame.style.left = `${ref.left}px`;
  refFrame.style.top = `${ref.top}px`;
}

function render(){
  if (!svgEl || !bbox) return;
  
  // COORDINATE SYSTEM:
  // 1. Viewport determines reference frame size (centered square, 90% of min dimension)
  // 2. Reference frame determines SVG transform
  //    - state.scale: scale relative to reference frame
  //      * 1.0 = SVG scaled to fit exactly in reference frame
  //      * 2.0 = SVG scaled to 2x the reference frame size
  //    - state.tx, state.ty: translation in pixels relative to reference frame center
  //      * 0,0 = centered in reference frame
  
  const ref = getReferenceFrame();
  
  // Calculate how to fit SVG in reference frame at scale 1.0
  const scaleToFitInRef = Math.min(ref.size / bbox.width, ref.size / bbox.height);
  
  // The actual viewport scale is: (scale relative to ref) * (scale to fit ref)
  const viewportScale = state.scale * scaleToFitInRef;
  
    // At scale 1.0, the SVG should fit exactly in the reference frame
    // Let's verify: when state.scale = 1.0:
    //   - scaledWidth should equal ref.size (if width-constrained) OR
    //   - scaledHeight should equal ref.size (if height-constrained)
    const scaledWidth = bbox.width * viewportScale;
    const scaledHeight = bbox.height * viewportScale;
  
    /* RENDER debug log removed */
  
    // Position: Start at reference frame center, add offsets (in pixels), subtract SVG center offset
  // state.tx/state.ty are normalized offsets in reference-frame units (1.0 = ref.size)
  const offsetXpx = state.tx * ref.size;
  const offsetYpx = state.ty * ref.size;
  const viewportTx = ref.centerX + offsetXpx - (bbox.x + bbox.width/2) * viewportScale;
  const viewportTy = ref.centerY + offsetYpx - (bbox.y + bbox.height/2) * viewportScale;
  
  // Apply transform
  svgEl.style.transform = `translate(${Math.round(viewportTx)}px, ${Math.round(viewportTy)}px) scale(${viewportScale})`;
  
  // Update reference frame display (called here for consistency, also called on resize)
  updateReferenceFrame();

  // Cache the current transform state for overlay calculations
  try {
    window.__svgCurrentTransform = {
      svgEl: svgEl,
      bbox: bbox,
      state: { ...state },
      ref: { ...ref },
      viewportScale: viewportScale,
      viewportTx: viewportTx,
      viewportTy: viewportTy,
      scaleToFitInRef: scaleToFitInRef,
      timestamp: performance.now()
    };
  } catch(e) {}
  
  // Update HTML overlays to match current SVG transform with dual-pass strategy:
  // 1. Immediate update during this frame
  // 2. RAF-scheduled second pass to catch any async updates
  try { 
    if (window.overlayManager && typeof window.overlayManager.update === 'function') {
      window.overlayManager.update(); 
    }
  } catch(e){}
  
  try { 
    cancelAnimationFrame(window.__overlayUpdateRaf || 0);
    window.__overlayUpdateRaf = requestAnimationFrame(() => { 
      if (window.overlayManager && typeof window.overlayManager.update === 'function') {
        window.overlayManager.update(); 
      }
    });
  } catch(e){}
}

// simple tweening helper for numeric state transitions
let __svg_tween_cancel = null;
function tweenProps(from, to, duration = 400, onUpdate){
  if (__svg_tween_cancel) __svg_tween_cancel();
  const start = performance.now();
  const keys = Object.keys(to);
  let rafId = null;
  let cancelled = false;
  // build a cubic-bezier easing function (approximation via Newton-Raphson)
  const bezier = (function(){
    function cubicBezier(p1x,p1y,p2x,p2y){
      const cx = 3 * p1x, bx = 3 * (p2x - p1x) - cx, ax = 1 - cx - bx;
      const cy = 3 * p1y, by = 3 * (p2y - p1y) - cy, ay = 1 - cy - by;
      function sampleCurveX(t){ return ((ax * t + bx) * t + cx) * t; }
      function sampleCurveY(t){ return ((ay * t + by) * t + cy) * t; }
      function sampleCurveDerivativeX(t){ return (3 * ax * t + 2 * bx) * t + cx; }
      function solveCurveX(x){
        let t2 = x;
        for (let i = 0; i < 8; i++){
          const x2 = sampleCurveX(t2) - x;
          const d = sampleCurveDerivativeX(t2);
          if (Math.abs(x2) < 1e-6) return t2;
          if (Math.abs(d) < 1e-6) break;
          t2 = t2 - x2 / d;
        }
        // fallback to bisection
        let t0 = 0, t1 = 1; t2 = x;
        while (t0 < t1){
          const x2 = sampleCurveX(t2);
          if (Math.abs(x2 - x) < 1e-6) return t2;
          if (x > x2) t0 = t2; else t1 = t2;
          t2 = (t1 - t0) * 0.5 + t0;
        }
        return t2;
      }
      return function(x){ return sampleCurveY(solveCurveX(x)); };
    }
    return cubicBezier(0.22, 1, 0.36, 1);
  })();

  function step(now){
    const t = Math.min(1, (now - start) / duration);
    const eased = bezier(t);
    const cur = {};
    keys.forEach(k => {
      const a = typeof from[k]==='number' ? from[k] : 0;
      const b = typeof to[k]==='number' ? to[k] : a;
      cur[k] = a + (b - a) * eased;
    });
    try { onUpdate(cur); } catch(e){}
    if (t < 1 && !cancelled) rafId = requestAnimationFrame(step);
    else {
      // final commit
      try { onUpdate(Object.assign({}, to)); } catch(e){}
      __svg_tween_cancel = null;
    }
  }
  rafId = requestAnimationFrame(step);
  __svg_tween_cancel = () => { cancelled = true; if (rafId) cancelAnimationFrame(rafId); __svg_tween_cancel = null; };
  return __svg_tween_cancel;
}

// animate to target params (s, x, y, r)
function animateTo(params, duration = 900){
  if (!params) return Promise.resolve();
  const target = {
    scale: typeof params.s === 'number' ? params.s : state.scale,
    tx: typeof params.x === 'number' ? params.x : state.tx,
    ty: typeof params.y === 'number' ? params.y : state.ty,
    // rotation intentionally omitted (viewer is pan/zoom-only)
  };
  return new Promise(resolve => {
    tweenProps({ scale: state.scale, tx: state.tx, ty: state.ty },
               { scale: target.scale, tx: target.tx, ty: target.ty },
               duration,
               (cur) => {
                 state.scale = cur.scale; state.tx = cur.tx; state.ty = cur.ty;
                 render();
               });
    // resolve after duration (plus tiny buffer)
    setTimeout(() => { resolve(); }, duration + 20);
  });
}

// Merge provided params with captured defaults so missing fields animate to defaults
function mergeWithDefaults(params){
  const defs = defaultSvgParams || { s: state.scale, x: state.tx, y: state.ty };
  const p = params && typeof params === 'object' ? params : {};
  return {
    s: (typeof p.s === 'number') ? p.s : defs.s,
    x: (typeof p.x === 'number') ? p.x : defs.x,
    y: (typeof p.y === 'number') ? p.y : defs.y
  };
}

// interaction
// Drag-to-pan using reference frame coordinates
svgContainer.addEventListener('mousedown', (e)=>{
  isDragging=true;
  const rect = svgContainer.getBoundingClientRect();
  const x = (e.clientX - rect.left);
  const y = (e.clientY - rect.top);
  dragStart = [x, y];
  // store starting normalized offsets
  const ref = getReferenceFrame();
  dragStartState = { tx: state.tx, ty: state.ty, refSize: ref.size };
  svgContainer.style.cursor = 'grabbing';
  try { setStatus('drag:start'); } catch(e){}
}, { passive: true });
window.addEventListener('mouseup', ()=>{ if (isDragging){ isDragging=false; svgContainer.style.cursor=''; commitHash(); }}, { passive: true });
window.addEventListener('mousemove', (e)=>{
  if (!isDragging || !dragStartState) return;
  const rect = svgContainer.getBoundingClientRect();
  const x = (e.clientX - rect.left);
  const y = (e.clientY - rect.top);
  const dx = x - dragStart[0];
  const dy = y - dragStart[1];
  
  // Convert pixel deltas to normalized reference-frame units
  const ref = getReferenceFrame();
  const scaleFactor = ref.size || dragStartState.refSize || 1;
  state.tx = dragStartState.tx + (dx / scaleFactor);
  state.ty = dragStartState.ty + (dy / scaleFactor);
  
  render();
  try { setStatus(`drag tx:${Math.round(state.tx*100)/100} ty:${Math.round(state.ty*100)/100}`); } catch(e){}
}, { passive: true });

// wheel zoom centered at mouse
// Wheel-based zoom using reference frame coordinates
svgContainer.addEventListener('wheel', (e)=>{
  if (!bbox) return;
  e.preventDefault();
  const rect = svgContainer.getBoundingClientRect();
  if (!rect.width || !rect.height) return;
  
  const zoomFactor = e.deltaY > 0 ? 1.1 : 0.9;
  const ref = getReferenceFrame();
  const scaleToFitRef = Math.min(ref.size / bbox.width, ref.size / bbox.height);
  
  // Mouse position in viewport pixels
  const mouseX = e.clientX - rect.left;
  const mouseY = e.clientY - rect.top;
  
  // We want the point under the mouse to stay fixed during zoom
  // Current viewport scale
  const oldViewportScale = state.scale * scaleToFitRef;
  
  // Mouse position relative to reference frame center
  const mouseRefX = mouseX - ref.centerX;
  const mouseRefY = mouseY - ref.centerY;
  
  // The point in the SVG under the mouse (in SVG coordinates)
  // viewportTx = ref.centerX + state.tx - (bbox.x + bbox.width/2) * viewportScale
  // mouseX = viewportTx + svgX * viewportScale
  // Solving for svgX:
  // svgX = (mouseX - viewportTx) / viewportScale
  //      = (mouseX - ref.centerX - state.tx + (bbox.x + bbox.width/2) * viewportScale) / viewportScale
  const txPx = state.tx * ref.size;
  const tyPx = state.ty * ref.size;
  const svgX = (mouseRefX - txPx) / oldViewportScale + (bbox.x + bbox.width/2);
  const svgY = (mouseRefY - tyPx) / oldViewportScale + (bbox.y + bbox.height/2);
  
  // Apply zoom to scale (scale is relative to reference frame)
  const newScale = state.scale / zoomFactor;
  const newViewportScale = newScale * scaleToFitRef;
  
  // Compute new tx, ty such that svgX, svgY still maps to mouse position
  // mouseX = ref.centerX + newTx + (svgX - (bbox.x + bbox.width/2)) * newViewportScale
  // Solving for newTx:
  // newTx = mouseX - ref.centerX - (svgX - (bbox.x + bbox.width/2)) * newViewportScale
  const newTxPx = mouseRefX - (svgX - (bbox.x + bbox.width/2)) * newViewportScale;
  const newTyPx = mouseRefY - (svgY - (bbox.y + bbox.height/2)) * newViewportScale;
  
  state.scale = newScale;
  // store normalized offsets
  state.tx = newTxPx / ref.size;
  state.ty = newTyPx / ref.size;
  
  render();
  try { 
    const ref = getReferenceFrame();
    setStatus(`scale:${Math.round(state.scale*100)/100} ref:${Math.round(ref.size)}px`); 
  } catch(e){}
  // persist new view/scale to the hash after user stops zooming
  try { scheduleViewHashWrite(100); } catch(e){}
},{ passive: false });

// rotate/zoom input controls removed per user preference

resetBtn.addEventListener('click', ()=>{
  // Animate back to the captured defaults (fit-to-container) then remove view params
  const parsed = parseHash();
  const defs = defaultSvgParams || { s: state.scale, x: state.tx, y: state.ty };
  // animateTo will merge with defaults, but we call with explicit defaults here
  animateTo({ s: defs.s, x: defs.x, y: defs.y }, 700).catch(()=>{}).then(() => {
    // After animation, write a compact hash that preserves url and visibility but omits view params
    try { suppressHashFor(120); } catch(e){}
    const token = buildCompactHash(parsed.url || '', {}, parsed.vis || { show: [], hide: [] });
    location.hash = '#'+token;
  });
});

// Hash management: only write final state on interaction end or reset
let hashTimeout = null;
function commitHash(){
  const url = currentUrl || '';
  const parsed = parseHash();
  const annotations = (parsed && parsed.annotations) ? parsed.annotations : { boxes:[], lines:[], color:'ff0000' };
  // Use same 6-field format for compatibility: view&opacity&boxes&lines&url&<rotation-slot>
  const viewParam = '';
  const opacity = 100;
  // Serialize params into url token
  function buildUrlToken(url, params) {
    let token = url || '';
    for (const k of Object.keys(params || {})) {
      token += `@${k}=${encodeURIComponent(String(params[k]))}`;
    }
    return token;
  }
  const params = { s: Math.round(state.scale*100)/100, x: Math.round(state.tx*100)/100, y: Math.round(state.ty*100)/100 };
  const token = buildCompactHash(url, params, parsed.vis || { show: [], hide: [] });
  suppressHashFor(120);
  /* commitHash debug log removed */
  location.hash = '#'+token;
}

let currentUrl = '';

// When we write location.hash from a UI interaction, the browser fires a hashchange
// event which can re-apply visibility programmatically and cancel in-progress
// animations. Use a timestamp guard so brief UI-originated writes are ignored
// by the hashchange handler for a short window.
try { window.__suppressHashChangeUntil = 0; } catch(e){}
function suppressHashFor(ms){ try { window.__suppressHashChangeUntil = Date.now() + (ms || 120); } catch(e){} }
// debounced hash write to avoid immediate reapplication during animations
let __hashWriteTimeout = null;
let __viewHashTimeout = null;
// Track last fully applied hash fields to avoid skipping real changes
try { window.__lastAppliedHash = { url: '', params: null, vis: null }; } catch(e){}

function scheduleViewHashWrite(delay = 100){
  try { if (__viewHashTimeout) clearTimeout(__viewHashTimeout); } catch(e){}
  __viewHashTimeout = setTimeout(() => {
    try { commitHash(); } catch(e){}
    __viewHashTimeout = null;
  }, delay);
}

// Public: accept messy hrefs like parent does
window.acceptViewerHash = function(raw){
  try{
    if (!raw || typeof raw !== 'string') return false;
    const s = raw.trim();
    const ampIdx = s.indexOf('&&&');
    if (ampIdx !== -1) {
      const after = s.slice(ampIdx+3);
      const token = after.split('&')[0] || '';
      if (!token) return false;
      // parse the legacy token into parsed fields and re-emit in compact form
      const parsed = parseHash.call({ location: { hash: '#'+token } }) || parseHash();
      const params = parsed.params || { s: state.scale, x: state.tx, y: state.ty };
      const compact = buildCompactHash(parsed.url || token, params, parsed.vis || { show: [], hide: [] });
      location.hash = '#'+compact;
      return true;
    }
  const urlMatch = s.match(/(https?:\/\/[^#\s]+|\/[^#\s]+|[^#\s]+\.svg)/i);
    if (urlMatch && urlMatch[0]){
      let url = urlMatch[0];
      try{ const u = new URL(url, location.origin); url = u.pathname + (u.search||''); } catch(e){}
      // emit compact hash using current view/state
  const params = { s: Math.round(state.scale*100)/100, x: Math.round(state.tx*100)/100, y: Math.round(state.ty*100)/100 };
      const compact = buildCompactHash(url, params, { show: [], hide: [] });
      location.hash = '#'+compact; return true;
    }
    return false;
  } catch(e){ return false; }
}

// Initial load (guarded startup to tolerate injected scripts that may throw)
function startViewer(){
  try {
    const parsed = parseHash();
    let url = parsed.url || '';
    // Only load if an explicit .svg filename is present in the hash
    if (!url || url.indexOf('.svg') === -1) {
      setStatus('waiting for #file.svg');
      window.viewerReady = false;
      return Promise.resolve();
    }
    currentUrl = url;
  // Apply params if present (scale/tx/ty) after load
    // queue visibility to apply after load if present
    if (parsed.vis) pendingVis = parsed.vis;
    return loadSVG(url).then(() => {
      try {
        if (parsed.params) {
              // animate into the requested params rather than snapping. Merge
              // missing fields with captured defaults so unspecified values
              // animate toward the default fit-to-container state.
              return animateTo(mergeWithDefaults(parsed.params), 900).catch(()=>{});
            }
      } catch (e) {
  /* Applying params failed */
      }
    }).catch(e => {
  /* Initial load failed */
      pendingVis = null;
    });
  } catch (e) {
  /* startViewer caught */
    return Promise.resolve();
  }
}

// Global non-fatal error handler: log but don't let injected scripts abort viewer startup
window.addEventListener('error', (ev) => {
  // Keep default behavior but ensure it's logged to console for tests
  try { /* PAGE ERROR (non-fatal) */ } catch(e){}
  // do not call ev.preventDefault() so other handlers can run; we only avoid throwing here
});

// Kick off startup asynchronously (guarded)
setTimeout(() => { startViewer(); }, 0);

// respond to external hash changes
window.addEventListener('hashchange', ()=>{
  // If this hashchange was caused by our own UI write, skip re-applying
  // visibility/state to avoid cancelling user-initiated animations.
  const now = Date.now();
  const suppressed = (typeof window.__suppressHashChangeUntil === 'number' && now < window.__suppressHashChangeUntil);
  const parsed = parseHash();
  // Decide whether to override suppression: if url or vis changed from last applied, we must process
  let mustProcess = false;
  try {
    const last = window.__lastAppliedHash || { url: '', params: null, vis: null };
    const visChanged = JSON.stringify(parsed.vis || {}) !== JSON.stringify(last.vis || {});
    const urlChanged = (parsed.url || '') !== (last.url || '');
    mustProcess = urlChanged || visChanged;
  } catch(e) { mustProcess = true; }
  if (suppressed && !mustProcess) { return; }
  if (!parsed) return;
  // if URL changed, load new svg immediately
  if (parsed.url && parsed.url !== currentUrl) {
    currentUrl = parsed.url;
    
    // Before loading new SVG, completely clear all overlays to ensure clean state
    try {
      if (window.overlayManager && window.overlayManager.items) {
        const allKeys = Array.from(window.overlayManager.items.keys());
        allKeys.forEach(key => {
          if (typeof window.overlayManager.remove === 'function') {
            window.overlayManager.remove(key);
          }
        });
      }
    } catch(e) {
      console.warn('[svg] Error clearing overlays before SVG load:', e);
    }
    
    // Load new SVG
    loadSVG(currentUrl).then(()=>{
      // After SVG loads, apply visibility from parsed hash
      if (parsed.vis) {
        try {
          applyVisibilityFromVis(parsed.vis, { animate: false, skipOverlayUpdate: false });
        } catch(e) {
          console.warn('[svg] Error applying visibility after load:', e);
        }
      }
      
      // Explicitly re-attach all video overlays with correct visibility state
      if (typeof autoAttachVideoOverlays === 'function') {
        try {
          autoAttachVideoOverlays(parsed.vis);
        } catch(e) {
          console.warn('[svg] Error attaching video overlays:', e);
        }
      }
      
      // Final overlay update to ensure all positioning is correct
      if (window.overlayManager && typeof window.overlayManager.update === 'function') {
        try {
          window.overlayManager.update();
        } catch(e) {
          console.warn('[svg] Error updating overlays:', e);
        }
      }
    }).catch(e => {
      console.warn('[svg] Error loading SVG:', e);
    });
    try { window.__lastAppliedHash = { url: parsed.url || '', params: parsed.params || null, vis: parsed.vis || null }; } catch(e){}
    return;
  }
  // if same URL but params changed, animate to new params
  if (parsed.url === currentUrl) {
    if (parsed.params) animateTo(mergeWithDefaults(parsed.params), 800).catch(()=>{});
    if (parsed.vis) {
      if (!svgEl) { pendingVis = parsed.vis; }
      else {
        try {
          applyVisibilityFromVis(parsed.vis, { animate: true, skipOverlayUpdate: true });
          // After visibility changes, update overlays to ensure fade in/out
          if (window.overlayManager && typeof window.overlayManager.update === 'function') window.overlayManager.update();
        } catch(e){}
      }
    }
    // Always re-attach overlays in case layers changed
    if (typeof autoAttachVideoOverlays === 'function') autoAttachVideoOverlays();
    try { window.__lastAppliedHash = { url: parsed.url || '', params: parsed.params || null, vis: parsed.vis || null }; } catch(e){}
  }
});

// Auto-attach video overlays based on layer IDs
function autoAttachVideoOverlays(overrideVis){
  try {
    if (!window.overlayManager || !layerKeyMap) return;
    if (typeof window.overlayManager.attachIframe !== 'function') {
      console.warn('[overlay] overlayManager.attachIframe not available');
      return;
    }
  
    let videos = [];
  if (overrideVis && Array.isArray(overrideVis.video)) {
    videos = overrideVis.video;
  } else {
    const parsed = parseHash();
    videos = parsed.vis && Array.isArray(parsed.vis.video) ? parsed.vis.video : [];
  }
  
  // Resolve short tokens to full keys
  const resolveToken = (tok) => {
    if (!tok) return tok;
    if (String(tok).includes('/')) return tok;
    const matches = [];
    for (const k of layerKeyMap.keys()){
      if (String(k).split('/').pop() === tok) matches.push(k);
    }
    return matches.length === 1 ? matches[0] : tok;
  };
  
  const resolvedVideos = videos.map(resolveToken);
  
    // First pass: remove all overlays that are no longer in the video list
    if (window.overlayManager.items && window.overlayManager.items.entries) {
      try {
        for (const [key] of window.overlayManager.items.entries()) {
          const shortKey = key.split('/').pop();
          const isVideo = resolvedVideos.includes(key) || resolvedVideos.includes(shortKey);
          if (!isVideo) {
            window.overlayManager.remove(key);
          }
        }
      } catch(e) {
        console.warn('[overlay] Error removing overlays:', e.message);
      }
    }
  
    // Second pass: for each layer in the map, attach video overlays if needed
    for (const [key, el] of layerKeyMap.entries()) {
      try {
        const shortKey = key.split('/').pop();
        const isVideo = resolvedVideos.includes(key) || resolvedVideos.includes(shortKey);
    
    // Skip if not a video layer
    if (!isVideo) {
      continue;
    }
    
    // Check if layer is visible enough to host overlay. Ignore opacity to allow fade-in.
    let isDisplayed = true;
    try {
      const cs = window.getComputedStyle(el);
      isDisplayed = cs.display !== 'none' && cs.visibility !== 'hidden';
    } catch(e) {
      console.warn('[overlay] getComputedStyle failed for', key, ':', e.message);
      // Assume displayed if we can't get computed style
      isDisplayed = true;
    }
    
    if (!isDisplayed) {
      // Remove overlay if layer is hidden
      if (window.overlayManager && typeof window.overlayManager.remove === 'function') {
        window.overlayManager.remove(key);
      }
      continue;
    }
    
    // Determine iframe URL for video layers
    let url = null;
    const id = el.id || shortKey;
    const vimeoMatch = id.match(/^vimeo-(\d+)$/i);
    if (vimeoMatch){
      const videoId = vimeoMatch[1];
      url = `../vim/#vimeo.com%2F${videoId}/autoplay,loop,cover`;
    }
    const embedMatch = id.match(/^embed-(.+)$/i);
    if (embedMatch && !url){
      const embedPath = embedMatch[1];
      url = `/vim/#${embedPath}`;
    }
    if (!url && id.startsWith('vimeo-')) {
      const videoId = id.replace('vimeo-', '');
      if (/^\d+$/.test(videoId)) {
        url = `../vim/#vimeo.com%2F${videoId}/autoplay,loop,cover`;
      }
    }
    
    // Attach iframe if we have a URL and layer is visible
    if (url && isVideo && isDisplayed){
      const item = window.overlayManager.items && window.overlayManager.items.get(key);
      let iframe = null;
      let needsAttach = true;
      if (item && item.el && item.el.querySelector) {
        iframe = item.el.querySelector('iframe');
        if (iframe && iframe.src && iframe.src === url) {
          needsAttach = false;
        }
      }
      if (needsAttach) {
        window.overlayManager.attachIframe(key, url);
        } else if (iframe && iframe.src !== url) {
          iframe.src = url;
        }
      }
      } catch(e) {
        console.warn('[overlay] Error processing layer', key, ':', e.message);
      }
    }
  
    // Update overlays after attaching/removing
    if (window.overlayManager && typeof window.overlayManager.update === 'function') {
      window.overlayManager.update();
    }
  } catch(e) {
    console.error('[overlay] autoAttachVideoOverlays failed:', e);
  }
}

// Update reference frame and SVG transform on window resize
window.addEventListener('resize', () => {
    try { 
      updateReferenceFrame();
      render(); // Re-render SVG to match new reference frame scale
      // Ensure overlays update after resize
      if (window.overlayManager && typeof window.overlayManager.update === 'function') window.overlayManager.update();
    } catch(e){}
  }, { passive: true });

  // Ensure overlays and iframes do not add non-passive touch event listeners
  // Remove any direct listeners on overlays/iframes
  function makeOverlayPassive(overlay) {
    if (!overlay) return;
    // Remove any touchstart/touchmove listeners
    overlay.removeEventListener('touchstart', null);
    overlay.removeEventListener('touchmove', null);
    // Add passive listeners for scroll/zoom events
    overlay.addEventListener('touchstart', function() {}, { passive: true });
    overlay.addEventListener('touchmove', function() {}, { passive: true });
    overlay.addEventListener('wheel', function() {}, { passive: true });
  }
  // Patch overlays after update
  if (window.overlayManager && window.overlayManager.items) {
    for (const item of window.overlayManager.items.values()) {
      makeOverlayPassive(item.el);
      const iframe = item.el && item.el.querySelector && item.el.querySelector('iframe');
      if (iframe) makeOverlayPassive(iframe);
    }
  }

window.viewerReady = false;

// Keyboard shortcut to toggle interface (sidebar/status/reference frame) on/off
// Works both standalone and embedded
function toggleInterface() {
  document.body.classList.toggle('ui-hidden');
}
document.addEventListener('keydown', function(e) {
  // Ignore if typing in an input field
  if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
  // Use code instead of key to work across keyboard layouts
  if (e.code === 'KeyE') {
    e.preventDefault();
    toggleInterface();
  } else if (e.code === 'KeyF') {
    // Foreground-only toggle - relay to parent
    e.preventDefault();
    if (window.parent && window.parent !== window) {
      window.parent.postMessage({ type: 'toggle-foreground-edit' }, '*');
    }
  } else if (e.code === 'KeyB') {
    // Background-only toggle - relay to parent
    e.preventDefault();
    if (window.parent && window.parent !== window) {
      window.parent.postMessage({ type: 'toggle-background-edit' }, '*');
    }
  }
});
</script>

<!-- Overlay manager: position HTML/iframe layers to follow SVG elements -->
<script>
(function(){
  const root = document.getElementById('overlays');
  const items = new Map(); // key -> { target: SVGElement, el: HTMLElement|SVGForeignObjectElement, mode: 'html'|'svg-fo' }

  function getTargetForKey(key){
    if (!key) return null;
    // Prefer layerKeyMap (built by viewer) for hierarchical keys
    if (window.layerKeyMap && typeof window.layerKeyMap.get === 'function'){
      const el = window.layerKeyMap.get(key);
      if (el) return el;
    }
    // Fallback: search by plain id in current svg
    try{
      if (window.svgEl && typeof window.svgEl.querySelector === 'function'){
        const byId = window.svgEl.querySelector('#'+CSS.escape(String(key)));
        if (byId) return byId;
      }
    }catch(e){}
    try{
      const byIdDoc = document.getElementById(String(key));
      if (byIdDoc && byIdDoc.ownerSVGElement) return byIdDoc;
    }catch(e){}
    return null;
  }

  function updateOne(key){
    const item = items.get(key);
    if (!item || !item.target || !item.el) return;
    const el = item.target;
    const overlay = item.el;
    try{
      // If this overlay is an SVG foreignObject (in-SVG), copy exact attributes from source element
      const isSvgFO = overlay && overlay.namespaceURI === 'http://www.w3.org/2000/svg' && overlay.tagName.toLowerCase() === 'foreignobject';
      if (isSvgFO) {
        // Strategy: Copy x, y, width, height, and transform attributes directly from the source element
        // This ensures perfect sync regardless of element type (g, use, image, path, etc.)
        
        // First, check if element has direct x/y/width/height attributes (e.g., <use> or <image>)
        let x = null, y = null, width = null, height = null, transform = null;
        
        // Try to get attributes from the element itself
        if (el.hasAttribute && el.getAttribute) {
          if (el.hasAttribute('x')) x = el.getAttribute('x');
          if (el.hasAttribute('y')) y = el.getAttribute('y');
          if (el.hasAttribute('width')) width = el.getAttribute('width');
          if (el.hasAttribute('height')) height = el.getAttribute('height');
          if (el.hasAttribute('transform')) transform = el.getAttribute('transform');
        }
        
        // If the element is a <g> (group), check its first child (like <use>)
        if ((x === null || width === null) && el.tagName && el.tagName.toLowerCase() === 'g') {
          try {
            const firstChild = el.querySelector('use, image, rect');
            if (firstChild) {
              if (x === null && firstChild.hasAttribute('x')) x = firstChild.getAttribute('x');
              if (y === null && firstChild.hasAttribute('y')) y = firstChild.getAttribute('y');
              if (width === null && firstChild.hasAttribute('width')) width = firstChild.getAttribute('width');
              if (height === null && firstChild.hasAttribute('height')) height = firstChild.getAttribute('height');
            }
          } catch(e) {/* ignore */}
        }
        
        // Always use bbox for dimensions to account for SVG scaling/viewBox transforms
        // Only use attributes for position if bbox position is unavailable
        const bb = el.getBBox();
        if (!bb) { overlay.setAttribute('display','none'); return; }
        
        // Use bbox for all dimensions (this accounts for SVG viewBox scaling)
        x = String(bb.x);
        y = String(bb.y);
        width = String(bb.width);
        height = String(bb.height);
        
        // Keep transform from element attributes
        if (el.hasAttribute && el.hasAttribute('transform')) {
          transform = el.getAttribute('transform');
        }
        
        // Apply attributes to foreignObject
        overlay.removeAttribute('display');
        // Strip 'px' units for SVG attributes to avoid scaling errors
        function stripPx(val) {
          if (typeof val === 'string' && val.endsWith('px')) return val.slice(0, -2);
          return val;
        }
        overlay.setAttribute('x', stripPx(x));
        overlay.setAttribute('y', stripPx(y));
        overlay.setAttribute('width', stripPx(width));
        overlay.setAttribute('height', stripPx(height));
        
        // Copy transform attribute if present, otherwise remove it
        if (transform) {
          overlay.setAttribute('transform', transform);
        } else {
          overlay.removeAttribute('transform');
        }
        
        // Get inner div and Safari detection before using them
        const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
        const innerDiv = overlay.querySelector('div[xmlns="http://www.w3.org/1999/xhtml"]');
        
        // Ensure the inner <div> and <iframe> fill the foreignObject (which has the correct dimensions)
        if (innerDiv) {
          innerDiv.style.width = '100%';
          innerDiv.style.height = '100%';
          const iframe = innerDiv.querySelector('iframe');
          if (iframe) {
            // Remove any width/height attributes to prevent conflicts with CSS
            iframe.removeAttribute('width');
            iframe.removeAttribute('height');
            // Set CSS sizing to fill parent
            iframe.style.width = '100%';
            iframe.style.height = '100%';
          }
        }
        
        // Safari-specific fix: Safari doesn't handle transform on foreignObject well
        // Apply transform via CSS on inner div for Safari only
        
        if (isSafari && transform && innerDiv) {
          // For Safari: remove SVG transform and apply as CSS transform on inner div
          overlay.removeAttribute('transform');
          innerDiv.style.transformOrigin = '0 0';
          innerDiv.style.transform = transform.replace(/\s+/g, ' ');
        } else if (innerDiv) {
          // For other browsers: clear any CSS transform on inner div
          innerDiv.style.transform = '';
          innerDiv.style.transformOrigin = '';
        }

        // Mirror visibility/opacity/transition via style
        const cs = window.getComputedStyle(el);
        const targetVisibility = cs.visibility || 'visible';
        const targetDisplay = (cs.display === 'none') ? 'none' : 'inline';
        const elTransition = el.style.transition || '';
        const elOpacity = el.style.opacity || cs.opacity || '1';
        overlay.style.transition = elTransition;
        overlay.style.opacity = elOpacity;
        overlay.style.visibility = targetVisibility;
        
        if (targetDisplay === 'none' || parseFloat(elOpacity) < 0.01 && (!elTransition || elTransition === 'none')) {
          overlay.setAttribute('display','none');
        } else {
          overlay.removeAttribute('display');
        }
        return; // SVG-FO path handled
      }
      const bb = el.getBBox();
      if (!bb) { overlay.style.display = 'none'; return; }

      // Prefer cached transform from render() for perfect sync
      // Use cached values if available and fresh (within 500ms)
      let ref, vb, st, scaleToFitInRef, viewportScale, viewportTx, viewportTy;
      
      const useCache = window.__svgCurrentTransform && 
                       window.__svgCurrentTransform.timestamp && 
                       (performance.now() - window.__svgCurrentTransform.timestamp) < 500 &&
                       window.__svgCurrentTransform.ref &&
                       window.__svgCurrentTransform.bbox &&
                       window.__svgCurrentTransform.state &&
                       isFinite(window.__svgCurrentTransform.scaleToFitInRef) &&
                       isFinite(window.__svgCurrentTransform.viewportScale);
      
      if (useCache) {
        ref = window.__svgCurrentTransform.ref;
        vb = window.__svgCurrentTransform.bbox;
        st = window.__svgCurrentTransform.state;
        scaleToFitInRef = window.__svgCurrentTransform.scaleToFitInRef;
        viewportScale = window.__svgCurrentTransform.viewportScale;
        viewportTx = window.__svgCurrentTransform.viewportTx;
        viewportTy = window.__svgCurrentTransform.viewportTy;
      } else {
        // Fallback: recalculate (stale, but better than nothing)
        ref = (typeof getReferenceFrame === 'function') ? getReferenceFrame() : {
          size: Math.min(window.innerWidth || 0, window.innerHeight || 0),
          centerX: (window.innerWidth || 0) / 2,
          centerY: (window.innerHeight || 0) / 2
        };
        vb = (typeof bbox !== 'undefined' && bbox) ? bbox : (svgEl && svgEl.getBBox ? svgEl.getBBox() : bb);
        st = (typeof state !== 'undefined' && state) ? state : { tx: 0, ty: 0, scale: 1 };
        if (!ref.size || ref.size <= 0 || !vb.width || vb.width <= 0) {
          overlay.style.display = 'none';
          return;
        }
        scaleToFitInRef = Math.min(ref.size / vb.width, ref.size / vb.height);
        viewportScale = st.scale * scaleToFitInRef;
        const offsetXpx = st.tx * ref.size;
        const offsetYpx = st.ty * ref.size;
        viewportTx = ref.centerX + offsetXpx - (vb.x + vb.width / 2) * viewportScale;
        viewportTy = ref.centerY + offsetYpx - (vb.y + vb.height / 2) * viewportScale;
      }

      const mapPoint = (x, y) => ({
        x: viewportTx + x * viewportScale,
        y: viewportTy + y * viewportScale
      });
      
      // Apply element's internal SVG transform (if any) before mapping to CSS pixels
      // getCTM() gives the matrix from the element's local coordinate space to the SVG viewport (pre-CSS)
      let ctm = null;
      try {
        if (typeof el.getCTM === 'function') {
          ctm = el.getCTM();
          // Validate CTM has sensible values
          if (ctm && (!isFinite(ctm.a) || !isFinite(ctm.b) || !isFinite(ctm.c) || !isFinite(ctm.d) || !isFinite(ctm.e) || !isFinite(ctm.f))) {
            ctm = null; // discard invalid CTM
          }
        }
      } catch(e) {
        ctm = null; // getCTM() failed, continue without it
      }
      
      // Map SVG coordinates through CTM to viewport coordinates
      const mapSvgToViewport = (svgX, svgY) => {
        if (ctm) {
          try {
            const p = new DOMPoint(svgX, svgY).matrixTransform(ctm);
            // Validate transformed point
            if (isFinite(p.x) && isFinite(p.y)) {
              return { x: p.x, y: p.y };
            }
          } catch(e) {
            // matrixTransform failed, fall back to direct mapping
          }
        }
        return { x: svgX, y: svgY };
      };
      
      // Then map viewport coordinates to CSS screen coordinates
      const mapViewportToScreen = (vportX, vportY) => {
        return mapPoint(vportX, vportY);
      };
      
      // Combined mapping: SVG → viewport → screen
      const mapLocal = (svgX, svgY) => {
        const vportCoords = mapSvgToViewport(svgX, svgY);
        return mapViewportToScreen(vportCoords.x, vportCoords.y);
      };

      let width, height, rotation, tx, ty;

      // Prefer true path corners when available
      if (el.tagName === 'path' && el.getAttribute) {
        try {
          const d = el.getAttribute('d');
          if (d) {
            const coords = [];
            // Support negative and decimal values for coordinates
            const matches = d.matchAll(/([ML])\s*([+-]?\d*\.?\d+)[,\s]+([+-]?\d*\.?\d+)/g);
            for (const match of matches) {
              coords.push({ x: parseFloat(match[2]), y: parseFloat(match[3]) });
              if (coords.length >= 4) break;
            }
            if (coords.length >= 4) {
              // Map the first four path points to screen coords
              const pts = [
                mapLocal(coords[0].x, coords[0].y),
                mapLocal(coords[1].x, coords[1].y),
                mapLocal(coords[2].x, coords[2].y),
                mapLocal(coords[3].x, coords[3].y)
              ];
              // Identify corners robustly by y-rank: top pair = two smallest y, bottom pair = two largest y
              const byY = pts.slice().sort((a,b)=> a.y - b.y);
              const topPair = byY.slice(0,2).sort((a,b)=> a.x - b.x); // [TL, TR]
              const bottomPair = byY.slice(2,4).sort((a,b)=> a.x - b.x); // [BL, BR]
              const tlp = topPair[0];
              const trp = topPair[1];
              const blp = bottomPair[0];
              // Compute width/height and rotation (orthonormal axes)
              const vx = { x: trp.x - tlp.x, y: trp.y - tlp.y };
              const vy = { x: blp.x - tlp.x, y: blp.y - tlp.y };
              width = Math.hypot(vx.x, vx.y);
              height = Math.hypot(vy.x, vy.y);
              rotation = Math.atan2(vx.y, vx.x) * 180 / Math.PI;
              tx = tlp.x; ty = tlp.y;
            }
          }
        } catch(e) {/* fall through to bbox */}
      }

      // Fallback: use bbox corners mapped through the viewer transform
      if (tx == null || ty == null) {
        // Validate bbox dimensions
        if (!bb || !isFinite(bb.width) || !isFinite(bb.height) || bb.width <= 0 || bb.height <= 0) { 
          overlay.style.display = 'none'; 
          return; 
        }
        const pts = [
          mapLocal(bb.x, bb.y),
          mapLocal(bb.x + bb.width, bb.y),
          mapLocal(bb.x + bb.width, bb.y + bb.height),
          mapLocal(bb.x, bb.y + bb.height)
        ];
        const byY = pts.slice().sort((a,b)=> a.y - b.y);
        const topPair = byY.slice(0,2).sort((a,b)=> a.x - b.x); // [TL, TR]
        const bottomPair = byY.slice(2,4).sort((a,b)=> a.x - b.x); // [BL, BR]
        const tlp = topPair[0];
        const trp = topPair[1];
        const blp = bottomPair[0];
        const vx = { x: trp.x - tlp.x, y: trp.y - tlp.y };
        const vy = { x: blp.x - tlp.x, y: blp.y - tlp.y };
        width = Math.hypot(vx.x, vx.y);
        height = Math.hypot(vy.x, vy.y);
        rotation = Math.atan2(vx.y, vx.x) * 180 / Math.PI;
        tx = tlp.x; ty = tlp.y;
      }

      // Apply unambiguous translate+rotate, with width/height defining scale
      // Clamp width/height to prevent NaN or infinite sizes from crashing
      const finalWidth = Math.max(0.001, Math.min(1e6, isFinite(width) ? width : 1));
      const finalHeight = Math.max(0.001, Math.min(1e6, isFinite(height) ? height : 1));
      const finalRotation = isFinite(rotation) ? rotation : 0;
      const finalTx = isFinite(tx) ? tx : 0;
      const finalTy = isFinite(ty) ? ty : 0;
      
      overlay.style.transform = `translate(${finalTx}px, ${finalTy}px) rotate(${finalRotation}deg)`;
      overlay.style.width = finalWidth + 'px';
      overlay.style.height = finalHeight + 'px';
      
      // mirror visibility/opacity/transition with smooth transitions
      const cs = window.getComputedStyle(el);
      const targetVisibility = cs.visibility || 'visible';
      const targetDisplay = (cs.display === 'none') ? 'none' : 'block';
      
      // Mirror the element's inline styles exactly - this is critical for sync
      // Use inline style values, not computed, so we get the transition target values
      const elTransition = el.style.transition || '';
      const elOpacity = el.style.opacity || cs.opacity || '1';
      
      // Always copy the element's transition exactly
      overlay.style.transition = elTransition;
      
      // Mirror opacity from inline style (the target value during transitions)
      overlay.style.opacity = elOpacity;
      overlay.style.visibility = targetVisibility;
      
      // Keep display:block during fade transitions; only hide when opacity is 0 and no transition
      const opacityValue = parseFloat(elOpacity);
      if (targetDisplay === 'none' || (opacityValue < 0.01 && (!elTransition || elTransition === 'none' || elTransition === ''))) {
        overlay.style.display = 'none';
      } else {
        overlay.style.display = 'block';
      }
    }catch(e){ /* ignore per-frame errors */ }
  }

  function update(){
    for (const k of items.keys()) updateOne(k);
  }

  function attachToLayer(key, element, iframeSrc){
    try{
      // Check if overlay already exists for this key
      const existing = items.get(String(key));
      if (existing && existing.el) {
        // Update iframe src if needed
        if (existing.iframe && iframeSrc && existing.iframe.src !== iframeSrc) {
          existing.iframe.src = iframeSrc;
        }
        return existing.el;
      }
      
      const target = getTargetForKey(key);
      if (!target) { console.warn('[overlay] target not found for key', key); return null; }
      const el = (typeof element === 'function') ? element() : element;
      if (!el) return null;
      // Determine mode: use SVG foreignObject for correct z-ordering
      const isSvgMode = true;
      if (isSvgMode) {
        // Build foreignObject with XHTML div+iframe
        const fo = document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject');
        fo.setAttribute('x','0'); fo.setAttribute('y','0');
        fo.setAttribute('width','1'); fo.setAttribute('height','1');
        fo.style.pointerEvents = 'auto';
        // insert after target so it paints above target but below following siblings
        try { target.parentNode.insertBefore(fo, target.nextSibling); } catch(e) { try{ target.parentNode.appendChild(fo); }catch(e){} }

        const xhtmlDiv = document.createElementNS('http://www.w3.org/1999/xhtml', 'div');
        xhtmlDiv.setAttribute('xmlns','http://www.w3.org/1999/xhtml');
        xhtmlDiv.style.width = '100%';
        xhtmlDiv.style.height = '100%';
        xhtmlDiv.style.pointerEvents = 'auto';

        // If the provided element is an iframe/element, append into xhtmlDiv; else create iframe
        let iframeEl = el;
        if (!(el instanceof HTMLIFrameElement)) {
          const iframe = document.createElement('iframe');
          iframe.src = '';
          iframe.setAttribute('frameborder','0');
          iframe.setAttribute('allow','autoplay; fullscreen; picture-in-picture');
          iframe.setAttribute('playsinline', '');
          iframe.setAttribute('webkit-playsinline', '');
          iframe.style.width = '100%';
          iframe.style.height = '100%';
          iframe.style.border = '0';
          iframe.style.display = 'block';
          iframeEl = iframe;
        }
        xhtmlDiv.appendChild(iframeEl);
        fo.appendChild(xhtmlDiv);
        // Track item
        items.set(String(key), { target, el: fo, mode: 'svg-fo', iframe: iframeEl, iframeSrc });
        // Initial update
        updateOne(String(key));

        // Lazy load: only set iframe.src when visible (IntersectionObserver or fallback)
        function setIframeSrcIfVisible(){
          try {
            if (!iframeEl) return;
            if (iframeEl.src && iframeEl.src === iframeSrc) return;
            // Check if overlay is visible in viewport
            const rect = fo.getBoundingClientRect();
            const inViewport = rect.bottom > 0 && rect.top < window.innerHeight && rect.right > 0 && rect.left < window.innerWidth;
            if (inViewport && iframeSrc) {
              iframeEl.src = iframeSrc;
            }
          } catch(e) {
            console.warn('[overlay] setIframeSrcIfVisible failed:', e.message);
          }
        }
        if ('IntersectionObserver' in window && iframeSrc) {
          try {
            const observer = new IntersectionObserver((entries) => {
              try {
                entries.forEach(entry => {
                  if (entry.isIntersecting) {
                    if (iframeEl.src !== iframeSrc) iframeEl.src = iframeSrc;
                  }
                });
              } catch(e) {
                console.warn('[overlay] IntersectionObserver callback failed:', e.message);
              }
            }, { threshold: 0.01 });
            observer.observe(fo);
            // Store observer for cleanup
            fo.__iframeObserver = observer;
          } catch(e) {
            console.warn('[overlay] IntersectionObserver setup failed, using fallback:', e.message);
            // Fallback: set src if visible now
            setTimeout(setIframeSrcIfVisible, 100);
            window.addEventListener('scroll', setIframeSrcIfVisible, { passive: true });
            window.addEventListener('resize', setIframeSrcIfVisible, { passive: true });
          }
        } else if (iframeSrc) {
          // Fallback: set src if visible now
          setTimeout(setIframeSrcIfVisible, 100);
          window.addEventListener('scroll', setIframeSrcIfVisible, { passive: true });
          window.addEventListener('resize', setIframeSrcIfVisible, { passive: true });
        }
        return fo;
      } else {
        // Legacy HTML overlay mode
        el.classList.add('overlay');
        el.style.position = 'absolute';
        el.style.left = '0';
        el.style.top = '0';
        el.style.transformOrigin = '0 0';
        el.style.willChange = 'transform,width,height';
        el.dataset.layerKey = String(key);
        root && root.appendChild(el);
        items.set(String(key), { target, el, mode: 'html' });
        updateOne(String(key));
        return el;
      }
    }catch(e){ return null; }
  }

  function remove(key){
    const item = items.get(String(key));
    if (item) {
      // Clean up IntersectionObserver if present (for lazy iframe loading)
      if (item.el && item.el.__iframeObserver && typeof item.el.__iframeObserver.disconnect === 'function') {
        item.el.__iframeObserver.disconnect();
        delete item.el.__iframeObserver;
      }
      // Clean up scroll/resize listeners if present (for fallback lazy loading)
      if (item.iframe && item.iframeSrc) {
        const setIframeSrcIfVisible = item.iframe.__setIframeSrcIfVisible;
        if (setIframeSrcIfVisible) {
          window.removeEventListener('scroll', setIframeSrcIfVisible);
          window.removeEventListener('resize', setIframeSrcIfVisible);
          delete item.iframe.__setIframeSrcIfVisible;
        }
      }
      try{ item.el.remove(); }catch(e){}
      items.delete(String(key));
    }
  }

  function attachIframe(key, src, attrs){
    // No need to set width/height - foreignObject and CSS handle all sizing
    const fo = attachToLayer(key, () => {
      const iframe = document.createElement('iframe');
      iframe.src = '';
      iframe.setAttribute('frameborder','0');
      iframe.setAttribute('allow','autoplay; fullscreen; picture-in-picture');
      iframe.setAttribute('playsinline', '');
      iframe.setAttribute('webkit-playsinline', '');
      iframe.setAttribute('referrerpolicy', 'strict-origin-when-cross-origin');
      iframe.setAttribute('title', 'video-embed');
      iframe.style.width = '100%';
      iframe.style.height = '100%';
      iframe.style.border = '0';
      iframe.style.display = 'block';
      iframe.style.touchAction = 'auto';
      try{ Object.entries(attrs || {}).forEach(([k,v]) => iframe.setAttribute(k, String(v))); }catch(e){}
      return iframe;
    }, src);
    return fo;
  }

  // Expose API (including items for visibility checks)
  window.overlayManager = { attachToLayer, attachIframe, update, remove, items };
})();
</script>
</body>
</html>
