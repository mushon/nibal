<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Dynamic Mapbox Map with Hash Control</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    html, body, #map {
      height: 100%;
      margin: 0;
      padding: 0;
      width: 100%;
      background: #333; 
    }
    #layer-controls {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(255,255,255,0.9);
      padding: 10px;
      border-radius: 4px;
      z-index: 1;
      font-family: sans-serif;
    }
    #distance-ticker {
      position: absolute;
      width: 80px;
      height: 80px;
      border-radius: 50%;
      display: none;
      align-items: center;
      justify-content: center;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      font-size: 14px;
      font-weight: 600;
      color: #fff;
      background: rgba(0,0,0,0.3);
      border: #fffa solid 1px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
      pointer-events: none;
      z-index: 10;
      transform: translate(-50%, -125%);
    }
    #distance-ticker.active {
      display: flex;
    }
  </style>
  <script src="https://api.mapbox.com/mapbox-gl-js/v3.15.0/mapbox-gl.js"></script>
  <link href="https://api.mapbox.com/mapbox-gl-js/v3.15.0/mapbox-gl.css" rel="stylesheet" />
  <!-- Mapbox RTL Text Plugin is loaded on demand via setRTLTextPlugin; do not include as a <script> tag. -->
  <!-- Removed any Python-in-the-browser scripts (e.g., Pyodide, Brython) to prevent py.parse errors -->
  <!-- Add JSZip and togeojson for KMZ/KML support -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://unpkg.com/togeojson@0.16.0/dist/togeojson.js"></script>
  <!-- Add Papa Parse for robust CSV parsing -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
</head>
<body>
<div id="map"></div>
<div id="layer-controls"></div>
<div id="distance-ticker"></div>
<script>
// Hide control panel if in an iframe
if (window.self !== window.top) {
  document.addEventListener('DOMContentLoaded', function() {
    var controls = document.getElementById('layer-controls');
    if (controls) controls.style.display = 'none';
  });
}
// Sample Mapbox access token (replace with your own for production)
mapboxgl.accessToken = 'pk.eyJ1IjoiYnRzZWxlbW9yZyIsImEiOiJjbWhuNnF6djQwNTVlMnNzZjAxd2dqeWFyIn0.jw164iQiqRTNP1QMu-cbTg';

// Enable RTL text plugin for proper display of Arabic, Hebrew, and other RTL languages
mapboxgl.setRTLTextPlugin(
  'https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-rtl-text/v0.2.3/mapbox-gl-rtl-text.js',
  null,
  true // lazy load - only loads when needed
);

// Sample style
const style = 'mapbox://styles/btselemorg/cmhncne5l004p01qu9tpp7ih8';

// Layers to toggle (layer ids must exist in the style)
// Will be populated with all layers from the style after map load
let allStyleLayers = [];

// Will hold the style default visibility for each layer
const styleDefaultVisibility = {};

// Track externally loaded layers (not part of original style)
const externalLayers = new Set();

// Default camera
const defaultCamera = {
  center: [34.3537, 31.4238], // Custom view
  zoom: 10,
  bearing: 37.6,
  pitch: 0
};

// Parse hash: #lat,lng,zoom,bearing,pitch/+layer1,-layer2/load:filename
function parseHash() {
  const hash = window.location.hash.replace('#', '');
  if (!hash) return { camera: { ...defaultCamera }, layers: allStyleLayers.map(l => l.id), dynamicGeojsonToLoad: [] };
  let cameraStr = '', layersStr = '', followId = null;
  const parts = hash.split('/');
  const restParts = [];
  for (let i = 0; i < parts.length; i++) {
    if (parts[i].startsWith('load:')) {
      continue;
    } else if (parts[i].length > 0) {
      restParts.push(parts[i]);
    }
  }
  cameraStr = restParts[0] || '';
  layersStr = restParts[1] || '';
  const cameraParts = cameraStr ? cameraStr.split(',').map(Number) : [];
  let layersOn = allStyleLayers.map(l => l.id);
  let dynamicGeojsonToLoad = [];
  if (layersStr) {
    layersOn = [];
    const layerState = {};
    layersStr.split(',').forEach(token => {
      // Support +id:follow, ~id:follow, +id(source):follow, and +s2:YYYYMMDD
      // token examples: +name, ~name, +name:follow, +name(source), +name(source):follow, +s2:20240215
      // Updated regex to allow colons in layer names (except for the :follow suffix)
      const match = token.match(/^([+~])([^(]+?)(?:\(([^)]+)\))?(?::follow)?$/);
      if (!match) {
        console.warn('[HASH] Failed to parse layer token:', token);
        return;
      }
      const [, sign, lname, sourceHint] = match;
      // Always use the id without :follow for loading/toggling
      layerState[lname] = { sign, sourceHint: sourceHint || null, follow: token.endsWith(':follow') };
    });
    Object.entries(layerState).forEach(([lname, { sign, sourceHint, follow }]) => {
      if (sign === '+') {
        if (!allStyleLayers.some(l => l.id === lname)) {
          // Check if this is a Sentinel-2 layer (format: s2:YYYYMMDD)
          const s2Match = lname.match(/^s2:(\d{8})$/);
          if (s2Match) {
            const dateStr = s2Match[1];
            dynamicGeojsonToLoad.push({ name: lname, sourceHint: sourceHint || 'overlay', isS2: true, s2Date: dateStr });
          } else {
            // Check if this is a Wayback layer (format: wayback:YYYYMMDD)
            const waybackMatch = lname.match(/^wayback:(\d{8})$/);
            if (waybackMatch) {
              const dateStr = waybackMatch[1];
              dynamicGeojsonToLoad.push({ name: lname, sourceHint: sourceHint || 'overlay', isWayback: true, waybackDate: dateStr });
            } else {
              // Regular GeoJSON/CSV layer
              dynamicGeojsonToLoad.push({ name: lname, sourceHint });
            }
          }
        }
        layersOn.push(lname);
        if (follow) followId = lname;
      } else if (sign === '~') {
        // For ~new-id, load as invisible (unchecked) dynamic layer
        if (!allStyleLayers.some(l => l.id === lname)) {
          dynamicGeojsonToLoad.push({ name: lname, sourceHint });
        }
        if (follow) followId = lname;
        // Do NOT add to layersOn, so it is not visible/checked
      }
    });
  }
  // Helper: treat 0 as a valid numeric value (don't use || which treats 0 as falsy)
  function pickNum(val, def) {
    return (typeof val === 'number' && !isNaN(val)) ? val : def;
  }

  return {
    camera: {
      center: [pickNum(cameraParts[1], defaultCamera.center[0]), pickNum(cameraParts[0], defaultCamera.center[1])],
      zoom: pickNum(cameraParts[2], defaultCamera.zoom),
      bearing: pickNum(cameraParts[3], defaultCamera.bearing),
      pitch: pickNum(cameraParts[4], defaultCamera.pitch)
    },
    layers: layersOn,
    dynamicGeojsonToLoad,
    followId
  };
}

// Helper: load and add GeoJSON (or CSV as fallback) as a top layer or replace source of a layer
// geojsonFile: path or filename (typically name.geojson). If not found, we also try name.csv in the same folder.
// toLayer: optional { visibility } or { sourceHint }
async function loadAndAddOrReplaceGeoJSON(geojsonFile, toLayer) {
  // 1) Attempt to fetch and normalize into GeoJSON
  async function loadAsGeoJSONOrCSV(path) {
    const lower = path.toLowerCase();
    const isCSV = lower.endsWith('.csv');
    const isJSON = lower.endsWith('.geojson') || lower.endsWith('.json');
    const base = path.replace(/\.(geo)?json$/i, '').replace(/\.csv$/i, '');
    const nameOnly = base.split('/').pop();
    const sameDirGeo = `${base}.geojson`;
    const sameDirCsv = `${base}.csv`;
    const dataDirCsv = `${base.substring(0, base.lastIndexOf('/')) !== '' ? base.substring(0, base.lastIndexOf('/')) + '/' : ''}data/${nameOnly}.csv`;
    const upDataDirCsv = `../data/${nameOnly}.csv`;

    // Try explicit path first
    if (isJSON) {
      try {
        console.debug('[DATA] Trying GeoJSON:', path);
        const r = await fetch(path);
        if (!r.ok) throw new Error(`HTTP ${r.status}`);
        return await r.json();
      } catch (e) {
        // Fallback to CSV beside it
        const csvPath = sameDirCsv;
        try {
          console.debug('[DATA] GeoJSON not found. Trying CSV (same dir):', csvPath);
          const r2 = await fetch(csvPath);
          if (!r2.ok) throw new Error(`HTTP ${r2.status}`);
          const txt = await r2.text();
          return csvTextToGeoJSON(txt);
        } catch (e2) {
          // Try ./data/ and ../data/
          try {
            console.debug('[DATA] Trying CSV (data/):', dataDirCsv);
            const r3 = await fetch(dataDirCsv);
            if (!r3.ok) throw new Error(`HTTP ${r3.status}`);
            const txt3 = await r3.text();
            return csvTextToGeoJSON(txt3);
          } catch (e3) {
            try {
              console.debug('[DATA] Trying CSV (../data/):', upDataDirCsv);
              const r4 = await fetch(upDataDirCsv);
              if (!r4.ok) throw new Error(`HTTP ${r4.status}`);
              const txt4 = await r4.text();
              return csvTextToGeoJSON(txt4);
            } catch (e4) {
              throw new Error(`Failed to load as GeoJSON (${path}) or CSV (${csvPath} | ${dataDirCsv} | ${upDataDirCsv}).`);
            }
          }
        }
      }
    } else if (isCSV) {
      try {
        console.debug('[DATA] Trying CSV:', path);
        const r = await fetch(path);
        if (!r.ok) throw new Error(`HTTP ${r.status}`);
        const txt = await r.text();
        return csvTextToGeoJSON(txt);
      } catch (e) {
        // Fallback to GeoJSON beside it
        const gjPath = sameDirGeo;
        try {
          console.debug('[DATA] CSV not found. Trying GeoJSON (same dir):', gjPath);
          const r2 = await fetch(gjPath);
          if (!r2.ok) throw new Error(`HTTP ${r2.status}`);
          return await r2.json();
        } catch (e2) {
          throw new Error(`Failed to load as CSV (${path}) or GeoJSON (${gjPath}).`);
        }
      }
    } else {
      // No extension provided: try .geojson then .csv
      try {
        console.debug('[DATA] No extension. Trying GeoJSON (same dir):', sameDirGeo);
        const r = await fetch(sameDirGeo);
        if (!r.ok) throw new Error(`HTTP ${r.status}`);
        return await r.json();
      } catch (e) {
        try {
          console.debug('[DATA] Trying CSV (same dir):', sameDirCsv);
          const r2 = await fetch(sameDirCsv);
          if (!r2.ok) throw new Error(`HTTP ${r2.status}`);
          const txt = await r2.text();
          return csvTextToGeoJSON(txt);
        } catch (e2) {
          // Try ./data/ and ../data/
          try {
            console.debug('[DATA] Trying CSV (data/):', dataDirCsv);
            const r3 = await fetch(dataDirCsv);
            if (!r3.ok) throw new Error(`HTTP ${r3.status}`);
            const txt3 = await r3.text();
            return csvTextToGeoJSON(txt3);
          } catch (e3) {
            try {
              console.debug('[DATA] Trying CSV (../data/):', upDataDirCsv);
              const r4 = await fetch(upDataDirCsv);
              if (!r4.ok) throw new Error(`HTTP ${r4.status}`);
              const txt4 = await r4.text();
              return csvTextToGeoJSON(txt4);
            } catch (e4) {
              throw new Error(`Failed to load ${nameOnly} as .geojson or .csv (searched: ${sameDirGeo}, ${sameDirCsv}, ${dataDirCsv}, ${upDataDirCsv})`);
            }
          }
        }
      }
    }
  }

  // CSV -> GeoJSON (Point features) using Papa Parse for robust CSV parsing
  function csvTextToGeoJSON(csvText) {
    if (typeof Papa === 'undefined' || !Papa.parse) {
      throw new Error('CSV parsing library not loaded.');
    }
    const res = Papa.parse(csvText, { header: true, dynamicTyping: true, skipEmptyLines: true });
    if (res.errors && res.errors.length) {
      console.warn('CSV parse warnings:', res.errors);
    }
    const rows = res.data || [];
    if (!rows.length) return { type: 'FeatureCollection', features: [] };
    // Find lat/lon columns (case-insensitive)
    const keys = Object.keys(rows[0] || {});
    const lowerMap = Object.fromEntries(keys.map(k => [k.toLowerCase(), k]));
    const latCandidates = ['lat', 'latitude', 'y'];
    const lonCandidates = ['lon', 'lng', 'long', 'longitude', 'x'];
    const latKey = latCandidates.map(k => lowerMap[k]).find(Boolean);
    const lonKey = lonCandidates.map(k => lowerMap[k]).find(Boolean);
    if (!latKey || !lonKey) {
      throw new Error('CSV missing latitude/longitude columns');
    }
    const features = [];
    for (const row of rows) {
      const lat = parseFloat(row[latKey]);
      const lon = parseFloat(row[lonKey]);
      if (!isFinite(lat) || !isFinite(lon)) continue;
      const props = { ...row };
      features.push({
        type: 'Feature',
        geometry: { type: 'Point', coordinates: [lon, lat] },
        properties: props
      });
    }
    return { type: 'FeatureCollection', features };
  }

  try {
    const geojson = await loadAsGeoJSONOrCSV(geojsonFile);
    // 2) Determine ids and clean
    let fileId = geojsonFile.split('/').pop();
    let cleanId = fileId.replace(/(_geojson|\.geojson|\.json|\.csv)$/i, '');
    cleanId = cleanId.replace(/[^a-zA-Z0-9_-]/g, '_');
    const sourceId = cleanId;
    const layerId = cleanId;

    // 3) Replace existing and add source
    if (map.getLayer(layerId)) map.removeLayer(layerId);
    if (map.getSource(sourceId)) map.removeSource(sourceId);
    map.addSource(sourceId, { type: 'geojson', data: geojson });

    // 4) Extract sourceHint and determine layer type
    let sourceHint = null;
    if (typeof toLayer === 'object' && toLayer !== null && toLayer.sourceHint) sourceHint = toLayer.sourceHint;
    if (!sourceHint && typeof geojsonFile === 'object' && geojsonFile.sourceHint) sourceHint = geojsonFile.sourceHint;
    
    console.log('[LOAD] Layer:', layerId, 'with sourceHint:', sourceHint);
    
    let type = 'line';
    let sourceLayerFound = false;
    
    if (sourceHint) {
      const styleLayer = map.getStyle().layers.find(l => l.id === sourceHint);
      if (styleLayer && styleLayer.type) {
        type = styleLayer.type;
        sourceLayerFound = true;
        console.log('[LAYER TYPE] Using type', type, 'from source layer', sourceHint);
      } else {
        console.warn('[LAYER TYPE] Source layer', sourceHint, 'not found in style! Available layers:', map.getStyle().layers.map(l => l.id).join(', '));
      }
    }
    
    // Fallback: infer from geometry if no source layer found
    if (!sourceLayerFound) {
      if (geojson.features && geojson.features.length) {
        const geomType = geojson.features[0].geometry && geojson.features[0].geometry.type;
        if (geomType === 'Polygon' || geomType === 'MultiPolygon') type = 'fill';
        else if (geomType === 'Point' || geomType === 'MultiPoint') type = 'circle';
      }
    }

    // 5) Visibility
    let visibility = 'visible';
    if (typeof toLayer === 'object' && toLayer !== null && toLayer.visibility === 'none') {
      visibility = 'none';
    }

    // 6) Base paint defaults
    const basePaint = type === 'line' ? { 'line-color': '#fff', 'line-width': 3 } :
                      type === 'fill' ? { 'fill-color': '#f00', 'fill-opacity': 0.5 } :
                      { 'circle-radius': 6, 'circle-color': '#f00' };

    const layerDef = {
      id: layerId,
      type,
      source: sourceId,
      layout: { visibility },
      paint: basePaint
    };

    // 7) Copy styling from sourceHint if provided
    try {
      if (sourceHint) {
        const styleLayer = map.getStyle().layers.find(l => l.id === sourceHint);
        if (styleLayer) {
          if (styleLayer.paint) layerDef.paint = JSON.parse(JSON.stringify(styleLayer.paint));
          if (styleLayer.layout) {
            const copiedLayout = JSON.parse(JSON.stringify(styleLayer.layout));
            if (typeof copiedLayout.visibility !== 'undefined') delete copiedLayout.visibility;
            layerDef.layout = Object.assign({}, layerDef.layout, copiedLayout);
          }
          console.log('[STYLE COPY] Copied paint/layout from', sourceHint, 'to', layerId);
        } else {
          console.warn('[STYLE COPY] Source layer', sourceHint, 'not found, cannot copy styling');
        }
      }
    } catch (ex) {
      console.warn('[STYLE COPY] Failed to apply source hint style:', ex);
    }

    // 8) Add layer - with beforeId to place right after source layer if sourceHint is provided
    try {
      if (sourceHint) {
        // Find the layer that comes right after the source layer to insert before it
        const allLayers = map.getStyle().layers;
        const sourceIndex = allLayers.findIndex(l => l.id === sourceHint);
        if (sourceIndex >= 0) {
          if (sourceIndex < allLayers.length - 1) {
            const beforeId = allLayers[sourceIndex + 1].id;
            console.log('[LAYER ORDER] Placing', layerId, 'right after', sourceHint, '(before', beforeId + ')');
            map.addLayer(layerDef, beforeId);
          } else {
            // Source layer is last, add at top
            console.log('[LAYER ORDER] Source layer', sourceHint, 'is last, adding', layerId, 'at top');
            map.addLayer(layerDef);
          }
        } else {
          // Source layer not found
          console.warn('[LAYER ORDER] Source layer', sourceHint, 'not found in style, adding', layerId, 'at top');
          map.addLayer(layerDef);
        }
      } else {
        // No source hint, add at top
        map.addLayer(layerDef);
      }
    } catch (ex) {
      console.warn('[LAYER ORDER] Failed to add layer with positioning:', ex);
      // Fallback: add without beforeId
      try {
        map.addLayer(layerDef);
      } catch (ex2) {
        console.error('[LAYER ORDER] Failed to add layer at all:', ex2);
        throw ex2;
      }
    }
    console.log(`Layer loaded: ${layerId}`);
    
    // Mark as external layer
    externalLayers.add(layerId);

    // 9) Follow logic is handled centrally in the hashchange handler to ensure
    // camera and layer flags are applied first. No auto-follow here.

    // 10) Post-load bookkeeping/UI
    if (visibility === 'none') {
      map.setLayoutProperty(layerId, 'visibility', 'none');
    }
    if (!allStyleLayers.some(l => l.id === layerId)) {
      // Insert the layer in the correct position based on actual map layer order
      try {
        if (sourceHint) {
          // Find the source layer's position in allStyleLayers
          const sourceIdx = allStyleLayers.findIndex(l => l.id === sourceHint);
          if (sourceIdx >= 0) {
            // Insert right after the source layer
            allStyleLayers.splice(sourceIdx + 1, 0, { id: layerId, name: cleanId });
            console.log('[LAYER LIST] Inserted', layerId, 'after', sourceHint, 'in UI list');
          } else {
            // Source not in list, add at end
            allStyleLayers.push({ id: layerId, name: cleanId });
          }
        } else {
          // No source hint, add at end
          allStyleLayers.push({ id: layerId, name: cleanId });
        }
      } catch (ex) {
        console.warn('Failed to position layer in list:', ex);
        allStyleLayers.push({ id: layerId, name: cleanId });
      }
      styleDefaultVisibility[layerId] = 'visible';
    }
    createLayerControls(map, allStyleLayers.filter(l => map.getLayer(l.id) && map.getLayoutProperty(l.id, 'visibility') === 'visible').map(l => l.id));
  } catch (err) {
    console.error('Error loading data:', err);
  }
}

// Helper: Load Sentinel-2 imagery layer by date
// dateStr: YYYYMMDD format (e.g., "20240215")
// toLayer: optional { visibility, sourceHint }
async function loadS2Layer(dateStr, toLayer) {
  try {
    console.log('[S2] Loading Sentinel-2 layer for date:', dateStr);
    
    const layerId = `s2:${dateStr}`;
    const sourceId = layerId;
    
    // Validate date format
    if (!/^\d{8}$/.test(dateStr)) {
      throw new Error('Invalid date format. Expected YYYYMMDD, got: ' + dateStr);
    }
    
    // Parse date string to YYYY-MM-DD format
    const year = dateStr.substring(0, 4);
    const month = dateStr.substring(4, 6);
    const day = dateStr.substring(6, 8);
    const s2Date = `${year}-${month}-${day}`;
    
    // Validate date range (Sentinel-2 started June 2015)
    const minDate = new Date('2015-06-23');
    const requestDate = new Date(s2Date);
    const today = new Date();
    
    if (requestDate < minDate) {
      console.warn('[S2] Date', s2Date, 'is before Sentinel-2 launch (June 23, 2015). No imagery available.');
    }
    if (requestDate > today) {
      console.warn('[S2] Date', s2Date, 'is in the future. No imagery available.');
    }
    
    // Extract sourceHint - default to 'overlay' layer for positioning
    let sourceHint = 'overlay';
    if (typeof toLayer === 'object' && toLayer !== null && toLayer.sourceHint) {
      sourceHint = toLayer.sourceHint;
    }
    
    // Sentinel-2 tile URL via EOX
    // Using Sentinel-2 L2A True Color - 10m resolution
    // Available from June 2015 to present, updated twice yearly (summer/winter)
    // No authentication required for public preview layer, completely free and open
    // 
    // Note: Sentinel Hub offers multiple services:
    // 1. Public WMS service (what we're using) - free, no auth, but watermarked at high zoom
    // 2. Free tier with API key - 5000 requests/month, no watermark
    // 3. Paid tier for commercial use
    //
    // For this implementation, we use the public Sentinel-2 cloudless mosaic by EOX
    // which provides best-quality cloud-free imagery compiled from multiple acquisitions
    const baseYear = parseInt(year);
    const season = parseInt(month) <= 6 ? 'winter' : 'summer';
    
    // EOX Sentinel-2 cloudless - updated yearly
    // This is a global cloudless mosaic at 10m resolution
    // Mosaics are typically available with a 1-2 year delay
    // As of November 2025, the 2024 mosaic is available
    
    // Use the requested year, but cap at 2024 (latest available mosaic)
    const maxAvailableYear = 2024;
    const mosaicYear = Math.min(baseYear, maxAvailableYear);
    
    if (baseYear > maxAvailableYear) {
      console.warn('[S2] Year', baseYear, 'mosaic not yet available. Using', maxAvailableYear, 'instead.');
    }
    
    const tileUrl = `https://tiles.maps.eox.at/wmts/1.0.0/s2cloudless-${mosaicYear}_3857/default/g/{z}/{y}/{x}.jpg`;
    
    console.log('[S2] Using Sentinel-2 cloudless mosaic for', mosaicYear, '(10m resolution)');
    console.log('[S2] Tile URL pattern:', tileUrl.replace('{z}/{y}/{x}', 'Z/Y/X'));
    console.log('[S2] ✓ This is a free, open service with no authentication required');
    console.log('[S2] ℹ️  Note: Cloudless mosaics are compiled from multiple acquisitions for best quality');
    
    // Remove existing layer/source if present
    if (map.getLayer(layerId)) map.removeLayer(layerId);
    if (map.getSource(sourceId)) map.removeSource(sourceId);
    
    // Add raster source
    map.addSource(sourceId, {
      type: 'raster',
      tiles: [tileUrl],
      tileSize: 256,
      minzoom: 0,
      maxzoom: 13,  // Sentinel-2 cloudless available up to level 13 (10m resolution)
      attribution: 'Sentinel-2 cloudless by EOX - Contains modified Copernicus Sentinel data'
    });
    
    console.log('[S2] Added raster source:', sourceId);
    
    // Visibility
    let visibility = 'visible';
    if (typeof toLayer === 'object' && toLayer !== null && toLayer.visibility === 'none') {
      visibility = 'none';
    }
    
    // Create layer definition
    const layerDef = {
      id: layerId,
      type: 'raster',
      source: sourceId,
      layout: { visibility },
      paint: {
        'raster-opacity': 1
      }
    };
    
    // Copy paint properties from source hint if available
    try {
      if (sourceHint) {
        const styleLayer = map.getStyle().layers.find(l => l.id === sourceHint);
        if (styleLayer && styleLayer.paint && styleLayer.paint['raster-opacity'] !== undefined) {
          layerDef.paint['raster-opacity'] = styleLayer.paint['raster-opacity'];
          console.log('[S2] Copied raster-opacity from', sourceHint);
        }
      }
    } catch (ex) {
      console.warn('[S2] Failed to copy paint from source hint:', ex);
    }
    
    // Add layer positioned right after the source hint layer
    try {
      if (sourceHint) {
        const allLayers = map.getStyle().layers;
        const sourceIndex = allLayers.findIndex(l => l.id === sourceHint);
        if (sourceIndex >= 0 && sourceIndex < allLayers.length - 1) {
          const beforeId = allLayers[sourceIndex + 1].id;
          console.log('[S2] Placing', layerId, 'right after', sourceHint, '(before', beforeId + ')');
          map.addLayer(layerDef, beforeId);
        } else {
          console.log('[S2] Source layer', sourceHint, 'is last or not found, adding at top');
          map.addLayer(layerDef);
        }
      } else {
        map.addLayer(layerDef);
      }
    } catch (ex) {
      console.warn('[S2] Failed to add layer with positioning:', ex);
      map.addLayer(layerDef);
    }
    
    console.log('[S2] Layer loaded:', layerId);
    
    // Mark as external layer
    externalLayers.add(layerId);
    
    // Post-load bookkeeping
    if (visibility === 'none') {
      map.setLayoutProperty(layerId, 'visibility', 'none');
    }
    
    // Add to allStyleLayers if not present
    if (!allStyleLayers.some(l => l.id === layerId)) {
      try {
        if (sourceHint) {
          const sourceIdx = allStyleLayers.findIndex(l => l.id === sourceHint);
          if (sourceIdx >= 0) {
            allStyleLayers.splice(sourceIdx + 1, 0, { id: layerId, name: `Sentinel-2 ${s2Date}` });
            console.log('[S2] Inserted', layerId, 'after', sourceHint, 'in UI list');
          } else {
            allStyleLayers.push({ id: layerId, name: `Sentinel-2 ${s2Date}` });
          }
        } else {
          allStyleLayers.push({ id: layerId, name: `Sentinel-2 ${s2Date}` });
        }
      } catch (ex) {
        console.warn('[S2] Failed to position layer in list:', ex);
        allStyleLayers.push({ id: layerId, name: `Sentinel-2 ${s2Date}` });
      }
      styleDefaultVisibility[layerId] = 'visible';
    }
    
    // Update layer controls
    createLayerControls(map, allStyleLayers.filter(l => map.getLayer(l.id) && map.getLayoutProperty(l.id, 'visibility') === 'visible').map(l => l.id));
    
  } catch (err) {
    console.error('[S2] ❌ Error loading Sentinel-2 layer:', err);
    console.error('[S2] This may indicate:');
    console.error('[S2]   - Invalid date format or date out of range');
    console.error('[S2]   - Network connectivity issues');
    console.error('[S2]   - EOX Sentinel-2 service temporary unavailability');
    console.error('[S2] Valid date range: June 23, 2015 to present');
  }
}

// Helper: Load ESRI Wayback imagery layer by date
// dateStr: YYYYMMDD format (e.g., "20240215")
// toLayer: optional { visibility, sourceHint }
async function loadWaybackLayer(dateStr, toLayer) {
  try {
    console.log('[WAYBACK] Loading ESRI Wayback layer for date:', dateStr);
    
    const layerId = `wayback:${dateStr}`;
    const sourceId = layerId;
    
    // Validate date format
    if (!/^\d{8}$/.test(dateStr)) {
      throw new Error('Invalid date format. Expected YYYYMMDD, got: ' + dateStr);
    }
    
    // Parse date
    const year = dateStr.substring(0, 4);
    const month = dateStr.substring(4, 6);
    const day = dateStr.substring(6, 8);
    const requestDate = `${year}-${month}-${day}`;
    
    // Fetch Wayback configuration
    console.log('[WAYBACK] Fetching Wayback release catalog...');
    const configResponse = await fetch('https://s3-us-west-2.amazonaws.com/config.maptiles.arcgis.com/waybackconfig.json');
    if (!configResponse.ok) {
      throw new Error('Failed to fetch Wayback configuration');
    }
    
    const config = await configResponse.json();
    
    // Parse releases and find closest one to requested date
    const releases = Object.entries(config).map(([releaseId, info]) => {
      // Extract date from title like "World Imagery (Wayback 2024-11-18)"
      const match = info.itemTitle.match(/(\d{4}-\d{2}-\d{2})/);
      if (match) {
        return {
          releaseId,
          date: match[1],
          dateObj: new Date(match[1]),
          title: info.itemTitle
        };
      }
      return null;
    }).filter(r => r !== null);
    
    // Sort by date
    releases.sort((a, b) => a.dateObj - b.dateObj);
    
    // Find closest release to requested date
    const targetDate = new Date(requestDate);
    let closestRelease = releases[0];
    let minDiff = Math.abs(targetDate - releases[0].dateObj);
    
    for (const release of releases) {
      const diff = Math.abs(targetDate - release.dateObj);
      if (diff < minDiff) {
        minDiff = diff;
        closestRelease = release;
      }
      // If we've passed the target date, stop
      if (release.dateObj > targetDate) {
        break;
      }
    }
    
    console.log(`[WAYBACK] Requested: ${requestDate}, Using release: ${closestRelease.date} (ID: ${closestRelease.releaseId})`);
    
    // ESRI Wayback tile URL
    // High resolution Maxar satellite imagery + aerial imagery
    // Updated every few weeks since February 2014
    const tileUrl = `https://wayback.maptiles.arcgis.com/arcgis/rest/services/world_imagery/wmts/1.0.0/default028mm/mapserver/tile/${closestRelease.releaseId}/{z}/{y}/{x}`;
    
    console.log('[WAYBACK] Using ESRI World Imagery Wayback (Maxar satellite imagery)');
    console.log('[WAYBACK] Tile URL pattern:', tileUrl.replace('{z}/{y}/{x}', 'Z/Y/X'));
    console.log('[WAYBACK] ✓ High resolution imagery (up to 30cm in urban areas)');
    console.log('[WAYBACK] ℹ️  Release:', closestRelease.title);
    
    // Extract sourceHint - default to 'overlay' layer for positioning
    let sourceHint = 'overlay';
    if (typeof toLayer === 'object' && toLayer !== null && toLayer.sourceHint) {
      sourceHint = toLayer.sourceHint;
    }
    
    // Remove existing layer/source if present
    if (map.getLayer(layerId)) map.removeLayer(layerId);
    if (map.getSource(sourceId)) map.removeSource(sourceId);
    
    // Add raster source
    map.addSource(sourceId, {
      type: 'raster',
      tiles: [tileUrl],
      tileSize: 256,
      minzoom: 0,
      maxzoom: 22,  // Wayback supports very high zoom levels
      attribution: '© Esri, Maxar, GeoEye, Earthstar Geographics, CNES/Airbus DS, USDA, USGS, AeroGRID, IGN, and the GIS User Community'
    });
    console.log('[WAYBACK] Added raster source:', sourceId);
    
    // Visibility
    let visibility = 'visible';
    if (typeof toLayer === 'object' && toLayer !== null && toLayer.visibility === 'none') {
      visibility = 'none';
    }
    
    // Create layer definition
    const layerDef = {
      id: layerId,
      type: 'raster',
      source: sourceId,
      layout: { visibility },
      paint: {
        'raster-opacity': 1
      }
    };
    
    // Copy paint properties from source hint if available
    try {
      if (sourceHint) {
        const styleLayer = map.getStyle().layers.find(l => l.id === sourceHint);
        if (styleLayer && styleLayer.paint && styleLayer.paint['raster-opacity'] !== undefined) {
          layerDef.paint['raster-opacity'] = styleLayer.paint['raster-opacity'];
          console.log('[WAYBACK] Copied raster-opacity from', sourceHint);
        }
      }
    } catch (ex) {
      console.warn('[WAYBACK] Failed to copy paint from source hint:', ex);
    }
    
    // Add layer positioned right after the source hint layer
    try {
      if (sourceHint) {
        const allLayers = map.getStyle().layers;
        const sourceIndex = allLayers.findIndex(l => l.id === sourceHint);
        if (sourceIndex >= 0 && sourceIndex < allLayers.length - 1) {
          const beforeId = allLayers[sourceIndex + 1].id;
          console.log('[WAYBACK] Placing', layerId, 'right after', sourceHint, '(before', beforeId + ')');
          map.addLayer(layerDef, beforeId);
        } else {
          console.log('[WAYBACK] Source layer', sourceHint, 'is last or not found, adding at top');
          map.addLayer(layerDef);
        }
      } else {
        map.addLayer(layerDef);
      }
    } catch (ex) {
      console.warn('[WAYBACK] Failed to add layer with positioning:', ex);
      map.addLayer(layerDef);
    }
    
    console.log('[WAYBACK] Layer loaded:', layerId);
    
    // Mark as external layer
    externalLayers.add(layerId);
    
    // Post-load bookkeeping
    if (visibility === 'none') {
      map.setLayoutProperty(layerId, 'visibility', 'none');
    }
    
    // Add to allStyleLayers if not present
    if (!allStyleLayers.some(l => l.id === layerId)) {
      try {
        if (sourceHint) {
          const sourceIdx = allStyleLayers.findIndex(l => l.id === sourceHint);
          if (sourceIdx >= 0) {
            allStyleLayers.splice(sourceIdx + 1, 0, { id: layerId, name: `Wayback ${requestDate}` });
            console.log('[WAYBACK] Inserted', layerId, 'after', sourceHint, 'in UI list');
          } else {
            allStyleLayers.push({ id: layerId, name: `Wayback ${requestDate}` });
          }
        } else {
          allStyleLayers.push({ id: layerId, name: `Wayback ${requestDate}` });
        }
      } catch (ex) {
        console.warn('[WAYBACK] Failed to position layer in list:', ex);
        allStyleLayers.push({ id: layerId, name: `Wayback ${requestDate}` });
      }
      styleDefaultVisibility[layerId] = 'visible';
    }
    
    // Update layer controls
    createLayerControls(map, allStyleLayers.filter(l => map.getLayer(l.id) && map.getLayoutProperty(l.id, 'visibility') === 'visible').map(l => l.id));
    
  } catch (err) {
    console.error('[WAYBACK] ❌ Error loading Wayback layer:', err);
    console.error('[WAYBACK] This may indicate:');
    console.error('[WAYBACK]   - Invalid date format or date out of range');
    console.error('[WAYBACK]   - Network connectivity issues');
    console.error('[WAYBACK]   - ESRI Wayback service temporary unavailability');
    console.error('[WAYBACK] Valid date range: February 2014 to present');
  }
}

// Update hash from map state
function updateHash(map, visibleLayers) {
  const c = map.getCenter();
  const z = map.getZoom().toFixed(2);
  const b = map.getBearing().toFixed(1);
  const p = map.getPitch().toFixed(1);
  // Preserve existing layer part of hash if present
  const hash = window.location.hash.replace('#', '');
  const [, layersStr] = hash.split('/');
  const cameraStr = `${c.lat.toFixed(5)},${c.lng.toFixed(5)},${z},${b},${p}`;
  if (layersStr !== undefined) {
    window.location.replace(`#${cameraStr}/${layersStr}`);
  } else {
    window.location.replace(`#${cameraStr}`);
  }
}

// Create layer controls
function createLayerControls(map, visibleLayers) {
  const container = document.getElementById('layer-controls');
  container.innerHTML = '<strong>Layers</strong><br>';
  let foundLayer = false;
  // Always reflect the current style visibility for checkboxes
  // Parse current hash for explicit toggles
  const hash = window.location.hash.replace('#', '');
  const [, layersStr] = hash.split('/');
  const explicitState = {};
  if (layersStr) {
    layersStr.split(',').forEach(token => {
      const match = token.match(/^([+~])(.+)$/);
      if (!match) return;
      const [, sign, lname] = match;
      explicitState[lname] = sign;
    });
  }
  // Include all style layers and any geojson-above-* layers
  const allLayers = [
    ...allStyleLayers,
    ...map.getStyle().layers
      .filter(l => l.id.startsWith('geojson-above-') && !allStyleLayers.some(s => s.id === l.id))
      .map(l => ({ id: l.id }))
  ];
  // Order from highest (topmost) to lowest (bottommost)
  allLayers.reverse();
  allLayers.forEach(layer => {
    if (map.getLayer(layer.id)) {
      foundLayer = true;
      const vis = map.getLayoutProperty(layer.id, 'visibility');
      const defaultVis = styleDefaultVisibility[layer.id] || 'visible';
      let checked, bold, state, showReset = false;
      if (explicitState[layer.id] === '+') {
        checked = 'checked';
        bold = true;
        state = 'visible';
        showReset = (defaultVis !== 'visible');
      } else if (explicitState[layer.id] === '~') {
        checked = '';
        bold = true;
        state = 'hidden';
        showReset = (defaultVis !== 'none');
      } else {
        checked = (defaultVis === 'visible') ? 'checked' : '';
        bold = false;
        state = 'default';
        showReset = false;
      }
      let label = layer.name || layer.id;
      // Check if this is an externally loaded layer
      const isExternalLayer = externalLayers.has(layer.id);
      // Apply bold blue styling for external layers
      const labelStyle = isExternalLayer ? 'font-weight:bold;color:#0028ff;' : (bold ? 'font-weight:bold;' : '');
      // Wrap the checkbox, label, and button in a span for easy removal
      container.innerHTML += `<span class="layer-list-item" data-layer-item="${layer.id}"><label style="${labelStyle}"><input type="checkbox" data-layer="${layer.id}" ${checked}> ${label}</label>`;
      // For dynamic layers (not part of the style), always show delete 'X' button
      if (isExternalLayer) {
        container.innerHTML += ` <button data-delete="${layer.id}" title="Delete layer" style="font-size:1.1em;line-height:1;color:#c00;font-weight:bold;vertical-align:middle;padding:0 0.2em;">x</button>`;
      } else if (explicitState[layer.id]) {
        container.innerHTML += ` <button data-reset="${layer.id}" title="Reset to style default" style="font-size:1.1em;line-height:1;vertical-align:middle;padding:0 0.2em;">↻</button>`;
      }
      container.innerHTML += '</span><br>';
    }
  });
  if (!foundLayer) {
    container.innerHTML += '<em>No toggleable layers found in the current style.</em>';
  }
  container.querySelectorAll('input[type=checkbox]').forEach(cb => {
    cb.addEventListener('change', function() {
      const layerId = this.getAttribute('data-layer');
      if (!map.getLayer(layerId)) {
        console.warn(`Layer '${layerId}' not found in style.`);
        return;
      }
      // Parse current hash for explicit toggles
      const hash = window.location.hash.replace('#', '');
      const [cameraStr, layersStr] = hash.split('/');
      const explicitState = {};
      if (layersStr) {
        layersStr.split(',').forEach(token => {
          const match = token.match(/^([+~])(.+)$/);
          if (!match) return;
          const [, sign, lname] = match;
          explicitState[lname] = sign;
        });
      }
      // Toggle + or ~ in hash and set visibility
      if (this.checked) {
        explicitState[layerId] = '+';
        map.setLayoutProperty(layerId, 'visibility', 'visible');
      } else {
        explicitState[layerId] = '~';
        map.setLayoutProperty(layerId, 'visibility', 'none');
      }
      // Build new hash
      const tokens = Object.entries(explicitState).map(([lname, sign]) => `${sign}${lname}`);
      if (tokens.length > 0) {
        window.location.replace(`#${cameraStr}/${tokens.join(',')}`);
      } else {
        window.location.replace(`#${cameraStr}`);
      }
    });
  });

  // Add reset button listeners for style layers
  container.querySelectorAll('button[data-reset]').forEach(btn => {
    btn.addEventListener('click', function(e) {
      e.preventDefault();
      const layerId = this.getAttribute('data-reset');
      // Parse current hash for explicit toggles
      const hash = window.location.hash.replace('#', '');
      const [cameraStr, layersStr] = hash.split('/');
      const explicitState = {};
      if (layersStr) {
        layersStr.split(',').forEach(token => {
          const match = token.match(/^([+~])(.+)$/);
          if (!match) return;
          const [, sign, lname] = match;
          explicitState[lname] = sign;
        });
      }
      // Remove explicit toggle for this layer
      delete explicitState[layerId];
      // Style layer: restore style default
      const defaultVis = styleDefaultVisibility[layerId] || 'visible';
      map.setLayoutProperty(layerId, 'visibility', defaultVis);
      // Build new hash
      const tokens = Object.entries(explicitState).map(([lname, sign]) => `${sign}${lname}`);
      if (tokens.length > 0) {
        window.location.replace(`#${cameraStr}/${tokens.join(',')}`);
      } else {
        window.location.replace(`#${cameraStr}`);
      }
    });
  });

  // Add delete button listeners for dynamic layers
  container.querySelectorAll('button[data-delete]').forEach(btn => {
    btn.addEventListener('click', function(e) {
      e.preventDefault();
      const layerId = this.getAttribute('data-delete');
      // Parse current hash for explicit toggles
      const hash = window.location.hash.replace('#', '');
      const [cameraStr, layersStr] = hash.split('/');
      const explicitState = {};
      if (layersStr) {
        layersStr.split(',').forEach(token => {
          const match = token.match(/^([+~])(.+)$/);
          if (!match) return;
          const [, sign, lname] = match;
          explicitState[lname] = sign;
        });
      }
      // Remove explicit toggle for this layer
      delete explicitState[layerId];
      // Remove from map and state
      if (map.getLayer(layerId)) map.removeLayer(layerId);
      if (map.getSource(layerId)) map.removeSource(layerId);
      const idx = allStyleLayers.findIndex(l => l.id === layerId);
      if (idx !== -1) allStyleLayers.splice(idx, 1);
      delete styleDefaultVisibility[layerId];
      externalLayers.delete(layerId);
      // Refresh the UI after deletion to ensure the list is in sync
      createLayerControls(map, allStyleLayers.filter(l => map.getLayer(l.id) && map.getLayoutProperty(l.id, 'visibility') === 'visible').map(l => l.id));
      // Remove from hash and update URL
      const tokens = Object.entries(explicitState).map(([lname, sign]) => `${sign}${lname}`);
      if (tokens.length > 0) {
        window.location.replace(`#${cameraStr}/${tokens.join(',')}`);
      } else {
        window.location.replace(`#${cameraStr}`);
      }
    });
  });
}

const { camera, layers } = parseHash();

const map = new mapboxgl.Map({
  container: 'map',
  style,
  center: camera.center,
  zoom: camera.zoom,
  bearing: camera.bearing,
  pitch: camera.pitch
});

map.on('load', () => {
  // After all layers are loaded, if :follow is present in the hash, trigger follow logic directly (no hashchange event)
  const { camera: camInit, layers: layersInit, dynamicGeojsonToLoad: dynInit, followId: followInit } = parseHash();
  if (followInit) {
    // Only start follow if not already running (avoid double-trigger)
    if (!window._isFollowStarted) {
      window._isFollowStarted = true;
      const tryStartFollow = () => {
        const src = map.getSource(followInit);
        if (!(src && src._data && src._data.features)) {
          setTimeout(tryStartFollow, 100);
          return;
        }
        // Extract coords
        let coords = [];
        src._data.features.forEach(f => {
          if (!f.geometry) return;
          if (f.geometry.type === 'LineString') coords = coords.concat(f.geometry.coordinates);
          if (f.geometry.type === 'Polygon') coords = coords.concat(f.geometry.coordinates[0]);
          if (f.geometry.type === 'MultiLineString') coords = coords.concat(...f.geometry.coordinates);
          if (f.geometry.type === 'MultiPolygon') coords = coords.concat(...f.geometry.coordinates.map(ring => ring[0]));
        });
        if (coords.length > 1) {
          followPathWithFreeCamera(map, coords, () => {
            // On completion: freeze current camera into the hash and remove :follow to avoid jumping back
            const c = map.getCenter();
            const z = map.getZoom().toFixed(2);
            const b = map.getBearing().toFixed(1);
            const p = map.getPitch().toFixed(1);
            const cameraStr = `${c.lat.toFixed(5)},${c.lng.toFixed(5)},${z},${b},${p}`;
            let hash = window.location.hash.replace('#', '');
            const parts = hash.split('/');
            let layersStr = parts[1] || '';
            if (layersStr) {
              layersStr = layersStr.replace(new RegExp(`([+~]${followInit}):follow`), '$1');
            }
            const newHash = `#${cameraStr}` + (layersStr ? `/${layersStr}` : '');
            window._suppressNextFollowCancel = true;
            window.location.replace(newHash);
            window._isFollowStarted = false;
          }, followInit);
        }
      };
      setTimeout(tryStartFollow, 0);
    }
  }
  // Get all layers from the style
  allStyleLayers = map.getStyle().layers.map(l => ({ id: l.id }));
  // Store the style default visibility for each layer
  allStyleLayers.forEach(layer => {
    if (map.getLayer(layer.id)) {
      const styleLayer = map.getStyle().layers.find(l => l.id === layer.id);
      let vis = 'visible';
      if (styleLayer && styleLayer.layout && typeof styleLayer.layout.visibility !== 'undefined') {
        vis = styleLayer.layout.visibility;
      }
      styleDefaultVisibility[layer.id] = vis;
    }
  });
  // Apply layer visibility from hash on initial load
  const { layers: hashLayers } = parseHash();
  const hashStr = window.location.hash.replace('#', '');
  const [, layersStr] = hashStr.split('/');
  if (layersStr) {
    const explicitState = {};
    layersStr.split(',').forEach(token => {
      const match = token.match(/^([+~])([^:(]+)(?:\(([^)]+)\))?(?::follow)?$/);
      if (!match) return;
      const [, sign, lname] = match;
      explicitState[lname] = sign;
    });
    
    // Apply visibility to all layers based on hash
    allStyleLayers.forEach(layer => {
      const id = layer.id;
      const explicit = explicitState[id];
      if (explicit === '+') {
        // Explicitly shown in hash
        if (map.getLayer(id) && map.getLayoutProperty(id, 'visibility') !== 'visible') {
          map.setLayoutProperty(id, 'visibility', 'visible');
        }
      } else if (explicit === '~') {
        // Explicitly hidden in hash
        if (map.getLayer(id) && map.getLayoutProperty(id, 'visibility') !== 'none') {
          map.setLayoutProperty(id, 'visibility', 'none');
        }
      }
      // If not mentioned in hash, leave as-is (default from style)
    });
  }
  
  // Update the toggle list to reflect current visibility
  createLayerControls(map, allStyleLayers.filter(l => map.getLayer(l.id) && map.getLayoutProperty(l.id, 'visibility') === 'visible').map(l => l.id));
  
  // Re-apply camera from hash after style load to ensure bearing/pitch/zoom are honored
  try {
    const { camera: parsedCamera } = parseHash();
    if (parsedCamera) {
      map.jumpTo({
        center: parsedCamera.center,
        zoom: parsedCamera.zoom,
        bearing: parsedCamera.bearing,
        pitch: parsedCamera.pitch,
        animate: false
      });
      console.log('[INIT] Applied camera from hash on load:', parsedCamera);
    }
  } catch (e) {
    console.warn('[INIT] Failed to apply parsed camera on load', e);
  }
  // Load any dynamic layers requested in the hash
  const { dynamicGeojsonToLoad, layers: layersOn } = parseHash();
  if (dynamicGeojsonToLoad && dynamicGeojsonToLoad.length) {
    dynamicGeojsonToLoad.forEach(entry => {
      let name = null, sourceHint = null, isS2 = false, s2Date = null, isWayback = false, waybackDate = null;
      if (typeof entry === 'string') {
        name = entry;
      } else if (entry && typeof entry === 'object') {
        name = entry.name;
        sourceHint = entry.sourceHint;
        isS2 = entry.isS2 || false;
        s2Date = entry.s2Date || null;
        isWayback = entry.isWayback || false;
        waybackDate = entry.waybackDate || null;
      }
      if (name) {
        const visibility = (layersOn && layersOn.includes(name)) ? 'visible' : 'none';
        if (isS2 && s2Date) {
          // Load Sentinel-2 layer
          loadS2Layer(s2Date, { visibility, sourceHint });
        } else if (isWayback && waybackDate) {
          // Load ESRI Wayback layer
          loadWaybackLayer(waybackDate, { visibility, sourceHint });
        } else {
          // Load GeoJSON/CSV layer
          loadAndAddOrReplaceGeoJSON(name + '.geojson', { visibility, sourceHint });
        }
      }
    });
  }

  // Do NOT trigger hashchange handler here; let user navigation or manual hash changes do it.
});

// Update hash on camera move
map.on('moveend', () => {
  // During free-camera follow animation, don't write to the hash —
  // it can re-introduce :follow and cause unintended restarts.
  if (isFreeCameraAnimating) return;
  // Also avoid writing while :follow is present in the hash for any layer.
  try {
    const rawHash = window.location.hash.replace('#','');
    const parts = rawHash.split('/');
    const layersStr = parts[1] || '';
    if (layersStr.split(',').some(t => /:follow$/.test(t))) return;
  } catch(e){}
  // Only update camera part of hash, preserve layer toggles
  updateHash(map, []);
});

// Listen for hash changes (external navigation)
let isFreeCameraAnimating = false;
let pendingHashUpdate = null;
function followPathWithFreeCamera(map, coords, onComplete, layerId) {
  // Periodic check for :follow in the hash
  // Escape layerId for regex
  const safeLayerId = layerId.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  console.log('[FOLLOW START]', layerId, 'coords:', coords.length);
  let followCheckInterval = setInterval(() => {
    const rawHash = window.location.hash;
    const hash = rawHash.replace('#', '');
    const [, layersStr] = hash.split('/');
    let stillFollowing = false;
    if (layersStr) {
      const tokens = layersStr.split(',');
      // Pattern must account for optional (sourceHint) after layer name: +layerId(source):follow
      stillFollowing = tokens.some(token => token.match(new RegExp(`^[+~]${safeLayerId}(?:\\([^)]+\\))?:follow$`)));
    }
    console.log(`[FOLLOW CHECK] hash: ${rawHash} | :follow present for ${layerId}?`, stillFollowing);
    if (!stillFollowing) {
      console.log(`[FOLLOW CHECK] :follow removed for ${layerId}, stopping animation and applying hash params.`);
      if (window._follow && typeof window._follow.cancel === 'function') {
        window._follow.cancel();
        console.log('[FOLLOW] Cancelled by hashchange or flag removal');
      } else {
        // Fallback cleanup
        isFreeCameraAnimating = false;
        clearInterval(followCheckInterval);
        try {
          if (layerId && originalData) {
            const src = map.getSource(layerId);
            if (src && src.setData) src.setData(originalData);
          }
        } catch(e) {}
        console.log('[FOLLOW] Fallback cancel cleanup');
      }
    }
  }, 1000);
  isFreeCameraAnimating = true;
  console.log('[FOLLOW] Animation state set: isFreeCameraAnimating = true');
  
  // Make the layer visible at the start of the follow animation
  if (layerId && map.getLayer(layerId)) {
    map.setLayoutProperty(layerId, 'visibility', 'visible');
    console.log('[FOLLOW] Made layer visible:', layerId);
  }
  
  // Expose a global cancel to allow immediate stop on hash changes
  if (!window._follow) window._follow = {};
  window._follow.layerId = layerId;
  window._follow.checkIntervalId = followCheckInterval;
  window._follow.cancel = function() {
    try { if (window._follow.checkIntervalId) clearInterval(window._follow.checkIntervalId); } catch(e){}
    isFreeCameraAnimating = false;
    try {
      if (layerId && originalData) {
        const src = map.getSource(layerId);
        if (src && src.setData) src.setData(originalData);
      }
    } catch(e) {}
    // Hide distance ticker
    const ticker = document.getElementById('distance-ticker');
    if (ticker) ticker.classList.remove('active');
    // Do not modify hash or call onComplete here; caller controls next steps
    // Cleanup handle
    window._follow = null;
  };
  // Calculate total distance for constant speed
  function getDistance(a, b) {
    const R = 6371000;
    const toRad = Math.PI / 180;
    const dLat = (b[1] - a[1]) * toRad;
    const dLng = (b[0] - a[0]) * toRad;
    const lat1 = a[1] * toRad;
    const lat2 = b[1] * toRad;
    const aVal = Math.sin(dLat/2) * Math.sin(dLat/2) + Math.cos(lat1) * Math.cos(lat2) * Math.sin(dLng/2) * Math.sin(dLng/2);
    const c = 2 * Math.atan2(Math.sqrt(aVal), Math.sqrt(1-aVal));
    return R * c;
  }
  let totalDist = 0;
  for (let j = 1; j < coords.length; j++) totalDist += getDistance(coords[j-1], coords[j]);
  const duration = Math.max(2000, totalDist * 2); // ms, 2ms per meter, min 2s
  let startTime = null;
  let originalData = null;
  if (layerId) {
    const src = map.getSource(layerId);
    if (src && src._data) originalData = JSON.parse(JSON.stringify(src._data));
  }
  // Store original data reference for external cancel
  if (window._follow) window._follow.originalData = originalData;
  
  // Show distance ticker if we have a valid GeoJSON source
  const ticker = document.getElementById('distance-ticker');
  const totalDistKm = totalDist / 1000;
  if (ticker && totalDistKm > 0) {
    ticker.classList.add('active');
    ticker.textContent = '0 km';
  }
  function getBearing(from, to) {
    // Calculate bearing in radians from point 'from' to point 'to'
    const rad = Math.PI / 180;
    const lat1 = from[1] * rad;
    const lat2 = to[1] * rad;
    const dLon = (to[0] - from[0]) * rad;
    const y = Math.sin(dLon) * Math.cos(lat2);
    const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);
    let brng = Math.atan2(y, x);
    return brng;
  }

  function interpolateLine(coords, t) {
    // t in [0,1], returns the point at t along the line
    let dist = 0, segStart = coords[0], segEnd = coords[1], segIdx = 1;
    let total = 0;
    for (let j = 1; j < coords.length; j++) total += getDistance(coords[j-1], coords[j]);
    let target = t * total;
    for (let j = 1; j < coords.length; j++) {
      let segLen = getDistance(coords[j-1], coords[j]);
      if (dist + segLen >= target) {
        segStart = coords[j-1];
        segEnd = coords[j];
        segIdx = j;
        break;
      }
      dist += segLen;
    }
    let segT = (target - dist) / getDistance(segStart, segEnd);
    return [
      segStart[0] + (segEnd[0] - segStart[0]) * segT,
      segStart[1] + (segEnd[1] - segStart[1]) * segT
    ];
  }

  // Easing function (easeInOutQuad)
  function easeInOutQuad(x) {
    return x < 0.5 ? 2 * x * x : 1 - Math.pow(-2 * x + 2, 2) / 2;
  }

  // Before animation: capture the current camera state at the moment follow starts
  const camBearing = map.getBearing();
  const camPitch = map.getPitch();
  const camZoom = map.getZoom();
  // Get current map center and path start in screen (pixel) coordinates
  const mapCenter = map.getCenter();
  const mapCenterPx = map.project(mapCenter);
  const pathStartPx = map.project({lng: coords[0][0], lat: coords[0][1]});
  // Offset vector in pixels from map center to path start
  const offsetPx = { x: pathStartPx.x - mapCenterPx.x, y: pathStartPx.y - mapCenterPx.y };
  // Camera state for smooth following
  let currentCameraCenter = mapCenter;
  let useOffset = Math.abs(offsetPx.x) > 1e-2 || Math.abs(offsetPx.y) > 1e-2;

  function animate(ts) {
    if (!isFreeCameraAnimating) {
      console.log('[FOLLOW] Animation interrupted: isFreeCameraAnimating = false');
      return;
    }
    // (Hash :follow check now handled by periodic interval)
    // Cleanup interval on animation end
    const originalOnComplete = onComplete;
    onComplete = function() {
      clearInterval(followCheckInterval);
      if (typeof originalOnComplete === 'function') originalOnComplete();
    };
    if (!startTime) startTime = ts;
    let elapsed = ts - startTime;
    let t = Math.min(1, elapsed / duration);
    let tip = interpolateLine(coords, t);
    if (layerId) {
      const src = map.getSource(layerId);
      if (src) {
        // Find the last full point before tip
        let dist = 0, lastIdx = 0, total = 0;
        for (let j = 1; j < coords.length; j++) total += getDistance(coords[j-1], coords[j]);
        let target = t * total;
        for (let j = 1; j < coords.length; j++) {
          let segLen = getDistance(coords[j-1], coords[j]);
          if (dist + segLen >= target) {
            lastIdx = j-1;
            break;
          }
          dist += segLen;
        }
        const partialCoords = coords.slice(0, lastIdx+1).concat([tip]);
        const partialLine = {
          type: 'FeatureCollection',
          features: [
            {
              type: 'Feature',
              geometry: {
                type: 'LineString',
                coordinates: partialCoords
              },
              properties: {}
            }
          ]
        };
        src.setData(partialLine);
      }
    }
    let targetCameraCenter;
    if (useOffset) {
      // Always keep the same pixel offset from tip as original map center to path start
      const tipPx = map.project({lng: tip[0], lat: tip[1]});
      const desiredCenterPx = { x: tipPx.x - offsetPx.x, y: tipPx.y - offsetPx.y };
      targetCameraCenter = map.unproject(desiredCenterPx);
    } else {
      // Move camera center along the path (classic follow)
      targetCameraCenter = {lng: tip[0], lat: tip[1]};
    }
    // Smoothly ease the camera center
    const ease = 0.15;
    currentCameraCenter = {
      lng: currentCameraCenter.lng + (targetCameraCenter.lng - currentCameraCenter.lng) * ease,
      lat: currentCameraCenter.lat + (targetCameraCenter.lat - currentCameraCenter.lat) * ease
    };
    // Set camera to always keep the same bearing, pitch, and zoom as at start
    map.jumpTo({
      center: currentCameraCenter,
      zoom: camZoom,
      bearing: camBearing,
      pitch: camPitch,
      animate: false
    });
    
    // Update distance ticker position and value
    if (ticker && ticker.classList.contains('active')) {
      const tipPx = map.project({lng: tip[0], lat: tip[1]});
      ticker.style.left = tipPx.x + 'px';
      ticker.style.top = tipPx.y + 'px';
      const currentDistKm = t * totalDistKm;
      ticker.textContent = currentDistKm.toFixed(1) + ' km';
    }
    
    if (t < 1) {
      requestAnimationFrame(animate);
    } else {
      if (layerId && originalData) {
        const src = map.getSource(layerId);
        if (src) src.setData(originalData);
      }
      isFreeCameraAnimating = false;
      // Hide ticker on completion
      if (ticker) ticker.classList.remove('active');
      try { if (followCheckInterval) clearInterval(followCheckInterval); } catch(e){}
      if (typeof onComplete === 'function') onComplete();
      window._follow = null;
  console.log('[FOLLOW END]', layerId);
    }
  }
  requestAnimationFrame(animate);
}

window.addEventListener('hashchange', () => {
  // Prevent double follow on initial load
  if (window._suppressNextFollowCancel) {
    window._suppressNextFollowCancel = false;
    return;
  }
  if (!window._lastHashState) window._lastHashState = '';
  const currentHash = window.location.hash;
  if (window._lastHashState === currentHash) return;
  window._lastHashState = currentHash;

  // Always cancel any running follow immediately so we can apply new state
  if (isFreeCameraAnimating) {
    try { if (window._follow && typeof window._follow.cancel === 'function') window._follow.cancel(); }
    catch(e) { isFreeCameraAnimating = false; }
    window._isFollowStarted = false; // Ensure new hash is processed after cancel
  }
  // Always reset follow started before processing new hash
  window._isFollowStarted = false;

  // ...existing code...

  const { camera, layers, dynamicGeojsonToLoad, followId } = parseHash();
  console.log('[FOLLOW DEBUG] Hash:', window.location.hash, '| followId:', followId, '| layers:', layers, '| dynamicGeojsonToLoad:', dynamicGeojsonToLoad);
  console.log('[FOLLOW DEBUG] About to process layers and dynamic sources...');

  // Load dynamic layers as needed (GeoJSON/CSV, Sentinel-2, or Wayback)
  if (dynamicGeojsonToLoad && dynamicGeojsonToLoad.length) {
    const layersOn = layers || [];
    dynamicGeojsonToLoad.forEach(entry => {
      let name = null, sourceHint = null, isS2 = false, s2Date = null, isWayback = false, waybackDate = null;
      if (typeof entry === 'string') {
        name = entry;
      } else if (entry && typeof entry === 'object') {
        name = entry.name;
        sourceHint = entry.sourceHint;
        isS2 = entry.isS2 || false;
        s2Date = entry.s2Date || null;
        isWayback = entry.isWayback || false;
        waybackDate = entry.waybackDate || null;
      }
      if (!name) return;
      
      // Check if layer already exists
      const layerExists = map.getLayer(name);
      // If this layer will be followed, load it hidden initially - the follow animation will show it
      const isFollowLayer = (name === followId);
      const visibility = isFollowLayer ? 'none' : (layersOn.includes(name) ? 'visible' : 'none');
      
      if (isS2 && s2Date) {
        // Sentinel-2 layer
        if (!layerExists) {
          console.log('[HASHCHANGE] Loading new Sentinel-2 layer:', name);
          loadS2Layer(s2Date, { visibility, sourceHint });
        } else if (sourceHint) {
          console.log('[HASHCHANGE] Reloading Sentinel-2 layer:', name, 'with sourceHint:', sourceHint);
          loadS2Layer(s2Date, { visibility, sourceHint });
        }
      } else if (isWayback && waybackDate) {
        // ESRI Wayback layer
        if (!layerExists) {
          console.log('[HASHCHANGE] Loading new Wayback layer:', name);
          loadWaybackLayer(waybackDate, { visibility, sourceHint });
        } else if (sourceHint) {
          console.log('[HASHCHANGE] Reloading Wayback layer:', name, 'with sourceHint:', sourceHint);
          loadWaybackLayer(waybackDate, { visibility, sourceHint });
        }
      } else {
        // GeoJSON/CSV layer
        if (!layerExists) {
          console.log('[HASHCHANGE] Loading new layer:', name, 'with sourceHint:', sourceHint, 'visibility:', visibility);
          loadAndAddOrReplaceGeoJSON(name + '.geojson', { visibility, sourceHint });
        } else if (sourceHint) {
          console.log('[HASHCHANGE] Reloading existing layer:', name, 'with sourceHint:', sourceHint);
          loadAndAddOrReplaceGeoJSON(name + '.geojson', { visibility, sourceHint });
        }
      }
    });
  }

  // 5. Fly to hash geolocation (with animation), then start follow only after fly completes
  const flyOpts = {
    center: [camera.center[0], camera.center[1]],
    zoom: camera.zoom,
    bearing: camera.bearing,
    pitch: camera.pitch,
    duration: 1200
  };

  // Always start follow if followId is present after camera update
  console.log('[FOLLOW DEBUG] Calling map.flyTo with:', flyOpts);
  map.flyTo(flyOpts);
  if (followId) {
    console.log('[FOLLOW DEBUG] followId detected, setting up follow for:', followId);
    // Wait for both flyTo and source readiness before starting follow
    let followReady = false;
    let flyDone = false;
    const tryStartFollow = () => {
      console.log('[FOLLOW DEBUG] tryStartFollow called. flyDone:', flyDone, 'followReady:', followReady);
      if (!flyDone || !followReady) return;
      const src = map.getSource(followId);
      if (!(src && src._data && src._data.features)) {
        console.log('[FOLLOW DEBUG] No source or features found for followId:', followId);
        return;
      }
      // Extract coords
      let coords = [];
      let geomTypes = [];
      src._data.features.forEach(f => {
        if (!f.geometry) return;
        geomTypes.push(f.geometry.type);
        if (f.geometry.type === 'LineString') coords = coords.concat(f.geometry.coordinates);
        if (f.geometry.type === 'Polygon') coords = coords.concat(f.geometry.coordinates[0]);
        if (f.geometry.type === 'MultiLineString') coords = coords.concat(...f.geometry.coordinates);
        if (f.geometry.type === 'MultiPolygon') coords = coords.concat(...f.geometry.coordinates.map(ring => ring[0]));
      });
      console.log('[FOLLOW DEBUG] Layer:', followId, 'Geom types:', geomTypes, 'Coords count:', coords.length);
      if (coords.length > 1) {
        console.log('[FOLLOW DEBUG] Starting new follow animation for:', followId);
        window._isFollowStarted = true;
        followPathWithFreeCamera(map, coords, () => {
          // On completion: freeze current camera into the hash and remove :follow to avoid jumping back
          const c = map.getCenter();
          const z = map.getZoom().toFixed(2);
          const b = map.getBearing().toFixed(1);
          const p = map.getPitch().toFixed(1);
          const cameraStr = `${c.lat.toFixed(5)},${c.lng.toFixed(5)},${z},${b},${p}`;
          let hash = window.location.hash.replace('#', '');
          const parts = hash.split('/');
          let layersStr = parts[1] || '';
          if (layersStr) {
            layersStr = layersStr.replace(new RegExp(`([+~]${followId}):follow`), '$1');
          }
          const newHash = `#${cameraStr}` + (layersStr ? `/${layersStr}` : '');
          window._suppressNextFollowCancel = true;
          window.location.replace(newHash);
          window._isFollowStarted = false;
        }, followId);
      } else {
        console.log('[FOLLOW DEBUG] Not enough coordinates to follow for layer:', followId);
      }
    };
    // Listen for flyend
    map.once('moveend', () => {
      console.log('[FOLLOW DEBUG] map.moveend fired, setting flyDone = true');
      flyDone = true;
      tryStartFollow();
    });
    // Listen for source readiness
    const checkSource = () => {
      const src = map.getSource(followId);
      if (src && src._data && src._data.features) {
        console.log('[FOLLOW DEBUG] Source', followId, 'is ready with', src._data.features.length, 'features');
        followReady = true;
        tryStartFollow();
        return true;
      }
      console.log('[FOLLOW DEBUG] Source', followId, 'not ready yet. src:', !!src, 'src._data:', !!(src && src._data), 'features:', !!(src && src._data && src._data.features));
      return false;
    };
    if (!checkSource()) {
      console.log('[FOLLOW DEBUG] Source not ready, listening for sourcedata events...');
      const onSourceData = (e) => {
        console.log('[FOLLOW DEBUG] sourcedata event for:', e.sourceId);
        if (e.sourceId === followId && checkSource()) {
          console.log('[FOLLOW DEBUG] Removing sourcedata listener for:', followId);
          map.off('sourcedata', onSourceData);
        }
      };
      map.on('sourcedata', onSourceData);
    } else {
      console.log('[FOLLOW DEBUG] Source already ready, calling tryStartFollow immediately');
      followReady = true;
      tryStartFollow();
    }
  } else {
    console.log('[FOLLOW DEBUG] No followId in hash, skipping follow setup');
  }
});
</script>
</body>
</html>