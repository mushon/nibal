<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Dynamic Mapbox Map with Hash Control</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    html, body, #map {
      height: 100%;
      margin: 0;
      padding: 0;
      width: 100%;
      background: #333; 
    }
    #layer-controls {
      position: fixed;
      top: 0;
      left: 0;
      width: 280px;
      height: 100vh;
      background: rgba(0,0,0,0.25);
      backdrop-filter: blur(10px);
      z-index: 1000;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      box-shadow: 2px 0 8px rgba(0,0,0,0.4);
      display: flex;
      flex-direction: column;
      transition: transform 0.3s ease;
      color: #fff;
    }
    #layer-controls.hidden {
      transform: translateX(-100%);
    }
    #layer-controls-header {
      padding: 15px;
      border-bottom: 1px solid rgba(255,255,255,0.15);
      flex-shrink: 0;
    }
    #layer-controls-header .title-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      margin-bottom: 5px;
    }
    #layer-controls-header h3 {
      margin: 0;
      font-size: 16px;
      font-weight: 600;
      color: #fff;
      flex: 1;
    }
    #reset-all-btn {
      background: transparent;
      border: none;
      color: rgba(255,255,255,0.7);
      cursor: pointer;
      padding: 4px 8px;
      font-size: 16px;
      line-height: 1;
      border-radius: 3px;
      transition: all 0.15s;
      flex-shrink: 0;
    }
    #add-layer-toggle-btn {
      background: transparent;
      border: none;
      color: rgba(255,255,255,0.7);
      cursor: pointer;
      padding: 4px 8px;
      font-size: 18px;
      line-height: 1;
      border-radius: 3px;
      transition: all 0.15s;
      flex-shrink: 0;
    }
    #add-layer-toggle-btn:hover {
      background: rgba(255,255,255,0.15);
      color: #fff;
    }
    #reset-all-btn:hover {
      background: rgba(255,255,255,0.15);
      color: #fff;
    }
    #layer-controls-header .hint {
      font-size: 11px;
      color: rgba(255,255,255,0.6);
      margin: 0;
    }
    #layer-list {
      flex: 1;
      overflow-y: auto;
      padding: 10px 15px;
      font-size: 13px;
    }
    .layer-list-item {
      display: flex;
      align-items: center;
      gap: 4px;
      margin: 4px 0;
    }
    #layer-list label {
      color: #fff;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 4px;
      border-radius: 3px;
      transition: background 0.15s;
      font-size: 13px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      flex: 1;
      min-width: 0;
    }
    #layer-list label:hover {
      background: rgba(255,255,255,0.1);
    }
    .layer-list-item button {
      background: transparent;
      border: none;
      color: rgba(255,255,255,0.7);
      cursor: pointer;
      padding: 4px 6px;
      font-size: 14px;
      line-height: 1;
      border-radius: 3px;
      transition: all 0.15s;
      flex-shrink: 0;
    }
    .layer-list-item button:hover {
      background: rgba(255,255,255,0.15);
      color: #fff;
    }
    .layer-list-item button[data-delete] {
      color: #ff4444;
      font-weight: bold;
    }
    .layer-list-item button[data-delete]:hover {
      color: #ff6666;
      background: rgba(255,68,68,0.2);
    }
    .layer-list-item button[data-follow] {
      font-size: 16px;
      padding: 2px 6px;
    }
    .layer-list-item button[data-follow].active {
      color: #4caf50;
      background: rgba(76,175,80,0.2);
    }
    .layer-list-item button[data-follow]:hover {
      color: #4caf50;
    }
    .follow-offset-input {
      display: none;
      width: 50px;
      padding: 2px 4px;
      margin-left: 2px;
      background: rgba(0,0,0,0.3);
      border: 1px solid rgba(76,175,80,0.4);
      border-radius: 3px;
      color: #4caf50;
      font-size: 11px;
      font-family: monospace;
      text-align: center;
      outline: none;
    }
    .follow-offset-input.active {
      display: inline-block;
    }
    .follow-offset-input:focus {
      border-color: #4caf50;
      background: rgba(76,175,80,0.1);
    }
    .filter-input {
      display: none;
      width: 120px;
      padding: 2px 4px;
      margin-left: 2px;
      background: rgba(0,0,0,0.3);
      border: 1px solid rgba(255,165,0,0.4);
      border-radius: 3px;
      color: #ffa500;
      font-size: 11px;
      font-family: monospace;
      outline: none;
    }
    .filter-input.active {
      display: inline-block;
    }
    .filter-input:focus {
      border-color: #ffa500;
      background: rgba(255,165,0,0.1);
    }
    /* Common properties dropdown for filters */
    .filter-prop-select {
      display: none;
      max-width: 140px;
      padding: 2px 4px;
      margin-left: 2px;
      background: rgba(0,0,0,0.3);
      border: 1px solid rgba(255,165,0,0.4);
      border-radius: 3px;
      color: #ffa500;
      font-size: 11px;
      font-family: inherit;
      outline: none;
      cursor: pointer;
    }
    .filter-prop-select.active {
      display: inline-block;
    }
    .layer-list-item button[data-filter] {
      font-size: 14px;
      padding: 2px 6px;
    }
    .layer-list-item button[data-filter].active {
      color: #ffa500;
      background: rgba(255,165,0,0.2);
    }
    .layer-list-item button[data-filter]:hover {
      color: #ffa500;
    }
    #layer-controls-footer {
      padding: 10px 15px;
      border-top: 1px solid rgba(255,255,255,0.15);
      flex-shrink: 0;
    }
    #copy-link-btn {
      width: 100%;
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 4px;
      padding: 10px 12px;
      font-family: inherit;
      font-size: 13px;
      cursor: pointer;
      transition: all 0.2s;
      text-align: center;
      color: #fff;
    }
    #copy-link-btn:hover {
      background: rgba(255,255,255,0.2);
      border-color: rgba(255,255,255,0.4);
    }
    #copy-link-btn:active {
      background: rgba(255,255,255,0.15);
    }
    #copy-link-btn.copied {
      background: #4caf50;
      color: white;
      border-color: #4caf50;
    }
    #add-layer-form {
      display: none;
      margin-top: 8px;
      padding: 8px 10px 4px;
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.15);
      border-radius: 6px;
      backdrop-filter: blur(6px);
    }
    #add-layer-form.active { display: block; }
    #add-layer-form label { display:block; font-size:11px; margin:0 0 4px; color:rgba(255,255,255,0.6); }
      .layer-tab {
        flex: 1;
        background: rgba(255,255,255,0.08);
        border: 1px solid rgba(255,255,255,0.2);
        border-radius: 4px;
        padding: 6px 8px;
        font-size: 12px;
        cursor: pointer;
        color: rgba(255,255,255,0.6);
        font-family: inherit;
        transition: all 0.15s;
      }
      .layer-tab:hover {
        background: rgba(255,255,255,0.15);
        color: rgba(255,255,255,0.8);
      }
      .layer-tab.active {
        background: rgba(255,255,255,0.22);
        border-color: rgba(255,255,255,0.4);
        color: #fff;
        font-weight: 500;
      }
    #layer-type-select {
      width: 100%;
      box-sizing: border-box;
      padding: 6px 8px;
      border-radius: 4px;
      border: 1px solid rgba(255,255,255,0.25);
      background: rgba(0,0,0,0.3);
      color: #fff;
      font-size: 12px;
      font-family: inherit;
      outline: none;
      cursor: pointer;
      margin-bottom: 8px;
    }
    #layer-type-select option { background: #222; color: #fff; }
    .layer-input-group { margin-bottom: 8px; }
    #new-layer-input, #satellite-date-input, #reference-layer-select {
      width: 100%;
      box-sizing: border-box;
      padding: 6px 8px;
      border-radius: 4px;
      border: 1px solid rgba(255,255,255,0.25);
      background: rgba(0,0,0,0.3);
      color: #fff;
      font-size: 12px;
      font-family: inherit;
      outline: none;
    }
    #new-layer-input:focus, #satellite-date-input:focus, #reference-layer-select:focus { border-color: rgba(255,255,255,0.5); }
    #satellite-date-input {
      color-scheme: dark;
      cursor: pointer;
    }
    #satellite-date-input::-webkit-calendar-picker-indicator {
      filter: invert(1);
    }
    #reference-layer-select { margin-top: 8px; cursor: pointer; }
    #reference-layer-select option { background: #222; color: #fff; }
    #add-layer-confirm-btn {
      margin-top: 6px;
      width: 100%;
      background: rgba(255,255,255,0.12);
      border: 1px solid rgba(255,255,255,0.25);
      border-radius: 4px;
      padding: 6px 8px;
      font-size: 12px;
      cursor: pointer;
      color:#fff;
      font-family: inherit;
      transition: background 0.15s, border-color 0.15s;
    }
    #add-layer-confirm-btn:hover { background: rgba(255,255,255,0.22); border-color: rgba(255,255,255,0.4); }
    #add-layer-error { margin:4px 0 0; font-size:11px; color:#ff6666; min-height:14px; }
    #distance-ticker {
      position: absolute;
      width: 80px;
      height: 80px;
      border-radius: 50%;
      display: none;
      align-items: center;
      justify-content: center;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      font-size: 14px;
      font-weight: 600;
      color: #fff;
      background: rgba(0,0,0,0.3);
      border: #fffa solid 1px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
      pointer-events: none;
      z-index: 10;
      transform: translate(-50%, -125%);
    }
    #distance-ticker.active {
      display: flex;
    }
    #wayback-iframe-container {
      position: fixed;
      left: 280px;
      top: 0;
      width: calc(100% - 280px);
      height: 100vh;
      z-index: 999;
      display: none;
      box-shadow: 2px 0 8px rgba(0,0,0,0.4);
    }
    #wayback-iframe-container.active {
      display: block;
    }
    #wayback-iframe {
      width: 100%;
      height: 100%;
      border: none;
    }
    /* Make the date input calendar icon white (WebKit browsers) */
    #satellite-date-input::-webkit-calendar-picker-indicator {
      filter: invert(1);
    }
    #satellite-date-input {
      color-scheme: dark;
    }
    /* Container becomes draggable (horizontally) via toolbar */
  </style>
  <script src="https://api.mapbox.com/mapbox-gl-js/v3.15.0/mapbox-gl.js"></script>
  <link href="https://api.mapbox.com/mapbox-gl-js/v3.15.0/mapbox-gl.css" rel="stylesheet" />
  <!-- Mapbox RTL Text Plugin is loaded on demand via setRTLTextPlugin; do not include as a <script> tag. -->
  <!-- Removed any Python-in-the-browser scripts (e.g., Pyodide, Brython) to prevent py.parse errors -->
  <!-- Add Papa Parse for robust CSV parsing -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
</head>
<body>
<div id="map"></div>
<div id="wayback-iframe-container">
  <iframe id="wayback-iframe" src="" allow="geolocation" sandbox="allow-scripts allow-same-origin allow-forms allow-popups" referrerpolicy="no-referrer" style="position:absolute; top:0; left:0; width:100%; height:100%;"></iframe>
</div>
<div id="layer-controls">
  <div id="layer-controls-header">
    <div class="title-row">
      <h3>Map Layers</h3>
      <button id="add-layer-toggle-btn" title="Add new layer">ï¼‹</button>
      <button id="reset-all-btn" title="Reset all layers to style defaults">â†»</button>
    </div>
    <p class="hint">Press 'E' to toggle edit mode</p>
    <div id="add-layer-form">
        <!-- Tab buttons -->
        <div id="layer-type-tabs" style="display: flex; gap: 4px; margin-bottom: 12px;">
          <button id="tab-geodata" class="layer-tab active" data-tab="geodata">Geodata</button>
          <button id="tab-satellite" class="layer-tab" data-tab="satellite">Satellite</button>
        </div>
      
      <!-- GeoJSON/CSV input (default visible) -->
      <div id="geojson-input-group" class="layer-input-group">
        <label for="new-layer-input">Layer filename</label>
        <input id="new-layer-input" list="local-layer-files" placeholder="Type to search local files" autocomplete="off" />
        <datalist id="local-layer-files"></datalist>
          <label for="reference-layer-select" style="margin-top: 8px;">Position after layer (optional)</label>
          <select id="reference-layer-select" title="Select a reference layer to insert after (optional)">
            <option value="">-- No reference (add at top) --</option>
          </select>
      </div>
      
        <!-- Satellite date picker (hidden by default) -->
      <div id="satellite-input-group" class="layer-input-group" style="display:none;">
        <label for="satellite-date-input">Satellite image date</label>
        <input id="satellite-date-input" type="date" placeholder="YYYY-MM-DD" />
  <p class="hint" style="font-size: 11px; margin: 4px 0 0; color: rgba(255,255,255,0.8);">choose the date from the list on the <a id="wayback-open-new" href="https://livingatlas.arcgis.com/wayback/" target="_blank" rel="noopener noreferrer" style="color:#9fd1ff;text-decoration:underline;">Wayback site</a> and enter it in the date picker</p>
      </div>
      
  <button id="add-layer-confirm-btn" title="Add the selected layer">Add Layer</button>
      <div id="add-layer-error"></div>
    </div>
  </div>
  <div id="layer-list"></div>
  <div id="layer-controls-footer">
  <button id="copy-link-btn" title="Copy a shareable link to this exact map view and layer configuration">ðŸ“‹ Copy Link</button>
  </div>
</div>
<div id="distance-ticker"></div>
<script>
// Hide control panel if in an iframe, show by default otherwise
if (window.self !== window.top) {
  // In iframe - hide by default
  document.addEventListener('DOMContentLoaded', function() {
    var controls = document.getElementById('layer-controls');
    if (controls) controls.classList.add('hidden');
  });
}

// Keyboard shortcut to toggle UI (E key)
document.addEventListener('keydown', function(e) {
  // Ignore if typing in an input field
  if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
  
  // Use code instead of key to work across keyboard layouts
  if (e.code === 'KeyE') {
    e.preventDefault();
    var controls = document.getElementById('layer-controls');
    if (controls) {
      const wasHidden = controls.classList.contains('hidden');
      controls.classList.toggle('hidden');
      
      // Tell parent about edit mode change
      if (window.parent && window.parent !== window) {
        window.parent.postMessage({ 
          type: 'bg-edit-mode', 
          enabled: wasHidden 
        }, '*');
      }
      console.log('[MAP] Edit mode:', wasHidden ? 'ON' : 'OFF');
    }
  } else if (e.code === 'KeyF') {
    // Foreground-only toggle - relay to parent
    e.preventDefault();
    if (window.parent && window.parent !== window) {
      window.parent.postMessage({ type: 'toggle-foreground-edit' }, '*');
    }
  } else if (e.code === 'KeyB') {
    // Background-only toggle - relay to parent
    e.preventDefault();
    if (window.parent && window.parent !== window) {
      window.parent.postMessage({ type: 'toggle-background-edit' }, '*');
    }
  }
});

// Local layer filenames (autogenerated from /map directory at build time)
// Only .geojson basenames are listed. Remote URLs are not yet persisted via hash.
const availableLocalLayerFiles = [
  'IDF_zone_210824_240824','IDF_zone_210824_240824_NEW','Areas_Designated_for_Evacuation_by_the_IDF','IDF_Zones','IDF_zone_010724-210724','IDF_zone_010724-210724_NEW','IDF_zone_041223-281223','IDF_zone_041223-281223_NEW','IDF_zone_060524-110524','IDF_zone_061024','IDF_zone_061024_NEW','IDF_zone_090925','IDF_zone_090925_NEW','IDF_zone_110824_150824','IDF_zone_110824_150824_NEW','IDF_zone_160824_200824','IDF_zone_160824_200824_NEW','IDF_zone_191025','IDF_zone_210724-100824','IDF_zone_210724-100824_NEW','IDF_zone_250824_280824','IDF_zone_250824_280824_NEW','IDF_zone_290824','IDF_zone_290824_NEW','IDF_zone_300824','IDF_zone_300824_NEW','IDF_zone_ALL_UNTIL_101025','al-mawasi-jabalia','al-zawaida-al-mawasi','evac-orders-dec2','evac-orders-dec4','evac-orders-dec5','gaza-deir-al-balah','gaza-khan-younis','gaza-nuseirat','gaza','jabalia-al-mawasi','jabalia-deir-al-balah','jabalia-gaza','jabalia-rafah','nuseirat-rafah','oct7-hamas','oct7_23_hamas','rafah-bureij','safe-area','wrong','wrong2','wrong3','wrong4','wrong5','wrong6'
];

function populateLocalLayerDatalist() {
  const dl = document.getElementById('local-layer-files');
  if (!dl) return;
  dl.innerHTML = '';
  const seen = new Set();
  availableLocalLayerFiles.forEach(name => {
    if (!seen.has(name)) {
      seen.add(name);
      const opt = document.createElement('option');
      opt.value = name;
      dl.appendChild(opt);
    }
  });
}
document.addEventListener('DOMContentLoaded', populateLocalLayerDatalist);

// Populate reference layer dropdown with current map layers
function populateReferenceLayerSelect() {
  const select = document.getElementById('reference-layer-select');
  if (!select || !window.map) return;
  
  // Keep the default "no reference" option
  const defaultOpt = select.querySelector('option[value=""]');
  select.innerHTML = '';
  if (defaultOpt) { defaultOpt.title = 'Add at the very top (no reference)'; select.appendChild(defaultOpt); }
  else {
    const opt = document.createElement('option');
    opt.value = '';
    opt.textContent = '-- No reference (add at top) --';
    opt.title = 'Add at the very top (no reference)';
    select.appendChild(opt);
  }
  
  // Add all current layers (reversed order - topmost first)
  if (window.allStyleLayers && window.allStyleLayers.length > 0) {
    // Reverse the array to show topmost layers first
    const reversedLayers = [...window.allStyleLayers].reverse();
    reversedLayers.forEach(layer => {
      if (window.map.getLayer(layer.id)) {
        const opt = document.createElement('option');
        opt.value = layer.id;
        opt.textContent = layer.name || layer.id;
        opt.title = `Insert new layer immediately after '${layer.name || layer.id}'`;
        select.appendChild(opt);
      }
    });
  }
}

// Refresh reference layer dropdown when form is opened
document.addEventListener('DOMContentLoaded', function() {
  const toggleBtn = document.getElementById('add-layer-toggle-btn');
  const form = document.getElementById('add-layer-form');
  if (toggleBtn && form) {
    toggleBtn.addEventListener('click', () => {
      const wasHidden = !form.classList.contains('active');
      form.classList.toggle('active');
      if (wasHidden) {
        // Form just opened - refresh the reference layer list
        populateReferenceLayerSelect();
      }
    });
  }
});

// Add layer logic (supports GeoJSON/CSV and Satellite imagery)
document.addEventListener('DOMContentLoaded', function() {
  const tabGeodataBtn = document.getElementById('tab-geodata');
  const tabSatelliteBtn = document.getElementById('tab-satellite');
  const geojsonGroup = document.getElementById('geojson-input-group');
  const satelliteGroup = document.getElementById('satellite-input-group');
  const geojsonInput = document.getElementById('new-layer-input');
  const satelliteDateInput = document.getElementById('satellite-date-input');
  const satelliteLatestDateEl = document.getElementById('satellite-latest-date');
  const refSelect = document.getElementById('reference-layer-select');
  const confirmBtn = document.getElementById('add-layer-confirm-btn');
  const errorEl = document.getElementById('add-layer-error');
  
  if (!confirmBtn) {
    console.warn('[ADD LAYER] UI elements not found');
    return;
  }
  
  let currentTab = 'geodata';

  // Tooltips for tabs and inputs
  if (tabGeodataBtn) tabGeodataBtn.title = 'Add a GeoJSON/CSV data layer';
  if (tabSatelliteBtn) tabSatelliteBtn.title = 'Add a satellite imagery layer (Wayback)';
  if (geojsonInput) {
    geojsonInput.title = 'Type or choose a local filename or URL';
    geojsonInput.addEventListener('input', () => { geojsonInput.title = geojsonInput.value || 'Type or choose a local filename or URL'; });
  }
  if (satelliteDateInput) {
    satelliteDateInput.title = 'Pick a date (YYYY-MM-DD)';
    satelliteDateInput.addEventListener('change', () => { satelliteDateInput.title = satelliteDateInput.value || 'Pick a date (YYYY-MM-DD)'; });
  }
  if (refSelect) {
    const updateRefTitle = () => {
      const selOpt = refSelect.options[refSelect.selectedIndex];
      refSelect.title = selOpt ? (selOpt.textContent || refSelect.title) : refSelect.title;
    };
    updateRefTitle();
    if (!refSelect.dataset.titleHandler) {
      refSelect.addEventListener('change', updateRefTitle);
      refSelect.dataset.titleHandler = '1';
    }
  }
  
  
  // Handle tab switching
  function switchTab(tabName) {
    currentTab = tabName;
    
    // Update tab button states
    if (tabGeodataBtn && tabSatelliteBtn) {
      tabGeodataBtn.classList.toggle('active', tabName === 'geodata');
      tabSatelliteBtn.classList.toggle('active', tabName === 'satellite');
    }
    
    // Show/hide input groups
    if (geojsonGroup) geojsonGroup.style.display = tabName === 'geodata' ? 'block' : 'none';
    if (satelliteGroup) satelliteGroup.style.display = tabName === 'satellite' ? 'block' : 'none';
    
    // Show/hide Wayback iframe
    const waybackContainer = document.getElementById('wayback-iframe-container');
    const waybackIframe = document.getElementById('wayback-iframe');
    if (tabName === 'satellite') {
      if (waybackContainer) waybackContainer.classList.add('active');
      const openLink = document.getElementById('wayback-open-new');
      const statusEl = document.getElementById('wayback-status');
      // Initialize/update iframe URL to current map view each time we open
      if (waybackIframe) {
        const center = window.map ? window.map.getCenter() : {lng: 34.3537, lat: 31.4238};
        const zoom = window.map ? Math.round(window.map.getZoom()) : 10;
        const url = `https://livingatlas.arcgis.com/wayback/#mapCenter=${center.lng.toFixed(5)}%2C${center.lat.toFixed(5)}%2C${zoom}`;
        try {
          if (openLink) openLink.href = url;
          // Always set/update src to ensure it loads
          waybackIframe.src = url;
          if (statusEl) statusEl.textContent = 'loadingâ€¦';
        } catch(e) {
          if (statusEl) statusEl.textContent = 'open in new tab';
        }
      }
    } else {
      if (waybackContainer) waybackContainer.classList.remove('active');
    }
  }
  
  // Add click handlers to tabs
  if (tabGeodataBtn) {
    tabGeodataBtn.addEventListener('click', (e) => {
      e.preventDefault();
      switchTab('geodata');
    });
  }
  if (tabSatelliteBtn) {
    tabSatelliteBtn.addEventListener('click', (e) => {
      e.preventDefault();
      switchTab('satellite');
    });
  }
  
  function setError(msg) { if (errorEl) errorEl.textContent = msg || ''; }
  
  // Capture when opening add-layer form
  const addLayerToggleBtn = document.getElementById('add-layer-toggle-btn');
  if (addLayerToggleBtn) {
    addLayerToggleBtn.addEventListener('click', () => {
      const form = document.getElementById('add-layer-form');
      const nowActive = form && form.classList.contains('active');
      if (nowActive) {
        // Will close - just hide the Wayback container if visible
        const waybackContainer = document.getElementById('wayback-iframe-container');
        if (waybackContainer) waybackContainer.classList.remove('active');
      }
    });
  }

  confirmBtn.addEventListener('click', function(e) {
    e.preventDefault();
    setError('');
    
  const layerType = currentTab === 'satellite' ? 'satellite' : 'geojson';
    const refLayer = refSelect ? refSelect.value.trim() : '';
    let baseLayerId = '';
    let layerId = '';
    let newToken = '';
    
    // Build layer ID based on type
    if (layerType === 'geojson') {
      const raw = (geojsonInput.value || '').trim();
      console.log('[ADD LAYER] GeoJSON/CSV, raw input:', raw, 'reference:', refLayer);
      if (!raw) { setError('Enter a local filename or URL.'); return; }
      // Accept any input, not just predefined list - datalist provides suggestions only
      if (!availableLocalLayerFiles.includes(raw)) { 
        console.warn('[ADD LAYER] Custom file/URL not in predefined list:', raw);
        // Don't return error - allow custom files/URLs
      }
      baseLayerId = raw;
      
    } else if (layerType === 'satellite') {
      const dateValue = ((satelliteDateInput ? satelliteDateInput.value : '') || '').trim();
      console.log('[ADD LAYER] Satellite, date:', dateValue, 'reference:', refLayer);
      if (!dateValue) { setError('Select a satellite image date.'); return; }
      
      // Convert YYYY-MM-DD to YYYYMMDD
      const dateStr = dateValue.replace(/-/g, '');
      baseLayerId = `wayback:${dateStr}`;
    }
    
    // Auto-increment layer ID if base layer already exists
    layerId = baseLayerId;
    let counter = 2;
    while (window.map && window.map.getLayer && window.map.getLayer(layerId)) {
      layerId = `${baseLayerId}#${counter}`;
      counter++;
    }
    
    if (layerId !== baseLayerId) {
      console.log('[ADD LAYER] Base layer exists, using auto-incremented ID:', layerId);
    }
    
    // Build token with potentially incremented layerId
    newToken = `+${layerId}`;
    if (refLayer) {
      if (layerType === 'satellite' && refLayer === 'satellite') {
        // Omit (satellite) since it's the default sourceHint
        newToken = `+${layerId}`;
      } else {
        newToken = `+${layerId}(${refLayer})`;
      }
    }
    
    // Update hash with new layer
  const existing = window.location.hash.replace('#','');
  const parts = existing.split('/');
  // Keep existing camera string; if none, fall back to current map view
  let cameraStr = parts[0] || '';
  if (!cameraStr && window.map) {
    const c = window.map.getCenter();
    cameraStr = `${c.lat.toFixed(5)},${c.lng.toFixed(5)},${window.map.getZoom().toFixed(2)},${window.map.getBearing().toFixed(1)},${window.map.getPitch().toFixed(1)}`;
  }
    let layersStr = parts[1] || '';
    const tokens = layersStr ? layersStr.split(',').filter(t => t.length>0) : [];
    
    // Check if this exact layer ID already exists in tokens and replace, otherwise append
    // Escape special regex chars but preserve # for counter matching
    const escapedLayerId = layerId.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    const regex = new RegExp(`^[+~]${escapedLayerId}(?:\\([^)]+\\))?(?:\\[([^\\]]+)\\])?(?::follow(?:\\+\\d*)?)?$`);
    const idx = tokens.findIndex(t => regex.test(t));
    if (idx >= 0) {
      // Layer with this exact ID exists, replace it
      tokens[idx] = newToken;
    } else {
      // New layer, append
      tokens.push(newToken);
    }
    layersStr = tokens.join(',');
    const newHash = `#${cameraStr}` + (layersStr ? `/${layersStr}` : '');
    console.log('[ADD LAYER] Old hash:', existing);
    console.log('[ADD LAYER] New hash:', newHash);
    console.log('[ADD LAYER] New token:', newToken);
    // Apply new hash with selected layer and restore previous camera view
    window.location.hash = newHash;
    
    // Clear inputs
    if (geojsonInput) geojsonInput.value = '';
    if (satelliteDateInput) satelliteDateInput.value = '';
    if (refSelect) refSelect.value = '';
    
    // Hide form and Wayback iframe
    const form = document.getElementById('add-layer-form');
    if (form) form.classList.remove('active');
    const waybackContainer = document.getElementById('wayback-iframe-container');
    if (waybackContainer) waybackContainer.classList.remove('active');
  
  });
  
  // Minimal status updates for the Wayback iframe
  const waybackIframe = document.getElementById('wayback-iframe');
  const waybackStatus = document.getElementById('wayback-status');
  if (waybackIframe) {
    waybackIframe.addEventListener('load', () => {
      if (waybackStatus) waybackStatus.textContent = '';
    });
    waybackIframe.addEventListener('error', () => {
      if (waybackStatus) waybackStatus.textContent = 'failed to load â€” open in new tab';
    });
  }
});


// Copy link button functionality
document.addEventListener('DOMContentLoaded', function() {
  var copyBtn = document.getElementById('copy-link-btn');
  if (copyBtn) {
    copyBtn.addEventListener('click', function() {
      // Get current URL and extract from 'map/' onwards
      var fullUrl = window.location.href;
      var mapIndex = fullUrl.indexOf('map/');
      var linkToCopy = mapIndex !== -1 ? fullUrl.substring(mapIndex) : fullUrl;
      
      // Copy to clipboard
      navigator.clipboard.writeText(linkToCopy).then(function() {
        // Visual feedback
        var originalText = copyBtn.textContent;
        copyBtn.textContent = 'âœ“ Copied!';
        copyBtn.classList.add('copied');
        
        setTimeout(function() {
          copyBtn.textContent = originalText;
          copyBtn.classList.remove('copied');
        }, 2000);
      }).catch(function(err) {
        console.error('Failed to copy:', err);
        alert('Failed to copy link. Please copy manually: ' + linkToCopy);
      });
    });
  }
});

// Sample Mapbox access token (replace with your own for production)
mapboxgl.accessToken = 'pk.eyJ1IjoiYnRzZWxlbW9yZyIsImEiOiJjbWhuNnF6djQwNTVlMnNzZjAxd2dqeWFyIn0.jw164iQiqRTNP1QMu-cbTg';

// Enable RTL text plugin for proper display of Arabic, Hebrew, and other RTL languages
mapboxgl.setRTLTextPlugin(
  'https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-rtl-text/v0.2.3/mapbox-gl-rtl-text.js',
  null,
  true // lazy load - only loads when needed
);

// Sample style
const style = 'mapbox://styles/btselemorg/cmhncne5l004p01qu9tpp7ih8/draft';

// Layers to toggle (layer ids must exist in the style)
// Will be populated with all layers from the style after map load
let allStyleLayers = [];
// Expose globally for UI access
window.allStyleLayers = allStyleLayers;

// Will hold the style default visibility for each layer
const styleDefaultVisibility = {};
// Will hold the style default filter for each layer (null means no filter)
const styleDefaultFilter = {};

// Layer types that support filters
const FILTERABLE_LAYER_TYPES = ['fill','line','circle','symbol','heatmap','fill-extrusion'];

function layerSupportsFilter(layerId) {
  try {
    const layer = map && map.getLayer ? map.getLayer(layerId) : null;
    if (!layer) return false;
    return FILTERABLE_LAYER_TYPES.includes(layer.type || '');
  } catch(e) { return false; }
}

// Convert a compact filter expression string like "name=jabalia|beit_hanoun" or "type!=boundary" into a Mapbox GL filter array
function parseFilterExprToMapbox(filterExpr) {
  if (!filterExpr) return null;
  const match = filterExpr.match(/^([^=!]+)(=|!=)(.+)$/);
  if (!match) return null;
  const [, property, operator, rawValue] = match;
  const decoded = decodeURIComponent(rawValue);
  const values = decoded.split('|').map(v => (isNaN(v) ? v : Number(v)));
  if (operator === '=') {
    if (values.length === 1) return ['==', ['get', property], values[0]];
    return ['any', ...values.map(val => ['==', ['get', property], val])];
  } else if (operator === '!=') {
    if (values.length === 1) return ['!=', ['get', property], values[0]];
    return ['all', ...values.map(val => ['!=', ['get', property], val])];
  }
  return null;
}

// Track externally loaded layers (not part of original style)
const externalLayers = new Set();

// Track layers with path geometry (LineString, Polygon) that can be followed
const followableLayers = new Set();

// Default camera
const defaultCamera = {
  center: [34.3537, 31.4238], // Custom view
  zoom: 10,
  bearing: 37.6,
  pitch: 0
};

// Parse hash: #lat,lng,zoom,bearing,pitch/+layer1,-layer2/load:filename
function parseHash() {
  const hash = window.location.hash.replace('#', '');
  if (!hash) return { camera: { ...defaultCamera }, layers: allStyleLayers.map(l => l.id), dynamicGeojsonToLoad: [], followId: null, followOffset: 0, showTicker: false, followHidden: false };
  let cameraStr = '', layersStr = '', followId = null, followOffset = 0, showTicker = false, followHidden = false;
  const parts = hash.split('/');
  const restParts = [];
  for (let i = 0; i < parts.length; i++) {
    if (parts[i].startsWith('load:')) {
      continue;
    } else if (parts[i].length > 0) {
      restParts.push(parts[i]);
    }
  }
  cameraStr = restParts[0] || '';
  layersStr = restParts[1] || '';
  const cameraParts = cameraStr ? cameraStr.split(',').map(Number) : [];
  let layersOn = allStyleLayers.map(l => l.id);
  let dynamicGeojsonToLoad = [];
  if (layersStr) {
    layersOn = [];
    const layerState = {};
    layersStr.split(',').forEach(token => {
      // Support +id:follow, ~id:follow, +id(source):follow, +id:follow+offset, +wayback:YYYYMMDD, +id[property=value], and +id#2 (auto-increment)
      // token examples: +name, ~name, +name:follow, +name:follow+, +name:follow+0, +name:follow+15000, +name(source), +name(source):follow, +wayback:20240215, +pois[name=jabalia], +gaza.geojson#2
      // New: :follow (no ticker), :follow+ or :follow+0 (ticker at 0), :follow+1000 (ticker at 1000m), [property=value] (filter), #N (auto-increment counter)
      const match = token.match(/^([+~])([^\[(#]+?)(?:#(\d+))?(?:\(([^)]+)\))?(?:\[([^\]]+)\])?(?::follow(\+(\d*))?)?$/);
      if (!match) {
        console.warn('[HASH] Failed to parse layer token:', token);
        return;
      }
      const [, sign, baseName, counterStr, sourceHint, filterExpr, plusSign, offset] = match;
      // Reconstruct full layer name with counter if present
      const lname = counterStr ? `${baseName}#${counterStr}` : baseName;
      const hasFollow = token.includes(':follow');
      const hasTickerFlag = !!plusSign; // true if group 6 captured anything (:follow+ or :follow+number)
      const parsedOffset = offset ? parseInt(offset, 10) : 0;
      
      // Parse filter expression like "name=jabalia" or "type!=boundary" or "name=jabalia|beit_hanoun"
      let filter = null;
      if (filterExpr) {
        const filterMatch = filterExpr.match(/^([^=!]+)(=|!=)(.+)$/);
        if (filterMatch) {
          const [, property, operator, value] = filterMatch;
          // Decode URI components and support multiple values separated by |
          const decodedValue = decodeURIComponent(value);
          const values = decodedValue.split('|').map(v => isNaN(v) ? v : Number(v));
          if (operator === '=') {
            if (values.length === 1) {
              filter = ['==', ['get', property], values[0]];
            } else {
              // OR filter: match any value
              filter = ['any', ...values.map(val => ['==', ['get', property], val])];
            }
          } else if (operator === '!=') {
            if (values.length === 1) {
              filter = ['!=', ['get', property], values[0]];
            } else {
              // AND filter: exclude all values
              filter = ['all', ...values.map(val => ['!=', ['get', property], val])];
            }
          }
          console.log('[HASH PARSE] Filter for', lname, ':', filterExpr, '->', filter);
        } else {
          console.warn('[HASH PARSE] Invalid filter expression:', filterExpr);
        }
      }
      
      // Always use the id without :follow for loading/toggling
      layerState[lname] = { sign, sourceHint: sourceHint || null, filter, follow: hasFollow, followOffset: parsedOffset, showTicker: hasTickerFlag };
    });
  Object.entries(layerState).forEach(([lname, { sign, sourceHint, filter, follow, followOffset: layerFollowOffset, showTicker: layerShowTicker }]) => {
      if (sign === '+') {
        const isStyleLayer = allStyleLayers.some(l => l.id === lname);
        const isExternalLayer = externalLayers.has(lname);
        
        // Load layer if:
        // 1. It's not a style layer (new external layer)
        // 2. It's an external layer and has a sourceHint (reload with new style)
        if (!isStyleLayer || (isExternalLayer && sourceHint)) {
          // Check if this is a Wayback layer (format: wayback:YYYYMMDD)
          const waybackMatch = lname.match(/^wayback:(\d{8})$/);
          if (waybackMatch) {
            const dateStr = waybackMatch[1];
            dynamicGeojsonToLoad.push({ name: lname, sourceHint: sourceHint || 'overlay', filter, isWayback: true, waybackDate: dateStr });
          } else {
            // Regular GeoJSON/CSV layer
            dynamicGeojsonToLoad.push({ name: lname, sourceHint, filter });
          }
        }
        layersOn.push(lname);
        if (follow) {
          followId = lname;
          followOffset = layerFollowOffset;
          showTicker = layerShowTicker;
          followHidden = (sign === '~');
        }
      } else if (sign === '~') {
        // For ~new-id, load as invisible (unchecked) dynamic layer
        const isStyleLayer = allStyleLayers.some(l => l.id === lname);
        const isExternalLayer = externalLayers.has(lname);
        
        if (!isStyleLayer || (isExternalLayer && sourceHint)) {
          dynamicGeojsonToLoad.push({ name: lname, sourceHint, filter });
        }
        if (follow) {
          followId = lname;
          followOffset = layerFollowOffset;
          showTicker = layerShowTicker;
          followHidden = (sign === '~');
        }
        // Do NOT add to layersOn, so it is not visible/checked
      }
    });
  }
  // Helper: treat 0 as a valid numeric value (don't use || which treats 0 as falsy)
  function pickNum(val, def) {
    return (typeof val === 'number' && !isNaN(val)) ? val : def;
  }

  return {
    camera: {
      center: [pickNum(cameraParts[1], defaultCamera.center[0]), pickNum(cameraParts[0], defaultCamera.center[1])],
      zoom: pickNum(cameraParts[2], defaultCamera.zoom),
      bearing: pickNum(cameraParts[3], defaultCamera.bearing),
      pitch: pickNum(cameraParts[4], defaultCamera.pitch)
    },
    layers: layersOn,
    dynamicGeojsonToLoad,
    followId,
    followOffset,
    showTicker,
    followHidden
  };
}

// Helper: load and add GeoJSON (or CSV as fallback) as a top layer or replace source of a layer
// geojsonFile: path or filename (typically name.geojson or name.geojson#2 for auto-incremented layers). If not found, we also try name.csv in the same folder.
// toLayer: optional { visibility } or { sourceHint }
async function loadAndAddOrReplaceGeoJSON(geojsonFile, toLayer) {
  // Extract base filename (without #N counter) for loading, but keep full name for layer ID
  // Pattern: match name, optional counter (#N), optional extension (.geojson/.json/.csv)
  const counterMatch = geojsonFile.match(/^(.+?)(#\d+)?(\.(?:geo)?json|\.csv)?$/);
  const baseName = counterMatch ? counterMatch[1] : geojsonFile.replace(/\.(geo)?json$|\.csv$/i, '');
  const counter = counterMatch ? (counterMatch[2] || '') : '';
  const extension = counterMatch ? (counterMatch[3] || '') : '';
  
  // Reconstruct: baseFile is for loading (no counter), geojsonFile stays as-is for layer ID
  const baseFile = baseName + extension;
  
  // 1) Attempt to fetch and normalize into GeoJSON
  async function loadAsGeoJSONOrCSV(path) {
    const lower = path.toLowerCase();
    const isCSV = lower.endsWith('.csv');
    const isJSON = lower.endsWith('.geojson') || lower.endsWith('.json');
    const base = path.replace(/\.(geo)?json$/i, '').replace(/\.csv$/i, '');
    const nameOnly = base.split('/').pop();
    const sameDirGeo = `${base}.geojson`;
    const sameDirCsv = `${base}.csv`;
    const dataDirCsv = `${base.substring(0, base.lastIndexOf('/')) !== '' ? base.substring(0, base.lastIndexOf('/')) + '/' : ''}data/${nameOnly}.csv`;
    const upDataDirCsv = `../data/${nameOnly}.csv`;

    // Try explicit path first
    if (isJSON) {
      try {
        console.debug('[DATA] Trying GeoJSON:', path);
        const r = await fetch(path);
        if (!r.ok) throw new Error(`HTTP ${r.status}`);
        return await r.json();
      } catch (e) {
        // Fallback to CSV beside it
        const csvPath = sameDirCsv;
        try {
          console.debug('[DATA] GeoJSON not found. Trying CSV (same dir):', csvPath);
          const r2 = await fetch(csvPath);
          if (!r2.ok) throw new Error(`HTTP ${r2.status}`);
          const txt = await r2.text();
          return csvTextToGeoJSON(txt);
        } catch (e2) {
          // Try ./data/ and ../data/
          try {
            console.debug('[DATA] Trying CSV (data/):', dataDirCsv);
            const r3 = await fetch(dataDirCsv);
            if (!r3.ok) throw new Error(`HTTP ${r3.status}`);
            const txt3 = await r3.text();
            return csvTextToGeoJSON(txt3);
          } catch (e3) {
            try {
              console.debug('[DATA] Trying CSV (../data/):', upDataDirCsv);
              const r4 = await fetch(upDataDirCsv);
              if (!r4.ok) throw new Error(`HTTP ${r4.status}`);
              const txt4 = await r4.text();
              return csvTextToGeoJSON(txt4);
            } catch (e4) {
              throw new Error(`Failed to load as GeoJSON (${path}) or CSV (${csvPath} | ${dataDirCsv} | ${upDataDirCsv}).`);
            }
          }
        }
      }
    } else if (isCSV) {
      try {
        console.debug('[DATA] Trying CSV:', path);
        const r = await fetch(path);
        if (!r.ok) throw new Error(`HTTP ${r.status}`);
        const txt = await r.text();
        return csvTextToGeoJSON(txt);
      } catch (e) {
        // Fallback to GeoJSON beside it
        const gjPath = sameDirGeo;
        try {
          console.debug('[DATA] CSV not found. Trying GeoJSON (same dir):', gjPath);
          const r2 = await fetch(gjPath);
          if (!r2.ok) throw new Error(`HTTP ${r2.status}`);
          return await r2.json();
        } catch (e2) {
          throw new Error(`Failed to load as CSV (${path}) or GeoJSON (${gjPath}).`);
        }
      }
    } else {
      // No extension provided: try .geojson then .csv
      try {
        console.debug('[DATA] No extension. Trying GeoJSON (same dir):', sameDirGeo);
        const r = await fetch(sameDirGeo);
        if (!r.ok) throw new Error(`HTTP ${r.status}`);
        return await r.json();
      } catch (e) {
        try {
          console.debug('[DATA] Trying CSV (same dir):', sameDirCsv);
          const r2 = await fetch(sameDirCsv);
          if (!r2.ok) throw new Error(`HTTP ${r2.status}`);
          const txt = await r2.text();
          return csvTextToGeoJSON(txt);
        } catch (e2) {
          // Try ./data/ and ../data/
          try {
            console.debug('[DATA] Trying CSV (data/):', dataDirCsv);
            const r3 = await fetch(dataDirCsv);
            if (!r3.ok) throw new Error(`HTTP ${r3.status}`);
            const txt3 = await r3.text();
            return csvTextToGeoJSON(txt3);
          } catch (e3) {
            try {
              console.debug('[DATA] Trying CSV (../data/):', upDataDirCsv);
              const r4 = await fetch(upDataDirCsv);
              if (!r4.ok) throw new Error(`HTTP ${r4.status}`);
              const txt4 = await r4.text();
              return csvTextToGeoJSON(txt4);
            } catch (e4) {
              throw new Error(`Failed to load ${nameOnly} as .geojson or .csv (searched: ${sameDirGeo}, ${sameDirCsv}, ${dataDirCsv}, ${upDataDirCsv})`);
            }
          }
        }
      }
    }
  }

  // CSV -> GeoJSON (Point features) using Papa Parse for robust CSV parsing
  function csvTextToGeoJSON(csvText) {
    if (typeof Papa === 'undefined' || !Papa.parse) {
      throw new Error('CSV parsing library not loaded.');
    }
    const res = Papa.parse(csvText, { header: true, dynamicTyping: true, skipEmptyLines: true });
    if (res.errors && res.errors.length) {
      console.warn('CSV parse warnings:', res.errors);
    }
    const rows = res.data || [];
    if (!rows.length) return { type: 'FeatureCollection', features: [] };
    // Find lat/lon columns (case-insensitive)
    const keys = Object.keys(rows[0] || {});
    const lowerMap = Object.fromEntries(keys.map(k => [k.toLowerCase(), k]));
    const latCandidates = ['lat', 'latitude', 'y'];
    const lonCandidates = ['lon', 'lng', 'long', 'longitude', 'x'];
    const latKey = latCandidates.map(k => lowerMap[k]).find(Boolean);
    const lonKey = lonCandidates.map(k => lowerMap[k]).find(Boolean);
    if (!latKey || !lonKey) {
      throw new Error('CSV missing latitude/longitude columns');
    }
    const features = [];
    for (const row of rows) {
      const lat = parseFloat(row[latKey]);
      const lon = parseFloat(row[lonKey]);
      if (!isFinite(lat) || !isFinite(lon)) continue;
      const props = { ...row };
      features.push({
        type: 'Feature',
        geometry: { type: 'Point', coordinates: [lon, lat] },
        properties: props
      });
    }
    return { type: 'FeatureCollection', features };
  }

  try {
    const geojson = await loadAsGeoJSONOrCSV(baseFile);
    // 2) Determine ids and clean - use full geojsonFile (with counter) for IDs
    let fileId = geojsonFile.split('/').pop();
    let cleanId = fileId.replace(/(_geojson|\.geojson|\.json|\.csv)$/i, '');
    cleanId = cleanId.replace(/[^a-zA-Z0-9_#-]/g, '_'); // Allow # for counter
    const sourceId = cleanId;
    const layerId = cleanId;

    // 3) Replace existing and add source
    if (map.getLayer(layerId)) map.removeLayer(layerId);
    if (map.getSource(sourceId)) map.removeSource(sourceId);
    map.addSource(sourceId, { type: 'geojson', data: geojson });

    // 4) Extract sourceHint and determine layer type
    let sourceHint = null;
    let filter = null;
    if (typeof toLayer === 'object' && toLayer !== null && toLayer.sourceHint) sourceHint = toLayer.sourceHint;
    if (typeof toLayer === 'object' && toLayer !== null && toLayer.filter) filter = toLayer.filter;
    if (!sourceHint && typeof geojsonFile === 'object' && geojsonFile.sourceHint) sourceHint = geojsonFile.sourceHint;
    if (!filter && typeof geojsonFile === 'object' && geojsonFile.filter) filter = geojsonFile.filter;
    
    let type = 'line';
    let sourceLayerFound = false;
    
    if (sourceHint) {
      const styleLayer = map.getStyle().layers.find(l => l.id === sourceHint);
      if (styleLayer && styleLayer.type) {
        type = styleLayer.type;
        sourceLayerFound = true;
      }
    }
    
    // Fallback: infer from geometry if no source layer found
    if (!sourceLayerFound) {
      if (geojson.features && geojson.features.length) {
        const geomType = geojson.features[0].geometry && geojson.features[0].geometry.type;
        if (geomType === 'Polygon' || geomType === 'MultiPolygon') type = 'fill';
        else if (geomType === 'Point' || geomType === 'MultiPoint') type = 'circle';
      }
    }

    // 5) Visibility
    let visibility = 'visible';
    if (typeof toLayer === 'object' && toLayer !== null && toLayer.visibility === 'none') {
      visibility = 'none';
    }

    // 6) Base paint defaults
    const basePaint = type === 'line' ? { 'line-color': '#fff', 'line-width': 3 } :
                      type === 'fill' ? { 'fill-color': '#f00', 'fill-opacity': 0.5 } :
                      { 'circle-radius': 6, 'circle-color': '#f00' };

    const layerDef = {
      id: layerId,
      type,
      source: sourceId,
      layout: { visibility },
      paint: basePaint
    };
    
    // Add filter if provided
    if (filter) {
      layerDef.filter = filter;
      console.log('[FILTER] Applied filter to layer', layerId, ':', filter);
    } else {
      console.log('[FILTER] No filter for layer', layerId);
    }

    // 7) Copy styling from sourceHint if provided
    try {
      if (sourceHint) {
        const styleLayer = map.getStyle().layers.find(l => l.id === sourceHint);
        if (styleLayer) {
          if (styleLayer.paint) layerDef.paint = JSON.parse(JSON.stringify(styleLayer.paint));
          if (styleLayer.layout) {
            const copiedLayout = JSON.parse(JSON.stringify(styleLayer.layout));
            if (typeof copiedLayout.visibility !== 'undefined') delete copiedLayout.visibility;
            layerDef.layout = Object.assign({}, layerDef.layout, copiedLayout);
          }
        }
      }
    } catch (ex) {
      console.warn('[STYLE COPY] Failed to apply source hint style:', ex);
    }

    // 8) Add layer - with beforeId to place right after source layer if sourceHint is provided
    try {
      if (sourceHint) {
        // Find the layer that comes right after the source layer to insert before it
        const allLayers = map.getStyle().layers;
        const sourceIndex = allLayers.findIndex(l => l.id === sourceHint);
        if (sourceIndex >= 0) {
          if (sourceIndex < allLayers.length - 1) {
            const beforeId = allLayers[sourceIndex + 1].id;
            map.addLayer(layerDef, beforeId);
          } else {
            // Source layer is last, add at top
            map.addLayer(layerDef);
          }
        } else {
          // Source layer not found
          map.addLayer(layerDef);
        }
      } else {
        // No source hint, add at top
        map.addLayer(layerDef);
      }
    } catch (ex) {
      console.warn('[LAYER ORDER] Failed to add layer with positioning:', ex);
      // Fallback: add without beforeId
      try {
        map.addLayer(layerDef);
      } catch (ex2) {
        console.error('[LAYER ORDER] Failed to add layer at all:', ex2);
        throw ex2;
      }
    }
    
    // Mark as external layer
    externalLayers.add(layerId);
  // External layers default filter is none
  styleDefaultFilter[layerId] = null;
    
    // Check if this layer has path geometry (followable)
    if (geojson && geojson.features && geojson.features.length > 0) {
      const hasPathGeometry = geojson.features.some(f => {
        if (!f.geometry) return false;
        const gType = f.geometry.type;
        return gType === 'LineString' || gType === 'MultiLineString' || 
               gType === 'Polygon' || gType === 'MultiPolygon';
      });
      if (hasPathGeometry) {
        followableLayers.add(layerId);
      }
    }

    // 9) Follow logic is handled centrally in the hashchange handler to ensure
    // camera and layer flags are applied first. No auto-follow here.

    // 10) Post-load bookkeeping/UI
    if (visibility === 'none') {
      map.setLayoutProperty(layerId, 'visibility', 'none');
    }
    if (!allStyleLayers.some(l => l.id === layerId)) {
      // Insert the layer in the correct position based on actual map layer order
      try {
        if (sourceHint) {
          // Find the source layer's position in allStyleLayers
          const sourceIdx = allStyleLayers.findIndex(l => l.id === sourceHint);
          if (sourceIdx >= 0) {
            // Insert right after the source layer
            allStyleLayers.splice(sourceIdx + 1, 0, { id: layerId, name: cleanId });
          } else {
            // Source not in list, add at end
            allStyleLayers.push({ id: layerId, name: cleanId });
          }
        } else {
          // No source hint, add at end
          allStyleLayers.push({ id: layerId, name: cleanId });
        }
      } catch (ex) {
        console.warn('Failed to position layer in list:', ex);
        allStyleLayers.push({ id: layerId, name: cleanId });
      }
      styleDefaultVisibility[layerId] = 'visible';
    }
    createLayerControls(map, allStyleLayers.filter(l => map.getLayer(l.id) && map.getLayoutProperty(l.id, 'visibility') === 'visible').map(l => l.id));
  } catch (err) {
    console.error('Error loading data:', err);
  }
}

// Helper: Load Sentinel-2 imagery layer by date
// Helper: Load ESRI Wayback imagery layer by date
// dateStr: YYYYMMDD format (e.g., "20240215")
// toLayer: optional { visibility, sourceHint }
async function loadWaybackLayer(dateStr, toLayer) {
  try {
    console.log('[WAYBACK] Loading ESRI Wayback layer for date:', dateStr);
    
    const layerId = `wayback:${dateStr}`;
    const sourceId = layerId;
    
    // Validate date format
    if (!/^\d{8}$/.test(dateStr)) {
      throw new Error('Invalid date format. Expected YYYYMMDD, got: ' + dateStr);
    }
    
    // Parse date
    const year = dateStr.substring(0, 4);
    const month = dateStr.substring(4, 6);
    const day = dateStr.substring(6, 8);
    const requestDate = `${year}-${month}-${day}`;
    
    // Fetch Wayback configuration
    console.log('[WAYBACK] Fetching Wayback release catalog...');
    const configResponse = await fetch('https://s3-us-west-2.amazonaws.com/config.maptiles.arcgis.com/waybackconfig.json');
    if (!configResponse.ok) {
      throw new Error('Failed to fetch Wayback configuration');
    }
    
    const config = await configResponse.json();
    
    // Parse releases and find closest one to requested date
    const releases = Object.entries(config).map(([releaseId, info]) => {
      // Extract date from title like "World Imagery (Wayback 2024-11-18)"
      const match = info.itemTitle.match(/(\d{4}-\d{2}-\d{2})/);
      if (match) {
        return {
          releaseId,
          date: match[1],
          dateObj: new Date(match[1]),
          title: info.itemTitle
        };
      }
      return null;
    }).filter(r => r !== null);
    
    // Sort by date
    releases.sort((a, b) => a.dateObj - b.dateObj);
    
    // Find closest release to requested date
    const targetDate = new Date(requestDate);
    let closestRelease = releases[0];
    let minDiff = Math.abs(targetDate - releases[0].dateObj);
    
    for (const release of releases) {
      const diff = Math.abs(targetDate - release.dateObj);
      if (diff < minDiff) {
        minDiff = diff;
        closestRelease = release;
      }
      // If we've passed the target date, stop
      if (release.dateObj > targetDate) {
        break;
      }
    }
    
    console.log(`[WAYBACK] Requested: ${requestDate}, Using release: ${closestRelease.date} (ID: ${closestRelease.releaseId})`);
    
    // ESRI Wayback tile URL
    // High resolution Maxar satellite imagery + aerial imagery
    // Updated every few weeks since February 2014
    const tileUrl = `https://wayback.maptiles.arcgis.com/arcgis/rest/services/world_imagery/wmts/1.0.0/default028mm/mapserver/tile/${closestRelease.releaseId}/{z}/{y}/{x}`;
    
    console.log('[WAYBACK] Using ESRI World Imagery Wayback (Maxar satellite imagery)');
    console.log('[WAYBACK] Tile URL pattern:', tileUrl.replace('{z}/{y}/{x}', 'Z/Y/X'));
    console.log('[WAYBACK] âœ“ High resolution imagery (up to 30cm in urban areas)');
    console.log('[WAYBACK] â„¹ï¸  Release:', closestRelease.title);
    
    // Extract sourceHint - default to 'satellite' layer for positioning (changed from 'overlay')
    let sourceHint = 'satellite';
    if (typeof toLayer === 'object' && toLayer !== null && toLayer.sourceHint) {
      sourceHint = toLayer.sourceHint;
    }
    
    // Remove existing layer/source if present
    if (map.getLayer(layerId)) map.removeLayer(layerId);
    if (map.getSource(sourceId)) map.removeSource(sourceId);
    
    // Add raster source
    map.addSource(sourceId, {
      type: 'raster',
      tiles: [tileUrl],
      tileSize: 256,
      minzoom: 0,
      maxzoom: 22,  // Wayback supports very high zoom levels
      attribution: 'Â© Esri, Maxar, GeoEye, Earthstar Geographics, CNES/Airbus DS, USDA, USGS, AeroGRID, IGN, and the GIS User Community'
    });
    console.log('[WAYBACK] Added raster source:', sourceId);
    
    // Visibility
    let visibility = 'visible';
    if (typeof toLayer === 'object' && toLayer !== null && toLayer.visibility === 'none') {
      visibility = 'none';
    }
    
    // Create layer definition
    const layerDef = {
      id: layerId,
      type: 'raster',
      source: sourceId,
      layout: { visibility },
      paint: {
        'raster-opacity': 1
      }
    };
    
    // Copy paint properties from source hint if available
    try {
      if (sourceHint) {
        const styleLayer = map.getStyle().layers.find(l => l.id === sourceHint);
        if (styleLayer && styleLayer.paint && styleLayer.paint['raster-opacity'] !== undefined) {
          layerDef.paint['raster-opacity'] = styleLayer.paint['raster-opacity'];
          console.log('[WAYBACK] Copied raster-opacity from', sourceHint);
        }
      }
    } catch (ex) {
      console.warn('[WAYBACK] Failed to copy paint from source hint:', ex);
    }
    
    // Add layer positioned right after the source hint layer
    try {
      if (sourceHint) {
        const allLayers = map.getStyle().layers;
        const sourceIndex = allLayers.findIndex(l => l.id === sourceHint);
        if (sourceIndex >= 0 && sourceIndex < allLayers.length - 1) {
          const beforeId = allLayers[sourceIndex + 1].id;
          console.log('[WAYBACK] Placing', layerId, 'right after', sourceHint, '(before', beforeId + ')');
          map.addLayer(layerDef, beforeId);
        } else {
          console.log('[WAYBACK] Source layer', sourceHint, 'is last or not found, adding at top');
          map.addLayer(layerDef);
        }
      } else {
        map.addLayer(layerDef);
      }
    } catch (ex) {
      console.warn('[WAYBACK] Failed to add layer with positioning:', ex);
      map.addLayer(layerDef);
    }
    
    console.log('[WAYBACK] Layer loaded:', layerId);
    
    // Mark as external layer
    externalLayers.add(layerId);
  // Wayback raster layers don't support filters, but store null for consistency
  styleDefaultFilter[layerId] = null;
    
    // Post-load bookkeeping
    if (visibility === 'none') {
      map.setLayoutProperty(layerId, 'visibility', 'none');
    }
    
    // Add to allStyleLayers if not present
    if (!allStyleLayers.some(l => l.id === layerId)) {
      try {
        if (sourceHint) {
          const sourceIdx = allStyleLayers.findIndex(l => l.id === sourceHint);
          if (sourceIdx >= 0) {
            allStyleLayers.splice(sourceIdx + 1, 0, { id: layerId, name: `Wayback ${requestDate}` });
            console.log('[WAYBACK] Inserted', layerId, 'after', sourceHint, 'in UI list');
          } else {
            allStyleLayers.push({ id: layerId, name: `Wayback ${requestDate}` });
          }
        } else {
          allStyleLayers.push({ id: layerId, name: `Wayback ${requestDate}` });
        }
      } catch (ex) {
        console.warn('[WAYBACK] Failed to position layer in list:', ex);
        allStyleLayers.push({ id: layerId, name: `Wayback ${requestDate}` });
      }
      styleDefaultVisibility[layerId] = 'visible';
    }
    
    // Update layer controls
    createLayerControls(map, allStyleLayers.filter(l => map.getLayer(l.id) && map.getLayoutProperty(l.id, 'visibility') === 'visible').map(l => l.id));
    
  } catch (err) {
    console.error('[WAYBACK] âŒ Error loading Wayback layer:', err);
    console.error('[WAYBACK] This may indicate:');
    console.error('[WAYBACK]   - Invalid date format or date out of range');
    console.error('[WAYBACK]   - Network connectivity issues');
    console.error('[WAYBACK]   - ESRI Wayback service temporary unavailability');
    console.error('[WAYBACK] Valid date range: February 2014 to present');
  }
}

// Update hash from map state
function updateHash(map, visibleLayers) {
  const c = map.getCenter();
  const z = map.getZoom().toFixed(2);
  const b = map.getBearing().toFixed(1);
  const p = map.getPitch().toFixed(1);
  // Preserve existing layer part of hash if present
  const hash = window.location.hash.replace('#', '');
  const [, layersStr] = hash.split('/');
  const cameraStr = `${c.lat.toFixed(5)},${c.lng.toFixed(5)},${z},${b},${p}`;
  if (layersStr !== undefined) {
    window.location.replace(`#${cameraStr}/${layersStr}`);
  } else {
    window.location.replace(`#${cameraStr}`);
  }
}

// Debounce helper for expensive operations
let createLayerControlsTimeout = null;
function createLayerControlsDebounced(map, visibleLayers) {
  if (createLayerControlsTimeout) clearTimeout(createLayerControlsTimeout);
  createLayerControlsTimeout = setTimeout(() => {
    createLayerControls(map, visibleLayers);
  }, 10);
}

// Cache for parsed hash state to avoid redundant parsing
let cachedHashString = '';
let cachedHashState = null;

// Create layer controls
function createLayerControls(map, visibleLayers) {
  const container = document.getElementById('layer-list');
  if (!container) return;
  
  // Performance: Build HTML in array then join once
  const htmlParts = [];
  let foundLayer = false;
  
  // Always reflect the current style visibility for checkboxes
  // Parse current hash for explicit toggles and :follow flags
  const hash = window.location.hash.replace('#', '');
  const [, layersStr] = hash.split('/');
  
  // Performance: Use cached parse result if hash hasn't changed
  let explicitState, followState, followOffsets, showTicker, layerFilters;
  if (cachedHashString === hash && cachedHashState) {
    explicitState = cachedHashState.explicitState;
    followState = cachedHashState.followState;
    followOffsets = cachedHashState.followOffsets;
    showTicker = cachedHashState.showTicker;
    layerFilters = cachedHashState.layerFilters;
  } else {
    explicitState = {};
    followState = {}; // Track which layers have :follow
    followOffsets = {}; // Track follow offset values
    showTicker = {}; // Track whether to show ticker (true if :follow+ or :follow+number)
    layerFilters = {}; // Track filter expressions for layers
    if (layersStr) {
      layersStr.split(',').forEach(token => {
        // Match pattern: +layerName or +layerName(source) or +layerName[filter] or +layerName:follow or +layerName(source):follow+15000 or +layerName[name=value]:follow
        // New: :follow (no ticker), :follow+ or :follow+0 (ticker), :follow+1000 (ticker with offset), [property=value] (filter)
        const match = token.match(/^([+~])([^\[(]+?)(?:\(([^)]+)\))?(?:\[([^\]]+)\])?(?::follow(\+(\d*))?)?$/);
        if (!match) return;
        const [, sign, lname, sourceHint, filterExpr, plusSign, offset] = match;
        explicitState[lname] = sign;
        const followFlag = token.includes(':follow');
        if (followFlag) {
          followState[lname] = true;
          // If there's a + sign (even without a number), show ticker
          showTicker[lname] = !!plusSign;
          // Parse the offset value (default to 0 if no digits provided)
          followOffsets[lname] = offset ? parseInt(offset, 10) : 0;
        }
        if (filterExpr) {
          layerFilters[lname] = filterExpr;
        }
      });
    }
    // Cache the result
    cachedHashString = hash;
    cachedHashState = { explicitState, followState, followOffsets, showTicker, layerFilters };
  }
  // Include all style layers and any geojson-above-* layers
  const allLayers = [
    ...allStyleLayers,
    ...map.getStyle().layers
      .filter(l => l.id.startsWith('geojson-above-') && !allStyleLayers.some(s => s.id === l.id))
      .map(l => ({ id: l.id }))
  ];
  // Order from highest (topmost) to lowest (bottommost)
  allLayers.reverse();
  allLayers.forEach(layer => {
    if (map.getLayer(layer.id)) {
      foundLayer = true;
      const vis = map.getLayoutProperty(layer.id, 'visibility');
      const defaultVis = styleDefaultVisibility[layer.id] || 'visible';
      let checked, bold, state, showReset = false;
      if (explicitState[layer.id] === '+') {
        checked = 'checked';
        bold = true;
        state = 'visible';
        showReset = (defaultVis !== 'visible');
      } else if (explicitState[layer.id] === '~') {
        checked = '';
        bold = true;
        state = 'hidden';
        showReset = (defaultVis !== 'none');
      } else {
        checked = (defaultVis === 'visible') ? 'checked' : '';
        bold = false;
        state = 'default';
        showReset = false;
      }
      let label = layer.name || layer.id;
      // Append sourceHint if present in hash explicit state (parse from token map)
      // We'll parse the hash token for this specific layer to see if it has a (sourceHint)
      let sourceHintForLabel = null;
      if (layersStr) {
        const tokensRaw = layersStr.split(',');
        for (const t of tokensRaw) {
          // Match including optional counter (#N) inside name part
          const m = t.match(/^([+~])([^\[(#]+?(?:#\d+)?)(?:\(([^)]+)\))?(?:\[[^\]]+\])?(?::follow(?:\+\d*)?)?$/);
          if (m) {
            const [, , lnameMaybe, srcHintMaybe] = m;
            if (lnameMaybe === layer.id && srcHintMaybe) {
              sourceHintForLabel = srcHintMaybe;
              break;
            }
          }
        }
      }
      if (sourceHintForLabel) {
        label += ` (${sourceHintForLabel})`;
      }
      // Check if this is an externally loaded layer
      const isExternalLayer = externalLayers.has(layer.id);
      // Check if this is a followable layer
      const isFollowable = followableLayers.has(layer.id);
      const isFollowing = followState[layer.id] || false;
      const hasTickerFlag = showTicker[layer.id] || false;
      // Check if this layer has a filter
      const layerFilter = layerFilters[layer.id] || '';
      const hasFilter = !!layerFilter;
      // Apply bold blue styling for external layers
      const labelStyle = isExternalLayer ? 'font-weight:bold;color:#4caf50;' : (bold ? 'font-weight:bold;' : '');
      
      // Build button HTML
      let buttonHtml = '';
      
      // Add filter button/input for any filterable layer type
      if (layerSupportsFilter(layer.id)) {
        const filterClass = hasFilter ? ' class="active"' : '';
        const filterInputClass = hasFilter ? ' class="active"' : '';
  buttonHtml += ` <button data-filter="${layer.id}" title="Add/edit feature filter"${filterClass}>á¯¤</button>`;
        buttonHtml += ` <input type="text" data-filter-input="${layer.id}" value="${layerFilter}" placeholder="property=value"${filterInputClass} class="filter-input" title="Filter expression (e.g., name=jabalia or name=jabalia|beit_hanoun)">`;
        // Common properties dropdown (hidden until filter UI toggled)
        const propSelectActive = hasFilter ? ' active' : '';
        buttonHtml += ` <select data-filter-prop="${layer.id}" class="filter-prop-select${propSelectActive}" title="Common properties for ${layer.id}"><option value="">â€” property â€”</option></select>`;
      }
      
      // Add follow button for followable layers
      if (isFollowable) {
        const followClass = isFollowing ? ' class="active"' : '';
        const offsetValue = followOffsets[layer.id] || 0;
        // Show offset input if following (allow user to add + to enable ticker)
        // OR if ticker flag is already present (:follow+ or :follow+number)
        const shouldShowInput = isFollowing || hasTickerFlag;
        const inputClass = shouldShowInput ? ' class="active"' : '';
        // Set input value to "+" by default when following without ticker, otherwise show offset number
        const inputValue = (isFollowing && !hasTickerFlag) ? '+' : offsetValue;
        console.log('[UI] Layer', layer.id, 'isFollowing:', isFollowing, 'hasTickerFlag:', hasTickerFlag, 'shouldShowInput:', shouldShowInput, 'inputValue:', inputValue);
        buttonHtml += ` <button data-follow="${layer.id}" title="Toggle follow animation"${followClass}>âž </button>`;
        buttonHtml += ` <input type="text" data-follow-offset="${layer.id}" value="${inputValue}" placeholder="+"${inputClass} class="follow-offset-input" title="Distance offset in meters, or + to show ticker from 0">`;
      }
      
      if (isExternalLayer) {
        buttonHtml += ` <button data-delete="${layer.id}" title="Delete layer">Ã—</button>`;
      } else if (explicitState[layer.id]) {
        buttonHtml += ` <button data-reset="${layer.id}" title="Reset to style default">â†»</button>`;
      }
      
      // Performance: Push to array instead of concatenating to innerHTML
      // Build a comprehensive tooltip (title) for this layer item
      const tooltipParts = [];
      tooltipParts.push(`Layer: ${layer.id}`);
      if (sourceHintForLabel) tooltipParts.push(`Source style: ${sourceHintForLabel}`);
      if (isExternalLayer) tooltipParts.push('External data layer');
      if (isFollowable) tooltipParts.push('Path geometry (followable)');
      if (isFollowing) tooltipParts.push(`Following path${showTicker[layer.id] ? ' (ticker active)' : ''}`);
      if (hasFilter) tooltipParts.push(`Filter: ${layerFilter}`);
      const itemTitle = tooltipParts.join(' â€¢ ');
      htmlParts.push(`<span class="layer-list-item" data-layer-item="${layer.id}" title="${itemTitle}"><label style="${labelStyle}" title="${itemTitle}"><input type="checkbox" data-layer="${layer.id}" ${checked} title="Toggle visibility for ${layer.id}"> ${label}</label>${buttonHtml}</span>`);
    }
  });
  
  if (!foundLayer) {
    htmlParts.push('<em>No toggleable layers found in the current style.</em>');
  }
  
  // Performance: Single DOM update instead of multiple
  container.innerHTML = htmlParts.join('');
  // Populate any active property dropdowns immediately
  container.querySelectorAll('select[data-filter-prop].active').forEach(sel => {
    const lid = sel.getAttribute('data-filter-prop');
    populateFilterPropsDropdown(lid, sel);
  });
  // After injecting HTML, property dropdowns exist; listeners added later in this function.
  container.querySelectorAll('input[type=checkbox]').forEach(cb => {
    cb.addEventListener('change', function() {
      const layerId = this.getAttribute('data-layer');
      if (!map.getLayer(layerId)) {
        console.warn(`Layer '${layerId}' not found in style.`);
        return;
      }
      // Parse current hash for explicit toggles
      const hash = window.location.hash.replace('#', '');
      const [cameraStr, layersStr] = hash.split('/');
      const tokenMap = {}; // Map layer name to full token
      if (layersStr) {
        layersStr.split(',').forEach(token => {
          // Parse token to extract layer name
          const match = token.match(/^([+~])([^\[(]+?)(?:\(([^)]+)\))?(?:\[([^\]]+)\])?(?::follow(\+(\d*))?)?$/);
          if (!match) return;
          const [, sign, lname] = match;
          tokenMap[lname] = token; // Store full token
        });
      }
      // Toggle + or ~ in hash and set visibility
      if (this.checked) {
        // If token exists, change sign to +, otherwise create new +token
        if (tokenMap[layerId]) {
          tokenMap[layerId] = tokenMap[layerId].replace(/^[+~]/, '+');
        } else {
          tokenMap[layerId] = `+${layerId}`;
        }
        map.setLayoutProperty(layerId, 'visibility', 'visible');
      } else {
        // If token exists, change sign to ~, otherwise create new ~token
        if (tokenMap[layerId]) {
          tokenMap[layerId] = tokenMap[layerId].replace(/^[+~]/, '~');
        } else {
          tokenMap[layerId] = `~${layerId}`;
        }
        map.setLayoutProperty(layerId, 'visibility', 'none');
      }
      // Build new hash from tokens
      const tokens = Object.values(tokenMap);
      if (tokens.length > 0) {
        window.location.replace(`#${cameraStr}/${tokens.join(',')}`);
      } else {
        window.location.replace(`#${cameraStr}`);
      }
    });
  });

  // Add reset button listeners for style layers
  container.querySelectorAll('button[data-reset]').forEach(btn => {
    btn.addEventListener('click', function(e) {
      e.preventDefault();
      const layerId = this.getAttribute('data-reset');
      // Parse current hash for explicit toggles
      const hash = window.location.hash.replace('#', '');
      const [cameraStr, layersStr] = hash.split('/');
      const explicitState = {};
      if (layersStr) {
        layersStr.split(',').forEach(token => {
          const match = token.match(/^([+~])(.+)$/);
          if (!match) return;
          const [, sign, lname] = match;
          explicitState[lname] = sign;
        });
      }
      // Remove explicit toggle for this layer
      delete explicitState[layerId];
      // Style layer: restore style default
      const defaultVis = styleDefaultVisibility[layerId] || 'visible';
      map.setLayoutProperty(layerId, 'visibility', defaultVis);
      // Build new hash
      const tokens = Object.entries(explicitState).map(([lname, sign]) => `${sign}${lname}`);
      if (tokens.length > 0) {
        window.location.replace(`#${cameraStr}/${tokens.join(',')}`);
      } else {
        window.location.replace(`#${cameraStr}`);
      }
    });
  });

  // Reset all button handler
  const resetAllBtn = document.getElementById('reset-all-btn');
  if (resetAllBtn) {
    resetAllBtn.addEventListener('click', function(e) {
      e.preventDefault();
      // Parse current hash to get camera position
      const hash = window.location.hash.replace('#', '');
      const [cameraStr] = hash.split('/');
      
      // Reset all layers to style defaults
      Object.keys(styleDefaultVisibility).forEach(layerId => {
        const defaultVis = styleDefaultVisibility[layerId];
        if (map.getLayer(layerId)) {
          map.setLayoutProperty(layerId, 'visibility', defaultVis);
        }
      });
      
      // Clear all explicit layer states from hash (keep only camera position)
      window.location.replace(`#${cameraStr}`);
      
      console.log('[MAP] All layers reset to style defaults');
    });
  }

  // Add follow button listeners for followable layers
  container.querySelectorAll('button[data-follow]').forEach(btn => {
    btn.addEventListener('click', function(e) {
      e.preventDefault();
      const layerId = this.getAttribute('data-follow');
      console.log('[FOLLOW BTN] Clicked for layer:', layerId);
      
      // Get offset input for this layer
      const offsetInput = container.querySelector(`input[data-follow-offset="${layerId}"]`);
      const offsetValue = offsetInput ? parseInt(offsetInput.value, 10) || 0 : 0;
      
      // Parse current hash
      const hash = window.location.hash.replace('#', '');
      const [cameraStr, layersStr] = hash.split('/');
      
      if (!layersStr) {
        console.warn('[FOLLOW BTN] No layers in hash');
        return;
      }
      
      // Parse layer tokens and toggle :follow for this layer
      const tokens = layersStr.split(',').map(token => {
        // Match: +layerName or +layerName(source) or +layerName[filter] with optional :follow or :follow+ or :follow+number
        const match = token.match(/^([+~])([^\[(]+?)(?:\(([^)]+)\))?(?:\[([^\]]+)\])?(?::follow(\+(\d*))?)?$/);
        if (!match) return token;
        
        const [, sign, lname, sourceHint, filterExpr, followFlag] = match;
        
        if (lname === layerId) {
          // Toggle :follow for this layer
          let newToken = `${sign}${lname}`;
          if (sourceHint) newToken += `(${sourceHint})`;
          if (filterExpr) newToken += `[${filterExpr}]`;
          
          if (followFlag) {
            // Remove :follow
            console.log('[FOLLOW BTN] Removing :follow from', layerId);
            return newToken;
          } else {
            // Add :follow (no ticker by default)
            console.log('[FOLLOW BTN] Adding :follow to', layerId);
            // After hash updates, focus the offset input so user can easily add ticker
            setTimeout(() => {
              const input = container.querySelector(`input[data-follow-offset="${layerId}"]`);
              if (input) {
                input.focus();
                // Move cursor to end without selecting text
                const len = input.value.length;
                input.setSelectionRange(len, len);
              }
            }, 100);
            return newToken + ':follow';
          }
        }
        
        return token;
      });
      
      const newLayersStr = tokens.join(',');
      const newHash = `#${cameraStr}/${newLayersStr}`;
      console.log('[FOLLOW BTN] New hash:', newHash);
      window.location.hash = newHash;
    });
  });

  // Add offset input listeners to update hash when changed
  container.querySelectorAll('input[data-follow-offset]').forEach(input => {
    const handleOffsetUpdate = function(e) {
      const layerId = this.getAttribute('data-follow-offset');
      const inputValue = this.value.trim();
      console.log('[FOLLOW OFFSET] Update for layer:', layerId, 'raw value:', inputValue);
      
      // Parse current hash
      const hash = window.location.hash.replace('#', '');
      const [cameraStr, layersStr] = hash.split('/');
      
      if (!layersStr) return;
      
      // Update the offset in the layer token and control ticker visibility
      const tokens = layersStr.split(',').map(token => {
        const match = token.match(/^([+~])([^\[(]+?)(?:\(([^)]+)\))?(?:\[([^\]]+)\])?(?::follow(\+(\d*))?)?$/);
        if (!match) return token;
        
        const [, sign, lname, sourceHint, filterExpr, followFlag] = match;
        const hasFollow = !!followFlag;
        
        if (lname === layerId && hasFollow) {
          let newToken = `${sign}${lname}`;
          if (sourceHint) newToken += `(${sourceHint})`;
          if (filterExpr) newToken += `[${filterExpr}]`;
          
          // Handle different input formats:
          // Empty string '' -> :follow (no ticker, remove +)
          // '+' -> :follow+ (ticker at 0, just +)
          // '0' or '+0' -> :follow+0 (ticker at 0, explicit)
          // '+1000' or '1000' -> :follow+1000 (ticker at 1000m)
          let followSuffix;
          if (inputValue === '') {
            // Empty: remove ticker, just follow
            followSuffix = ':follow';
            this.value = '+'; // Reset input to default
            console.log('[FOLLOW OFFSET] Removed ticker for', layerId);
          } else if (inputValue === '+') {
            // Just +: ticker at 0, keep as :follow+
            followSuffix = ':follow+';
            this.value = '+'; // Keep as +
            console.log('[FOLLOW OFFSET] Set ticker to + for', layerId);
          } else if (inputValue === '0' || inputValue === '+0') {
            // Explicit 0: ticker at 0
            followSuffix = ':follow+0';
            this.value = '0'; // Normalize display
            console.log('[FOLLOW OFFSET] Set ticker to 0 for', layerId);
          } else {
            // Parse as number (remove leading + if present)
            const cleanValue = inputValue.startsWith('+') ? inputValue.slice(1) : inputValue;
            const numValue = parseInt(cleanValue, 10);
            if (!isNaN(numValue) && numValue >= 0) {
              followSuffix = `:follow+${numValue}`;
              this.value = numValue.toString(); // Normalize display
              console.log('[FOLLOW OFFSET] Set ticker to', numValue, 'for', layerId);
            } else {
              // Invalid input, default to +
              followSuffix = ':follow+';
              this.value = '+';
              console.log('[FOLLOW OFFSET] Invalid input, defaulting to + for', layerId);
            }
          }
          return newToken + followSuffix;
        }
        
        return token;
      });
      
      const newLayersStr = tokens.join(',');
      const newHash = `#${cameraStr}/${newLayersStr}`;
      console.log('[FOLLOW OFFSET] New hash:', newHash);
      window.location.hash = newHash;
    };
    
    // Listen for Enter key
    input.addEventListener('keydown', function(e) {
      if (e.key === 'Enter') {
        e.preventDefault();
        handleOffsetUpdate.call(this, e);
      }
    });
    
    // Also listen for change event (when user tabs away)
    input.addEventListener('change', handleOffsetUpdate);
  });

  // Add delete button listeners for dynamic layers
  container.querySelectorAll('button[data-delete]').forEach(btn => {
    btn.addEventListener('click', function(e) {
      e.preventDefault();
      const layerId = this.getAttribute('data-delete');
      // Parse current hash and remove the token for this layer
      const hash = window.location.hash.replace('#', '');
      const [cameraStr, layersStr] = hash.split('/');
      const tokens = layersStr ? layersStr.split(',').filter(t => t.length > 0) : [];
      
      // Remove tokens that match this layerId (handles counter, sourceHint, filter, follow, etc.)
      const escapedLayerId = layerId.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      const regex = new RegExp(`^[+~]${escapedLayerId}(?:\\([^)]+\\))?(?:\\[([^\\]]+)\\])?(?::follow(?:\\+\\d*)?)?$`);
      const filteredTokens = tokens.filter(t => !regex.test(t));
      
      // Remove from map and state
      if (map.getLayer(layerId)) map.removeLayer(layerId);
      if (map.getSource(layerId)) map.removeSource(layerId);
      const idx = allStyleLayers.findIndex(l => l.id === layerId);
      if (idx !== -1) allStyleLayers.splice(idx, 1);
      delete styleDefaultVisibility[layerId];
      externalLayers.delete(layerId);
      followableLayers.delete(layerId);
      // Don't call createLayerControls here - let hashchange handler do it
      // Remove from hash and update URL (hashchange will refresh UI)
      if (filteredTokens.length > 0) {
        window.location.replace(`#${cameraStr}/${filteredTokens.join(',')}`);
      } else {
        window.location.replace(`#${cameraStr}`);
      }
    });
  });
  
  // Add filter button listeners
  container.querySelectorAll('button[data-filter]').forEach(btn => {
    btn.addEventListener('click', function(e) {
      e.preventDefault();
      const layerId = this.getAttribute('data-filter');
      const filterInput = container.querySelector(`input[data-filter-input="${layerId}"]`);
      const propSelect = container.querySelector(`select[data-filter-prop="${layerId}"]`);
      
      if (filterInput) {
        // Toggle input visibility
        filterInput.classList.toggle('active');
        this.classList.toggle('active');
        
        // Focus input when shown
        if (filterInput.classList.contains('active')) {
          filterInput.focus();
        } else {
          // If hiding input and it has a value, clear the filter from hash
          if (!filterInput.value.trim()) {
            updateFilterInHash(layerId, '');
          }
        }
      }

      // Toggle and populate properties dropdown
      if (propSelect) {
        propSelect.classList.toggle('active');
        if (propSelect.classList.contains('active')) {
          populateFilterPropsDropdown(layerId, propSelect);
        }
      }
    });
  });
  
  // Add filter input listeners to update hash when changed
  container.querySelectorAll('input[data-filter-input]').forEach(input => {
    const handleFilterUpdate = function(e) {
      const layerId = this.getAttribute('data-filter-input');
      const filterExpr = this.value.trim();
      console.log('[FILTER INPUT] Update for layer:', layerId, 'expression:', filterExpr);
      
      updateFilterInHash(layerId, filterExpr);
    };
    
    // Update on blur (when user leaves the input)
    input.addEventListener('blur', handleFilterUpdate);
    
    // Also update on Enter key
    input.addEventListener('keydown', function(e) {
      if (e.key === 'Enter') {
        e.preventDefault();
        this.blur(); // Trigger blur event which calls handleFilterUpdate
      }
    });
  });

  // Add property dropdown listeners: when a property is picked, seed the filter input
  container.querySelectorAll('select[data-filter-prop]').forEach(sel => {
    sel.addEventListener('change', function() {
      const layerId = this.getAttribute('data-filter-prop');
      const prop = this.value;
      if (!prop) return;
      const filterInput = container.querySelector(`input[data-filter-input="${layerId}"]`);
      if (filterInput) {
        // Seed with prop= (preserve any existing expression only when it starts with same prop)
        const prev = (filterInput.value || '').trim();
        if (!prev || !prev.startsWith(prop + '=')) {
          filterInput.value = `${prop}=`;
        }
        filterInput.focus();
        // Move cursor to end
        const len = filterInput.value.length;
        filterInput.setSelectionRange(len, len);
      }
    });
  });
}

// Helper function to update filter in hash
function updateFilterInHash(layerId, filterExpr) {
  // Parse current hash
  const hash = window.location.hash.replace('#', '');
  const [cameraStr, layersStr] = hash.split('/');
  
  if (!layersStr) return;
  
  // Update the filter in the layer token
  const tokens = layersStr.split(',').map(token => {
    // Match: +layerName or +layerName(source) with optional [filter] and :follow (supports counters #N)
    const match = token.match(/^([+~])([^\[(]+?(?:#\d+)?)(?:\(([^)]+)\))?(?:\[([^\]]+)\])?(?::follow(\+(\d*))?)?$/);
    if (!match) return token;
    
    const [, sign, lname, sourceHint, oldFilterExpr, followFlag] = match;
    
    if (lname === layerId) {
      // Rebuild token with new or removed filter
      let newToken = `${sign}${lname}`;
      if (sourceHint) newToken += `(${sourceHint})`;
      if (filterExpr) {
        newToken += `[${filterExpr}]`;
      }
      if (followFlag) newToken += ':follow' + followFlag;
      
      console.log('[FILTER] Updated token from', token, 'to', newToken);
      return newToken;
    }
    
    return token;
  });
  
  const newLayersStr = tokens.join(',');
  const newHash = `#${cameraStr}/${newLayersStr}`;
  console.log('[FILTER] New hash:', newHash);
  window.location.hash = newHash;
}

// Populate common properties dropdown by scanning a subset of features
function populateFilterPropsDropdown(layerId, selectEl) {
  if (!selectEl) return;
  try {
    let feats = [];
    // 1) Prefer rendered features for current viewport (works for style and external layers)
    try {
      feats = map.queryRenderedFeatures(undefined, { layers: [layerId] }) || [];
    } catch(e) { feats = []; }

    // 2) If none, try source data (GeoJSON external layers)
    if (!feats.length) {
      const src = map.getSource(layerId);
      if (src && src._data && src._data.features) {
        feats = src._data.features.map(f => ({ properties: f.properties || {} }));
      }
    }

    // 3) If still none, try vector tile cache via source/source-layer
    if (!feats.length) {
      const styleLayer = (map.getStyle().layers || []).find(l => l.id === layerId);
      if (styleLayer && styleLayer.source && styleLayer['source-layer']) {
        try {
          const srcFeats = map.querySourceFeatures(styleLayer.source, { sourceLayer: styleLayer['source-layer'] }) || [];
          feats = srcFeats.map(f => ({ properties: f.properties || {} }));
        } catch(e) {}
      }
    }

    const sampleSize = Math.min(100, feats.length);
    const propsCount = {};
    for (let i = 0; i < sampleSize; i++) {
      const f = feats[i];
      if (!f || !f.properties) continue;
      Object.keys(f.properties).forEach(k => {
        // Skip geometry-related duplicates and empty keys
        if (!k) return;
        propsCount[k] = (propsCount[k] || 0) + 1;
      });
    }
    const commonProps = Object.entries(propsCount)
      .filter(([, count]) => count > 0)
      .sort((a, b) => b[1] - a[1])
      .map(([key]) => key)
      .slice(0, 30); // limit
    // Preserve first placeholder option
    const placeholder = selectEl.querySelector('option[value=""]');
    selectEl.innerHTML = '';
    if (placeholder) selectEl.appendChild(placeholder);
    else {
      const ph = document.createElement('option');
      ph.value = '';
      ph.textContent = 'â€” property â€”';
      selectEl.appendChild(ph);
    }
    commonProps.forEach(prop => {
      const opt = document.createElement('option');
      opt.value = prop;
      opt.textContent = prop;
      selectEl.appendChild(opt);
    });
  } catch(e) {
    console.warn('[FILTER PROPS] Failed to populate for', layerId, e);
  }
}

const { camera, layers } = parseHash();

const map = new mapboxgl.Map({
  container: 'map',
  style,
  center: camera.center,
  zoom: camera.zoom,
  bearing: camera.bearing,
  pitch: camera.pitch
});
// Expose map globally for add-layer UI logic
window.map = map;

map.on('load', () => {
  // After all layers are loaded, if :follow is present in the hash, trigger follow logic directly (no hashchange event)
  const { camera: camInit, layers: layersInit, dynamicGeojsonToLoad: dynInit, followId: followInit, followOffset: followOffsetInit, showTicker: showTickerInit, followHidden: followHiddenInit } = parseHash();
  if (followInit) {
    // Only start follow if not already running (avoid double-trigger)
    if (!window._isFollowStarted) {
      window._isFollowStarted = true;
      const tryStartFollow = () => {
        const src = map.getSource(followInit);
        if (!(src && src._data && src._data.features)) {
          setTimeout(tryStartFollow, 100);
          return;
        }
        // Extract coords
        let coords = [];
        src._data.features.forEach(f => {
          if (!f.geometry) return;
          if (f.geometry.type === 'LineString') coords = coords.concat(f.geometry.coordinates);
          if (f.geometry.type === 'Polygon') coords = coords.concat(f.geometry.coordinates[0]);
          if (f.geometry.type === 'MultiLineString') coords = coords.concat(...f.geometry.coordinates);
          if (f.geometry.type === 'MultiPolygon') coords = coords.concat(...f.geometry.coordinates.map(ring => ring[0]));
        });
        if (coords.length > 1) {
          followPathWithFreeCamera(map, coords, () => {
            // On completion: freeze current camera into the hash and remove :follow to avoid jumping back
            const c = map.getCenter();
            const z = map.getZoom().toFixed(2);
            const b = map.getBearing().toFixed(1);
            const p = map.getPitch().toFixed(1);
            const cameraStr = `${c.lat.toFixed(5)},${c.lng.toFixed(5)},${z},${b},${p}`;
            let hash = window.location.hash.replace('#', '');
            const parts = hash.split('/');
            let layersStr = parts[1] || '';
            if (layersStr) {
              // Remove :follow or :follow+offset or :follow+ allowing optional (source) part
              layersStr = layersStr.replace(new RegExp(`([+~]${followInit})(?:\\([^)]+\\))?(?::follow(?:\\+\\d*)?)`), '$1');
            }
            const newHash = `#${cameraStr}` + (layersStr ? `/${layersStr}` : '');
            window._suppressNextFollowCancel = true;
            window.location.replace(newHash);
            window._isFollowStarted = false;
          }, followInit, followOffsetInit || 0, showTickerInit, followHiddenInit);
        }
      };
      setTimeout(tryStartFollow, 0);
    }
  }
  // Get all layers from the style
  allStyleLayers = map.getStyle().layers.map(l => ({ id: l.id }));
  window.allStyleLayers = allStyleLayers; // Keep window reference in sync
  // Store the style default visibility for each layer
  allStyleLayers.forEach(layer => {
    if (map.getLayer(layer.id)) {
      const styleLayer = map.getStyle().layers.find(l => l.id === layer.id);
      let vis = 'visible';
      if (styleLayer && styleLayer.layout && typeof styleLayer.layout.visibility !== 'undefined') {
        vis = styleLayer.layout.visibility;
      }
      styleDefaultVisibility[layer.id] = vis;
      // Store default filter for restoration
      try {
        styleDefaultFilter[layer.id] = (styleLayer && typeof styleLayer.filter !== 'undefined') ? styleLayer.filter : null;
      } catch(e) {
        styleDefaultFilter[layer.id] = null;
      }
    }
  });
  // Apply layer visibility from hash on initial load
  const { layers: hashLayers } = parseHash();
  const hashStr = window.location.hash.replace('#', '');
  const [, layersStr] = hashStr.split('/');
  if (layersStr) {
    const explicitState = {};
    layersStr.split(',').forEach(token => {
      const match = token.match(/^([+~])([^:(]+)(?:\(([^)]+)\))?(?::follow)?$/);
      if (!match) return;
      const [, sign, lname] = match;
      explicitState[lname] = sign;
    });
    
    // Apply visibility to all layers based on hash
    allStyleLayers.forEach(layer => {
      const id = layer.id;
      const explicit = explicitState[id];
      const defaultVis = styleDefaultVisibility[id] || 'visible';
      
      if (explicit === '+') {
        // Explicitly shown in hash
        if (map.getLayer(id) && map.getLayoutProperty(id, 'visibility') !== 'visible') {
          map.setLayoutProperty(id, 'visibility', 'visible');
        }
      } else if (explicit === '~') {
        // Explicitly hidden in hash
        if (map.getLayer(id) && map.getLayoutProperty(id, 'visibility') !== 'none') {
          map.setLayoutProperty(id, 'visibility', 'none');
        }
      }
      // If not mentioned in hash, keep style default (don't change)
    });
  }
  // If no layers specified in hash, keep all at their style defaults (don't change)
  
  // Update the toggle list to reflect current visibility
  createLayerControls(map, allStyleLayers.filter(l => map.getLayer(l.id) && map.getLayoutProperty(l.id, 'visibility') === 'visible').map(l => l.id));
  
  // Re-apply camera from hash after style load to ensure bearing/pitch/zoom are honored
  try {
    const { camera: parsedCamera } = parseHash();
    if (parsedCamera) {
      map.jumpTo({
        center: parsedCamera.center,
        zoom: parsedCamera.zoom,
        bearing: parsedCamera.bearing,
        pitch: parsedCamera.pitch,
        animate: false
      });
      console.log('[INIT] Applied camera from hash on load:', parsedCamera);
    }
  } catch (e) {
    console.warn('[INIT] Failed to apply parsed camera on load', e);
  }
  // Load any dynamic layers requested in the hash
  const { dynamicGeojsonToLoad, layers: layersOn } = parseHash();
  if (dynamicGeojsonToLoad && dynamicGeojsonToLoad.length) {
    dynamicGeojsonToLoad.forEach(entry => {
      let name = null, sourceHint = null, filter = null, isWayback = false, waybackDate = null;
      if (typeof entry === 'string') {
        name = entry;
      } else if (entry && typeof entry === 'object') {
        name = entry.name;
        sourceHint = entry.sourceHint;
        filter = entry.filter;
        isWayback = entry.isWayback || false;
        waybackDate = entry.waybackDate || null;
      }
      if (name) {
        const visibility = (layersOn && layersOn.includes(name)) ? 'visible' : 'none';
        if (isWayback && waybackDate) {
          // Load ESRI Wayback layer
          loadWaybackLayer(waybackDate, { visibility, sourceHint, filter });
        } else {
          // Load GeoJSON/CSV layer
          // Extract base name (without #N counter) for file loading, but pass full name for layer ID
          const counterMatch = name.match(/^(.+?)(#\d+)?$/);
          const baseName = counterMatch ? counterMatch[1] : name;
          const fullName = name; // Keep the full name with counter for layer ID
          
          // Load using base filename, but the function will use fullName for layer/source IDs
          loadAndAddOrReplaceGeoJSON(fullName + '.geojson', { visibility, sourceHint, filter });
        }
      }
    });
  }

  // Do NOT trigger hashchange handler here; let user navigation or manual hash changes do it.
});

// Update hash on camera move
map.on('moveend', () => {
  // During free-camera follow animation, don't write to the hash â€”
  // it can re-introduce :follow and cause unintended restarts.
  if (isFreeCameraAnimating) return;
  // Also avoid writing while :follow is present in the hash for any layer.
  try {
    const rawHash = window.location.hash.replace('#','');
    const parts = rawHash.split('/');
    const layersStr = parts[1] || '';
  if (layersStr.split(',').some(t => /:follow(?:\+\d+)?$/.test(t))) return;
  } catch(e){}
  // Only update camera part of hash, preserve layer toggles
  updateHash(map, []);
});

// Update distance ticker position on any map move (pan, zoom, rotate)
map.on('move', () => {
  const ticker = document.getElementById('distance-ticker');
  if (ticker && ticker.classList.contains('active') && !isFreeCameraAnimating) {
    // If ticker has stored coordinates, update its screen position
    const lng = parseFloat(ticker.dataset.lng);
    const lat = parseFloat(ticker.dataset.lat);
    if (!isNaN(lng) && !isNaN(lat)) {
      const tipPx = map.project({lng, lat});
      ticker.style.left = tipPx.x + 'px';
      ticker.style.top = tipPx.y + 'px';
    }
  }
});

// Listen for hash changes (external navigation)
let isFreeCameraAnimating = false;
let pendingHashUpdate = null;
function followPathWithFreeCamera(map, coords, onComplete, layerId, startOffset = 0, showTicker = false, keepLayerHidden = false) {
  // Periodic check for :follow in the hash
  // Escape layerId for regex
  const safeLayerId = layerId.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  console.log('[FOLLOW START]', layerId, 'coords:', coords.length, 'startOffset:', startOffset, 'showTicker:', showTicker);
  let followCheckInterval = setInterval(() => {
    const rawHash = window.location.hash;
    const hash = rawHash.replace('#', '');
    const [, layersStr] = hash.split('/');
    let stillFollowing = false;
    if (layersStr) {
      const tokens = layersStr.split(',');
      // Pattern must account for optional (sourceHint) after layer name and optional ticker flag: +layerId(source):follow or :follow+ or :follow+number
      stillFollowing = tokens.some(token => token.match(new RegExp(`^[+~]${safeLayerId}(?:\\([^)]+\\))?:follow(?:\\+\\d*)?$`)));
    }
    console.log(`[FOLLOW CHECK] hash: ${rawHash} | :follow present for ${layerId}?`, stillFollowing);
    if (!stillFollowing) {
      console.log(`[FOLLOW CHECK] :follow removed for ${layerId}, stopping animation and applying hash params.`);
      if (window._follow && typeof window._follow.cancel === 'function') {
        window._follow.cancel();
        console.log('[FOLLOW] Cancelled by hashchange or flag removal');
      } else {
        // Fallback cleanup
        isFreeCameraAnimating = false;
        clearInterval(followCheckInterval);
        try {
          if (layerId && originalData) {
            const src = map.getSource(layerId);
            if (src && src.setData) src.setData(originalData);
          }
        } catch(e) {}
        console.log('[FOLLOW] Fallback cancel cleanup');
      }
    }
  }, 1000);
  isFreeCameraAnimating = true;
  console.log('[FOLLOW] Animation state set: isFreeCameraAnimating = true');
  
  // Capture original visibility and only force-visible if not instructed to keep hidden
  let originalVisibility = null;
  if (layerId && map.getLayer(layerId)) {
    try { originalVisibility = map.getLayoutProperty(layerId, 'visibility'); } catch(e) { originalVisibility = null; }
    if (!keepLayerHidden) {
      map.setLayoutProperty(layerId, 'visibility', 'visible');
      console.log('[FOLLOW] Made layer visible:', layerId);
    }
  }
  
  // Expose a global cancel to allow immediate stop on hash changes
  if (!window._follow) window._follow = {};
  window._follow.layerId = layerId;
  window._follow.checkIntervalId = followCheckInterval;
  window._follow.cancel = function() {
    try { if (window._follow.checkIntervalId) clearInterval(window._follow.checkIntervalId); } catch(e){}
    isFreeCameraAnimating = false;
    try {
      if (layerId && originalData) {
        const src = map.getSource(layerId);
        if (src && src.setData) src.setData(originalData);
      }
    } catch(e) {}
    // Restore original visibility if we changed it
    try {
      if (layerId && originalVisibility !== null && !keepLayerHidden) {
        map.setLayoutProperty(layerId, 'visibility', originalVisibility);
      }
    } catch(e) {}
    // Hide distance ticker
    const ticker = document.getElementById('distance-ticker');
    if (ticker) ticker.classList.remove('active');
    // Do not modify hash or call onComplete here; caller controls next steps
    // Cleanup handle
    window._follow = null;
  };
  // Calculate total distance for constant speed
  function getDistance(a, b) {
    const R = 6371000;
    const toRad = Math.PI / 180;
    const dLat = (b[1] - a[1]) * toRad;
    const dLng = (b[0] - a[0]) * toRad;
    const lat1 = a[1] * toRad;
    const lat2 = b[1] * toRad;
    const aVal = Math.sin(dLat/2) * Math.sin(dLat/2) + Math.cos(lat1) * Math.cos(lat2) * Math.sin(dLng/2) * Math.sin(dLng/2);
    const c = 2 * Math.atan2(Math.sqrt(aVal), Math.sqrt(1-aVal));
    return R * c;
  }
  let totalDist = 0;
  for (let j = 1; j < coords.length; j++) totalDist += getDistance(coords[j-1], coords[j]);
  const duration = Math.max(2000, totalDist * 2); // ms, 2ms per meter, min 2s
  let startTime = null;
  let originalData = null;
  if (layerId) {
    const src = map.getSource(layerId);
    if (src && src._data) originalData = JSON.parse(JSON.stringify(src._data));
  }
  // Store original data reference for external cancel
  if (window._follow) window._follow.originalData = originalData;
  
  // Show distance ticker only if showTicker flag is true
  const ticker = document.getElementById('distance-ticker');
  const totalDistKm = totalDist / 1000;
  const startOffsetKm = startOffset / 1000;
  console.log('[FOLLOW] showTicker:', showTicker, 'ticker element:', !!ticker, 'totalDistKm:', totalDistKm);
  if (showTicker && ticker && totalDistKm > 0) {
    ticker.classList.add('active');
    ticker.textContent = startOffsetKm.toFixed(1) + ' km';
    console.log('[FOLLOW] Ticker activated');
  } else {
    console.log('[FOLLOW] Ticker NOT activated - showTicker:', showTicker, 'ticker:', !!ticker, 'totalDistKm:', totalDistKm);
  }
  function getBearing(from, to) {
    // Calculate bearing in radians from point 'from' to point 'to'
    const rad = Math.PI / 180;
    const lat1 = from[1] * rad;
    const lat2 = to[1] * rad;
    const dLon = (to[0] - from[0]) * rad;
    const y = Math.sin(dLon) * Math.cos(lat2);
    const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);
    let brng = Math.atan2(y, x);
    return brng;
  }

  function interpolateLine(coords, t) {
    // t in [0,1], returns the point at t along the line
    let dist = 0, segStart = coords[0], segEnd = coords[1], segIdx = 1;
    let total = 0;
    for (let j = 1; j < coords.length; j++) total += getDistance(coords[j-1], coords[j]);
    let target = t * total;
    for (let j = 1; j < coords.length; j++) {
      let segLen = getDistance(coords[j-1], coords[j]);
      if (dist + segLen >= target) {
        segStart = coords[j-1];
        segEnd = coords[j];
        segIdx = j;
        break;
      }
      dist += segLen;
    }
    let segT = (target - dist) / getDistance(segStart, segEnd);
    return [
      segStart[0] + (segEnd[0] - segStart[0]) * segT,
      segStart[1] + (segEnd[1] - segStart[1]) * segT
    ];
  }

  // Easing function (easeInOutQuad)
  function easeInOutQuad(x) {
    return x < 0.5 ? 2 * x * x : 1 - Math.pow(-2 * x + 2, 2) / 2;
  }

  // Before animation: capture the current camera state at the moment follow starts
  const camBearing = map.getBearing();
  const camPitch = map.getPitch();
  const camZoom = map.getZoom();
  // Get current map center and path start in screen (pixel) coordinates
  const mapCenter = map.getCenter();
  const mapCenterPx = map.project(mapCenter);
  const pathStartPx = map.project({lng: coords[0][0], lat: coords[0][1]});
  // Offset vector in pixels from map center to path start
  const offsetPx = { x: pathStartPx.x - mapCenterPx.x, y: pathStartPx.y - mapCenterPx.y };
  // Camera state for smooth following
  let currentCameraCenter = mapCenter;
  let useOffset = Math.abs(offsetPx.x) > 1e-2 || Math.abs(offsetPx.y) > 1e-2;

  function animate(ts) {
    if (!isFreeCameraAnimating) {
      console.log('[FOLLOW] Animation interrupted: isFreeCameraAnimating = false');
      return;
    }
    // (Hash :follow check now handled by periodic interval)
    // Cleanup interval on animation end
    const originalOnComplete = onComplete;
    onComplete = function() {
      clearInterval(followCheckInterval);
      if (typeof originalOnComplete === 'function') originalOnComplete();
    };
    if (!startTime) startTime = ts;
    let elapsed = ts - startTime;
    let t = Math.min(1, elapsed / duration);
    let tip = interpolateLine(coords, t);
    if (layerId) {
      const src = map.getSource(layerId);
      if (src) {
        // Find the last full point before tip
        let dist = 0, lastIdx = 0, total = 0;
        for (let j = 1; j < coords.length; j++) total += getDistance(coords[j-1], coords[j]);
        let target = t * total;
        for (let j = 1; j < coords.length; j++) {
          let segLen = getDistance(coords[j-1], coords[j]);
          if (dist + segLen >= target) {
            lastIdx = j-1;
            break;
          }
          dist += segLen;
        }
        const partialCoords = coords.slice(0, lastIdx+1).concat([tip]);
        const partialLine = {
          type: 'FeatureCollection',
          features: [
            {
              type: 'Feature',
              geometry: {
                type: 'LineString',
                coordinates: partialCoords
              },
              properties: {}
            }
          ]
        };
        src.setData(partialLine);
      }
    }
    let targetCameraCenter;
    if (useOffset) {
      // Always keep the same pixel offset from tip as original map center to path start
      const tipPx = map.project({lng: tip[0], lat: tip[1]});
      const desiredCenterPx = { x: tipPx.x - offsetPx.x, y: tipPx.y - offsetPx.y };
      targetCameraCenter = map.unproject(desiredCenterPx);
    } else {
      // Move camera center along the path (classic follow)
      targetCameraCenter = {lng: tip[0], lat: tip[1]};
    }
    // Smoothly ease the camera center
    const ease = 0.15;
    currentCameraCenter = {
      lng: currentCameraCenter.lng + (targetCameraCenter.lng - currentCameraCenter.lng) * ease,
      lat: currentCameraCenter.lat + (targetCameraCenter.lat - currentCameraCenter.lat) * ease
    };
    // Set camera to always keep the same bearing, pitch, and zoom as at start
    map.jumpTo({
      center: currentCameraCenter,
      zoom: camZoom,
      bearing: camBearing,
      pitch: camPitch,
      animate: false
    });
    
    // Update distance ticker position and value
    if (ticker && ticker.classList.contains('active')) {
      const tipPx = map.project({lng: tip[0], lat: tip[1]});
      ticker.style.left = tipPx.x + 'px';
      ticker.style.top = tipPx.y + 'px';
      const currentDistKm = startOffsetKm + (t * totalDistKm);
      ticker.textContent = currentDistKm.toFixed(1) + ' km';
      // Store the current tip coordinates for post-animation updates
      ticker.dataset.lng = tip[0];
      ticker.dataset.lat = tip[1];
      console.log('[FOLLOW ANIMATE] Ticker updated:', currentDistKm.toFixed(1), 'km');
    } else {
      console.log('[FOLLOW ANIMATE] Ticker NOT updated - ticker:', !!ticker, 'hasActive:', ticker ? ticker.classList.contains('active') : false);
    }
    
    if (t < 1) {
      requestAnimationFrame(animate);
    } else {
      if (layerId && originalData) {
        const src = map.getSource(layerId);
        if (src) src.setData(originalData);
      }
      // Restore original visibility if we changed it (only when not keeping hidden)
      try {
        if (layerId && originalVisibility !== null && !keepLayerHidden) {
          map.setLayoutProperty(layerId, 'visibility', originalVisibility);
        }
      } catch(e) {}
      isFreeCameraAnimating = false;
      // Keep ticker visible on completion (don't hide it)
      // Store final position in data attributes so map move handler can update it
      if (ticker && ticker.classList.contains('active')) {
        ticker.dataset.lng = tip[0];
        ticker.dataset.lat = tip[1];
      }
      // if (ticker) ticker.classList.remove('active');
      try { if (followCheckInterval) clearInterval(followCheckInterval); } catch(e){}
      if (typeof onComplete === 'function') onComplete();
      window._follow = null;
  console.log('[FOLLOW END]', layerId);
    }
  }
  requestAnimationFrame(animate);
}

window.addEventListener('hashchange', () => {
  // Invalidate hash parse cache on hashchange
  cachedHashString = '';
  cachedHashState = null;
  
  // Prevent double follow on initial load
  if (window._suppressNextFollowCancel) {
    window._suppressNextFollowCancel = false;
    return;
  }
  if (!window._lastHashState) window._lastHashState = '';
  const currentHash = window.location.hash;
  if (window._lastHashState === currentHash) return;
  window._lastHashState = currentHash;

  // Always cancel any running follow immediately so we can apply new state
  if (isFreeCameraAnimating) {
    try { if (window._follow && typeof window._follow.cancel === 'function') window._follow.cancel(); }
    catch(e) { isFreeCameraAnimating = false; }
    window._isFollowStarted = false; // Ensure new hash is processed after cancel
  }
  // Always reset follow started before processing new hash
  window._isFollowStarted = false;

  // ...existing code...

  const { camera, layers, dynamicGeojsonToLoad, followId, followOffset, showTicker, followHidden } = parseHash();
  console.log('[FOLLOW DEBUG] Hash:', window.location.hash, '| followId:', followId, '| followOffset:', followOffset, '| showTicker:', showTicker, '| layers:', layers, '| dynamicGeojsonToLoad:', dynamicGeojsonToLoad);
  console.log('[FOLLOW DEBUG] About to process layers and dynamic sources...');

  // Apply layer visibility from hash for all existing layers
  const hashStr = window.location.hash.replace('#', '');
  const [, layersStr] = hashStr.split('/');
  if (layersStr) {
    const explicitState = {};
    const filterState = {}; // layerId -> filter array
    const filterExprState = {}; // layerId -> original expr (string)
    layersStr.split(',').forEach(token => {
      // Updated regex to handle layer names with colons (e.g., s2:20240215, wayback:20240215)
      const match = token.match(/^([+~])([^\[(]+?)(?:#\d+)?(?:\(([^)]+)\))?(?:\[([^\]]+)\])?(?::follow(?:\+(\d*))?)?$/);
      if (!match) return;
      const [, sign, lname, _sourceHint, filterExpr] = match;
      explicitState[lname] = sign;
      if (filterExpr) {
        const filterArr = parseFilterExprToMapbox(filterExpr);
        if (filterArr) {
          filterState[lname] = filterArr;
          filterExprState[lname] = filterExpr;
        }
      }
    });
    
    // Apply visibility to all existing style layers based on hash
    allStyleLayers.forEach(layer => {
      const id = layer.id;
      const explicit = explicitState[id];
      const defaultVis = styleDefaultVisibility[id] || 'visible';
      
      if (map.getLayer(id)) {
        if (explicit === '+') {
          // Explicitly shown in hash
          if (map.getLayoutProperty(id, 'visibility') !== 'visible') {
            map.setLayoutProperty(id, 'visibility', 'visible');
            console.log('[HASHCHANGE] Showing layer:', id);
          }
        } else if (explicit === '~') {
          // Explicitly hidden in hash
          if (map.getLayoutProperty(id, 'visibility') !== 'none') {
            map.setLayoutProperty(id, 'visibility', 'none');
            console.log('[HASHCHANGE] Hiding layer:', id);
          }
        } else {
          // Not mentioned - check if it's an external layer
          if (externalLayers.has(id)) {
            // External layers not in hash should be removed entirely
            if (!explicitState[id]) {
              if (map.getLayer(id)) map.removeLayer(id);
              if (map.getSource(id)) map.removeSource(id);
              const idx = allStyleLayers.findIndex(l => l.id === id);
              if (idx !== -1) allStyleLayers.splice(idx, 1);
              delete styleDefaultVisibility[id];
              externalLayers.delete(id);
              followableLayers.delete(id);
            }
          } else {
            // Style layers - restore to style default
            if (map.getLayoutProperty(id, 'visibility') !== defaultVis) {
              map.setLayoutProperty(id, 'visibility', defaultVis);
              console.log('[HASHCHANGE] Restoring layer to default:', id, defaultVis);
            }
          }
        }
      }
    });

    // Apply filters (style and external layers) according to hash
    try {
      const allMapLayers = map.getStyle().layers || [];
      allMapLayers.forEach(l => {
        const id = l.id;
        if (!layerSupportsFilter(id)) return;
        const filterForLayer = filterState[id];
        if (typeof filterForLayer !== 'undefined') {
          try { map.setFilter(id, filterForLayer); } catch(e) { /* ignore unsupported */ }
        } else {
          // Restore default
          const def = (id in styleDefaultFilter) ? styleDefaultFilter[id] : null;
          try { map.setFilter(id, def); } catch(e) { /* ignore unsupported */ }
        }
      });
    } catch(e) { console.warn('[HASHCHANGE] Filter application error', e); }
  } else {
    // No layers specified in hash - restore all layers to their style defaults
    allStyleLayers.forEach(layer => {
      if (map.getLayer(layer.id)) {
        if (externalLayers.has(layer.id)) {
          // Hide external layers when no layers in hash
          if (map.getLayoutProperty(layer.id, 'visibility') !== 'none') {
            map.setLayoutProperty(layer.id, 'visibility', 'none');
            console.log('[HASHCHANGE] Hiding external layer (no flags in hash):', layer.id);
          }
        } else {
          // Restore style layers to defaults
          const defaultVis = styleDefaultVisibility[layer.id] || 'visible';
          if (map.getLayoutProperty(layer.id, 'visibility') !== defaultVis) {
            map.setLayoutProperty(layer.id, 'visibility', defaultVis);
            console.log('[HASHCHANGE] Restoring layer to default (no flags in hash):', layer.id, defaultVis);
          }
        }
      }
    });
    // Also restore all filters to defaults when no layer tokens exist
    try {
      const allMapLayers = map.getStyle().layers || [];
      allMapLayers.forEach(l => {
        const id = l.id;
        if (!layerSupportsFilter(id)) return;
        const def = (id in styleDefaultFilter) ? styleDefaultFilter[id] : null;
        try { map.setFilter(id, def); } catch(e) { /* ignore unsupported */ }
      });
    } catch(e) {}
  }

  // Update layer controls to reflect current state (after any removals)
  createLayerControls(map, allStyleLayers.filter(l => map.getLayer(l.id) && map.getLayoutProperty(l.id, 'visibility') === 'visible').map(l => l.id));

  // Load dynamic layers as needed (GeoJSON/CSV, Sentinel-2, or Wayback)
  if (dynamicGeojsonToLoad && dynamicGeojsonToLoad.length) {
    const layersOn = layers || [];
    dynamicGeojsonToLoad.forEach(entry => {
      let name = null, sourceHint = null, filter = null, isWayback = false, waybackDate = null;
      if (typeof entry === 'string') {
        name = entry;
      } else if (entry && typeof entry === 'object') {
        name = entry.name;
        sourceHint = entry.sourceHint;
        filter = entry.filter;
        isWayback = entry.isWayback || false;
        waybackDate = entry.waybackDate || null;
      }
      if (!name) return;
      
      // Check if layer already exists
      const layerExists = map.getLayer(name);
      // If this layer will be followed, load it hidden initially - the follow animation will show it
  const isFollowLayer = (name === followId);
  const visibility = isFollowLayer ? 'none' : (layersOn.includes(name) ? 'visible' : 'none');
      
      if (isWayback && waybackDate) {
        // ESRI Wayback layer
        if (!layerExists) {
          console.log('[HASHCHANGE] Loading new Wayback layer:', name);
          loadWaybackLayer(waybackDate, { visibility, sourceHint, filter });
        } else if (sourceHint) {
          console.log('[HASHCHANGE] Reloading Wayback layer:', name, 'with sourceHint:', sourceHint);
          loadWaybackLayer(waybackDate, { visibility, sourceHint, filter });
        }
      } else {
        // GeoJSON/CSV layer
        if (!layerExists) {
          console.log('[HASHCHANGE] Loading new layer:', name, 'with sourceHint:', sourceHint, 'filter:', filter, 'visibility:', visibility);
          loadAndAddOrReplaceGeoJSON(name + '.geojson', { visibility, sourceHint, filter });
        } else if (sourceHint || filter) {
          console.log('[HASHCHANGE] Reloading existing layer:', name, 'with sourceHint:', sourceHint, 'filter:', filter);
          loadAndAddOrReplaceGeoJSON(name + '.geojson', { visibility, sourceHint, filter });
        }
      }
    });
  }

  // 5. Fly to hash geolocation (with animation), then start follow only after fly completes
  const flyOpts = {
    center: [camera.center[0], camera.center[1]],
    zoom: camera.zoom,
    bearing: camera.bearing,
    pitch: camera.pitch,
    duration: 1200
  };

  // Always start follow if followId is present after camera update
  console.log('[FOLLOW DEBUG] Calling map.flyTo with:', flyOpts);
  map.flyTo(flyOpts);
  if (followId) {
    console.log('[FOLLOW DEBUG] followId detected, setting up follow for:', followId);
    // Wait for both flyTo and source readiness before starting follow
    let followReady = false;
    let flyDone = false;
    const tryStartFollow = () => {
      console.log('[FOLLOW DEBUG] tryStartFollow called. flyDone:', flyDone, 'followReady:', followReady);
      if (!flyDone || !followReady) return;
      const src = map.getSource(followId);
      if (!(src && src._data && src._data.features)) {
        console.log('[FOLLOW DEBUG] No source or features found for followId:', followId);
        return;
      }
      // Extract coords
      let coords = [];
      let geomTypes = [];
      src._data.features.forEach(f => {
        if (!f.geometry) return;
        geomTypes.push(f.geometry.type);
        if (f.geometry.type === 'LineString') coords = coords.concat(f.geometry.coordinates);
        if (f.geometry.type === 'Polygon') coords = coords.concat(f.geometry.coordinates[0]);
        if (f.geometry.type === 'MultiLineString') coords = coords.concat(...f.geometry.coordinates);
        if (f.geometry.type === 'MultiPolygon') coords = coords.concat(...f.geometry.coordinates.map(ring => ring[0]));
      });
      console.log('[FOLLOW DEBUG] Layer:', followId, 'Geom types:', geomTypes, 'Coords count:', coords.length);
      if (coords.length > 1) {
        console.log('[FOLLOW DEBUG] Starting new follow animation for:', followId, 'with showTicker:', showTicker, 'offset:', followOffset);
        window._isFollowStarted = true;
  followPathWithFreeCamera(map, coords, () => {
          // On completion: freeze current camera into the hash and remove :follow to avoid jumping back
          const c = map.getCenter();
          const z = map.getZoom().toFixed(2);
          const b = map.getBearing().toFixed(1);
          const p = map.getPitch().toFixed(1);
          const cameraStr = `${c.lat.toFixed(5)},${c.lng.toFixed(5)},${z},${b},${p}`;
          let hash = window.location.hash.replace('#', '');
          const parts = hash.split('/');
          let layersStr = parts[1] || '';
          if (layersStr) {
            // Remove :follow or :follow+offset, allowing optional (source) part
            layersStr = layersStr.replace(new RegExp(`([+~]${followId})(?:\\([^)]+\\))?(?::follow(?:\\+\\d+)?)`), '$1');
          }
          const newHash = `#${cameraStr}` + (layersStr ? `/${layersStr}` : '');
          window._suppressNextFollowCancel = true;
          window.location.replace(newHash);
          window._isFollowStarted = false;
  }, followId, followOffset || 0, showTicker, followHidden);
      } else {
        console.log('[FOLLOW DEBUG] Not enough coordinates to follow for layer:', followId);
      }
    };
    // Listen for flyend
    map.once('moveend', () => {
      console.log('[FOLLOW DEBUG] map.moveend fired, setting flyDone = true');
      flyDone = true;
      tryStartFollow();
    });
    // Listen for source readiness
    const checkSource = () => {
      const src = map.getSource(followId);
      if (src && src._data && src._data.features) {
        console.log('[FOLLOW DEBUG] Source', followId, 'is ready with', src._data.features.length, 'features');
        followReady = true;
        tryStartFollow();
        return true;
      }
      console.log('[FOLLOW DEBUG] Source', followId, 'not ready yet. src:', !!src, 'src._data:', !!(src && src._data), 'features:', !!(src && src._data && src._data.features));
      return false;
    };
    if (!checkSource()) {
      console.log('[FOLLOW DEBUG] Source not ready, listening for sourcedata events...');
      const onSourceData = (e) => {
        console.log('[FOLLOW DEBUG] sourcedata event for:', e.sourceId);
        if (e.sourceId === followId && checkSource()) {
          console.log('[FOLLOW DEBUG] Removing sourcedata listener for:', followId);
          map.off('sourcedata', onSourceData);
        }
      };
      map.on('sourcedata', onSourceData);
    } else {
      console.log('[FOLLOW DEBUG] Source already ready, calling tryStartFollow immediately');
      followReady = true;
      tryStartFollow();
    }
  } else {
    console.log('[FOLLOW DEBUG] No followId in hash, skipping follow setup');
  }
});
</script>
</body>
</html>