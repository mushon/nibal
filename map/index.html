<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Dynamic Mapbox Map with Hash Control</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, user-scalable=no">
  <link rel="icon" type="image/png" sizes="32x32" href="img/favicon-32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="img/favicon-16.png">
  <link rel="apple-touch-icon" sizes="180x180" href="img/favicon-180.png">
  <style>
    html, body, #map {
      height: 100%;
      margin: 0;
      padding: 0;
      width: 100%;
      background: #333; 
    }

    #map .mapboxgl-ctrl a.mapboxgl-ctrl-logo{
      margin-left: 40px;
    }
    
    /* Mobile portrait: scale map canvas to compensate for 70dvh height constraint */
    @media (max-width: 1000px) and (orientation: portrait) {
      #map {
        transform: scale(1.15);
        transform-origin: top left;
      }
    }
    
    #layer-controls {
      position: fixed;
      top: 0;
      left: 0;
      width: 280px;
      height: 100vh;
      background: rgba(0,0,0,0.25);
      backdrop-filter: blur(10px);
      z-index: 1000;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      box-shadow: 2px 0 8px rgba(0,0,0,0.4);
      display: flex;
      flex-direction: column;
      transition: transform 0.3s ease;
      color: #fff;
    }
    #layer-controls.hidden {
      transform: translateX(-100%);
      pointer-events: none;
      visibility: hidden;
    }
    #layer-controls-header {
      padding: 15px;
      border-bottom: 1px solid rgba(255,255,255,0.15);
      flex-shrink: 0;
    }
    #layer-controls-header .title-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      margin-bottom: 5px;
    }
    #layer-controls-header h3 {
      margin: 0;
      font-size: 16px;
      font-weight: 600;
      color: #fff;
      flex: 1;
    }
    #reset-all-btn {
      background: transparent;
      border: none;
      color: rgba(255,255,255,0.7);
      cursor: pointer;
      padding: 4px 8px;
      font-size: 16px;
      line-height: 1;
      border-radius: 3px;
      transition: all 0.15s;
      flex-shrink: 0;
    }
    #add-layer-toggle-btn {
      background: transparent;
      border: none;
      color: rgba(255,255,255,0.7);
      cursor: pointer;
      padding: 4px 8px;
      font-size: 18px;
      line-height: 1;
      border-radius: 3px;
      transition: all 0.15s;
      flex-shrink: 0;
    }
    #add-layer-toggle-btn:hover {
      background: rgba(255,255,255,0.15);
      color: #fff;
    }
    #reset-all-btn:hover {
      background: rgba(255,255,255,0.15);
      color: #fff;
    }
    #layer-controls-header .hint {
      font-size: 11px;
      color: rgba(255,255,255,0.6);
      margin: 0;
    }
    #layer-list {
      flex: 1;
      overflow-y: auto;
      padding: 10px 15px;
      font-size: 13px;
    }
    .layer-list-item {
      display: flex;
      align-items: center;
      gap: 4px;
      margin: 4px 0;
    }
    #layer-list label {
      color: #fff;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 4px;
      border-radius: 3px;
      transition: background 0.15s;
      font-size: 13px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      flex: 1;
      min-width: 0;
    }
    #layer-list label:hover {
      background: rgba(255,255,255,0.1);
    }
    .layer-list-item button {
      background: transparent;
      border: none;
      color: rgba(255,255,255,0.7);
      cursor: pointer;
      padding: 4px 6px;
      font-size: 14px;
      line-height: 1;
      border-radius: 3px;
      transition: all 0.15s;
      flex-shrink: 0;
    }
    .layer-list-item button:hover {
      background: rgba(255,255,255,0.15);
      color: #fff;
    }
    .layer-list-item button[data-delete] {
      color: #ff4444;
      font-weight: bold;
    }
    .layer-list-item button[data-delete]:hover {
      color: #ff6666;
      background: rgba(255,68,68,0.2);
    }
    .layer-list-item button[data-follow] {
      font-size: 16px;
      padding: 2px 6px;
    }
    .layer-list-item button[data-follow].active {
      color: #4caf50;
      background: rgba(76,175,80,0.2);
    }
    .layer-list-item button[data-follow]:hover {
      color: #4caf50;
    }
    .follow-offset-input {
      display: none;
      width: 50px;
      padding: 2px 4px;
      margin-left: 2px;
      background: rgba(0,0,0,0.3);
      border: 1px solid rgba(76,175,80,0.4);
      border-radius: 3px;
      color: #4caf50;
      font-size: 11px;
      font-family: monospace;
      text-align: center;
      outline: none;
    }
    .follow-offset-input.active {
      display: inline-block;
    }
    .follow-offset-input:focus {
      border-color: #4caf50;
      background: rgba(76,175,80,0.1);
    }
    .filter-input {
      display: none;
      width: 120px;
      padding: 2px 4px;
      margin-left: 2px;
      background: rgba(0,0,0,0.3);
      border: 1px solid rgba(255,165,0,0.4);
      border-radius: 3px;
      color: #ffa500;
      font-size: 11px;
      font-family: monospace;
      outline: none;
    }
    .filter-input.active {
      display: inline-block;
    }
    .filter-input:focus {
      border-color: #ffa500;
      background: rgba(255,165,0,0.1);
    }
    /* Common properties dropdown for filters */
    .filter-prop-select {
      display: none;
      max-width: 140px;
      padding: 2px 4px;
      margin-left: 2px;
      background: rgba(0,0,0,0.3);
      border: 1px solid rgba(255,165,0,0.4);
      border-radius: 3px;
      color: #ffa500;
      font-size: 11px;
      font-family: inherit;
      outline: none;
      cursor: pointer;
    }
    .filter-prop-select.active {
      display: inline-block;
    }
    .layer-list-item button[data-filter] {
      font-size: 14px;
      padding: 2px 6px;
    }
    .layer-list-item button[data-filter].active {
      color: #ffa500;
      background: rgba(255,165,0,0.2);
    }
    .layer-list-item button[data-filter]:hover {
      color: #ffa500;
    }
    #layer-controls-footer {
      padding: 10px 15px;
      border-top: 1px solid rgba(255,255,255,0.15);
      flex-shrink: 0;
    }
    #copy-link-btn {
      width: 100%;
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 4px;
      padding: 10px 12px;
      font-family: inherit;
      font-size: 13px;
      cursor: pointer;
      transition: all 0.2s;
      text-align: center;
      color: #fff;
    }
    #copy-link-btn:hover {
      background: rgba(255,255,255,0.2);
      border-color: rgba(255,255,255,0.4);
    }
    #copy-link-btn:active {
      background: rgba(255,255,255,0.15);
    }
    #copy-link-btn.copied {
      background: #4caf50;
      color: white;
      border-color: #4caf50;
    }
    #add-layer-form {
      display: none;
      margin-top: 8px;
      padding: 8px 10px 4px;
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.15);
      border-radius: 6px;
      backdrop-filter: blur(6px);
    }
    #add-layer-form.active { display: block; }
    #add-layer-form label { display:block; font-size:11px; margin:0 0 4px; color:rgba(255,255,255,0.6); }
      .layer-tab {
        flex: 1;
        background: rgba(255,255,255,0.08);
        border: 1px solid rgba(255,255,255,0.2);
        border-radius: 4px;
        padding: 6px 8px;
        font-size: 12px;
        cursor: pointer;
        color: rgba(255,255,255,0.6);
        font-family: inherit;
        transition: all 0.15s;
      }
      .layer-tab:hover {
        background: rgba(255,255,255,0.15);
        color: rgba(255,255,255,0.8);
      }
      .layer-tab.active {
        background: rgba(255,255,255,0.22);
        border-color: rgba(255,255,255,0.4);
        color: #fff;
        font-weight: 500;
      }
    #layer-type-select {
      width: 100%;
      box-sizing: border-box;
      padding: 6px 8px;
      border-radius: 4px;
      border: 1px solid rgba(255,255,255,0.25);
      background: rgba(0,0,0,0.3);
      color: #fff;
      font-size: 12px;
      font-family: inherit;
      outline: none;
      cursor: pointer;
      margin-bottom: 8px;
    }
    #layer-type-select option { background: #222; color: #fff; }
    .layer-input-group { margin-bottom: 8px; }
    #new-layer-input, #satellite-date-input, #reference-layer-select {
      width: 100%;
      box-sizing: border-box;
      padding: 6px 8px;
      border-radius: 4px;
      border: 1px solid rgba(255,255,255,0.25);
      background: rgba(0,0,0,0.3);
      color: #fff;
      font-size: 12px;
      font-family: inherit;
      outline: none;
    }
    #new-layer-input:focus, #satellite-date-input:focus, #reference-layer-select:focus { border-color: rgba(255,255,255,0.5); }
    #satellite-date-input {
      color-scheme: dark;
      cursor: pointer;
    }
    #satellite-date-input::-webkit-calendar-picker-indicator {
      filter: invert(1);
    }
    #reference-layer-select { margin-top: 8px; cursor: pointer; }
    #reference-layer-select option { background: #222; color: #fff; }
    #add-layer-confirm-btn {
      margin-top: 6px;
      width: 100%;
      background: rgba(255,255,255,0.12);
      border: 1px solid rgba(255,255,255,0.25);
      border-radius: 4px;
      padding: 6px 8px;
      font-size: 12px;
      cursor: pointer;
      color:#fff;
      font-family: inherit;
      transition: background 0.15s, border-color 0.15s;
    }
    #add-layer-confirm-btn:hover { background: rgba(255,255,255,0.22); border-color: rgba(255,255,255,0.4); }
    #add-layer-error { margin:4px 0 0; font-size:11px; color:#ff6666; min-height:14px; }
    #distance-ticker {
      position: absolute;
      width: 80px;
      height: 80px;
      border-radius: 50%;
      display: none;
      align-items: center;
      justify-content: center;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      font-size: 14px;
      font-weight: 600;
      color: #fff;
      background: rgba(0,0,0,0.3);
      border: #fffa solid 1px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
      pointer-events: none;
      z-index: 10;
      transform: translate(-50%, -125%);
    }
    #distance-ticker.active {
      display: flex;
    }
    /* Make the date input calendar icon white (WebKit browsers) */
    #satellite-date-input::-webkit-calendar-picker-indicator {
      filter: invert(1);
    }
    #satellite-date-input {
      color-scheme: dark;
    }
    /* Container becomes draggable (horizontally) via toolbar */
    /* Map UI controls (shown only when /mapui segment present in hash) */
    #map-ui-controls {
      position: fixed;
      top: 12px;
      right: 12px;
      z-index: 1100;
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding: 6px;
      background: rgba(0,0,0,0.35);
      backdrop-filter: blur(8px);
      border: 1px solid rgba(255,255,255,0.25);
      border-radius: 10px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.4);
      pointer-events: auto;
      font-family: -apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;
    }
    #map-ui-controls button {
      width: 38px;
      height: 38px;
      background: rgba(255,255,255,0.15);
      border: none;
      color: #fff;
      font-size: 18px;
      font-weight: 600;
      border-radius: 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.15s, transform 0.15s;
    }
    #map-ui-controls button:hover {
      background: rgba(255,255,255,0.3);
    }
    #map-ui-controls button:active {
      transform: scale(0.92);
    }
    #map-ui-controls button.fullscreen-exit {
      background: rgba(255,100,100,0.25);
    }
    #map-ui-controls button.fullscreen-exit:hover {
      background: rgba(255,100,100,0.4);
    }
  </style>
  <script src="https://api.mapbox.com/mapbox-gl-js/v3.15.0/mapbox-gl.js"></script>
  <link href="https://api.mapbox.com/mapbox-gl-js/v3.15.0/mapbox-gl.css" rel="stylesheet" />
  <!-- Mapbox RTL Text Plugin is loaded on demand via setRTLTextPlugin; do not include as a <script> tag. -->
  <!-- Removed any Python-in-the-browser scripts (e.g., Pyodide, Brython) to prevent py.parse errors -->
  <!-- Add Papa Parse for robust CSV parsing -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
</head>
<body>
<div id="map"></div>
<div id="layer-controls" class="hidden">
  <div id="layer-controls-header">
    <div class="title-row">
      <h3>Map Layers</h3>
      <button id="add-layer-toggle-btn" title="Add new layer">ï¼‹</button>
      <button id="reset-all-btn" title="Reset all layers to style defaults">â†»</button>
    </div>
    <p class="hint">Press 'E' to toggle edit mode</p>
    <div id="add-layer-form">
        <!-- Tab buttons -->
        <div id="layer-type-tabs" style="display: flex; gap: 4px; margin-bottom: 12px;">
          <button id="tab-geodata" class="layer-tab active" data-tab="geodata">Geodata</button>
          <button id="tab-satellite" class="layer-tab" data-tab="satellite">Satellite</button>
        </div>
      
      <!-- GeoJSON/CSV input (default visible) -->
      <div id="geojson-input-group" class="layer-input-group">
        <label for="new-layer-input">Layer filename</label>
        <input id="new-layer-input" list="local-layer-files" placeholder="Type to search local files" autocomplete="off" />
        <datalist id="local-layer-files"></datalist>
          <label for="reference-layer-select" style="margin-top: 8px;">Position after layer (optional)</label>
          <select id="reference-layer-select" title="Select a reference layer to insert after (optional)">
            <option value="">-- No reference (add at top) --</option>
          </select>
      </div>
      
        <!-- Satellite date picker (hidden by default) -->
      <div id="satellite-input-group" class="layer-input-group" style="display:none;">
        <label for="satellite-date-input">Satellite image date</label>
        <input id="satellite-date-input" type="date" placeholder="YYYY-MM-DD" />
  <p class="hint" style="font-size: 11px; margin: 4px 0 0; color: rgba(255,255,255,0.8);">choose the date from the list on the <a id="wayback-open-new" href="https://livingatlas.arcgis.com/wayback/" target="_blank" rel="noopener noreferrer" style="color:#9fd1ff;text-decoration:underline;">Wayback site</a> and enter it in the date picker</p>
      </div>
      
  <button id="add-layer-confirm-btn" title="Add the selected layer">Add Layer</button>
      <div id="add-layer-error"></div>
    </div>
  </div>
  <div id="layer-list"></div>
  <div id="layer-controls-footer">
  <button id="copy-link-btn" title="Copy a shareable link to this exact map view and layer configuration">ðŸ“‹ Copy Link</button>
  </div>
</div>
<div id="distance-ticker"></div>
<script>
// Panel is hidden by default; show it when NOT in an iframe
document.addEventListener('DOMContentLoaded', function() {
  var controls = document.getElementById('layer-controls');
  if (!controls) return;
  // Detect embed-ui / mapui flag in hash (case-insensitive)
  const hashLower = (location.hash || '').toLowerCase();
  const hasShowUIFlag = hashLower.includes('/embed-ui') || hashLower.includes('/mapui');
  // If embed-ui flag present we always keep layer sidebar hidden (only want zoom panel)
  if (!hasShowUIFlag && window.self === window.top) {
    // Standalone page without embed-ui flag: show layer sidebar
    controls.classList.remove('hidden');
  } // else keep hidden
});

// Keyboard shortcut to toggle UI (E key)
document.addEventListener('keydown', function(e) {
  // Ignore if typing in an input field
  if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
  
  // Use code instead of key to work across keyboard layouts
  if (e.code === 'KeyE') {
    e.preventDefault();
    var controls = document.getElementById('layer-controls');
    if (controls) {
      const wasHidden = controls.classList.contains('hidden');
      controls.classList.toggle('hidden');
      
      // Tell parent about edit mode change
      if (window.parent && window.parent !== window) {
        window.parent.postMessage({ 
          type: 'bg-edit-mode', 
          enabled: wasHidden 
        }, '*');
      }
    }
  } else if (e.code === 'KeyF') {
    // Foreground-only toggle - relay to parent
    e.preventDefault();
    if (window.parent && window.parent !== window) {
      window.parent.postMessage({ type: 'toggle-foreground-edit' }, '*');
    }
  } else if (e.code === 'KeyB') {
    // Background-only toggle - relay to parent
    e.preventDefault();
    if (window.parent && window.parent !== window) {
      window.parent.postMessage({ type: 'toggle-background-edit' }, '*');
    }
  }
});

// Local layer filenames (autogenerated from /map directory at build time)
// Only .geojson basenames are listed. Remote URLs are not yet persisted via hash.
const availableLocalLayerFiles = [
  'pois','IDF_zone_210824_240824','IDF_zone_210824_240824_NEW','Areas_Designated_for_Evacuation_by_the_IDF','IDF_Zones','IDF_zone_010724-210724','IDF_zone_010724-210724_NEW','IDF_zone_041223-281223','IDF_zone_041223-281223_NEW','IDF_zone_060524-110524','IDF_zone_061024','IDF_zone_061024_NEW','IDF_zone_090925','IDF_zone_090925_NEW','IDF_zone_110824_150824','IDF_zone_110824_150824_NEW','IDF_zone_160824_200824','IDF_zone_160824_200824_NEW','IDF_zone_191025','IDF_zone_210724-100824','IDF_zone_210724-100824_NEW','IDF_zone_250824_280824','IDF_zone_250824_280824_NEW','IDF_zone_290824','IDF_zone_290824_NEW','IDF_zone_300824','IDF_zone_300824_NEW','IDF_zone_ALL_UNTIL_101025','al-mawasi-jabalia','al-zawaida-al-mawasi','evac-orders-dec2','evac-orders-dec4','evac-orders-dec5','gaza-deir-al-balah','gaza-khan-younis','gaza-nuseirat','gaza','jabalia-al-mawasi','jabalia-deir-al-balah','jabalia-gaza','jabalia-rafah','nuseirat-rafah','oct7-hamas','oct7_23_hamas','rafah-bureij','safe-area','wrong','wrong2','wrong3','wrong4','wrong5','wrong6'
];

function populateLocalLayerDatalist() {
  const dl = document.getElementById('local-layer-files');
  if (!dl) return;
  dl.innerHTML = '';
  const seen = new Set();
  availableLocalLayerFiles.forEach(name => {
    if (!seen.has(name)) {
      seen.add(name);
      const opt = document.createElement('option');
      opt.value = name;
      dl.appendChild(opt);
    }
  });
}
document.addEventListener('DOMContentLoaded', populateLocalLayerDatalist);

// Populate reference layer dropdown with current map layers
function populateReferenceLayerSelect() {
  const select = document.getElementById('reference-layer-select');
  if (!select || !window.map) return;
  
  // Keep the default "no reference" option
  const defaultOpt = select.querySelector('option[value=""]');
  select.innerHTML = '';
  if (defaultOpt) { defaultOpt.title = 'Add at the very top (no reference)'; select.appendChild(defaultOpt); }
  else {
    const opt = document.createElement('option');
    opt.value = '';
    opt.textContent = '-- No reference (add at top) --';
    opt.title = 'Add at the very top (no reference)';
    select.appendChild(opt);
  }
  
  // Add all current layers (reversed order - topmost first)
  if (window.allStyleLayers && window.allStyleLayers.length > 0) {
    // Reverse the array to show topmost layers first
    const reversedLayers = [...window.allStyleLayers].reverse();
    reversedLayers.forEach(layer => {
      if (window.map.getLayer(layer.id)) {
        const opt = document.createElement('option');
        opt.value = layer.id;
        opt.textContent = layer.name || layer.id;
        opt.title = `Insert new layer immediately after '${layer.name || layer.id}'`;
        select.appendChild(opt);
      }
    });
  }
}

// Refresh reference layer dropdown when form is opened
document.addEventListener('DOMContentLoaded', function() {
  const toggleBtn = document.getElementById('add-layer-toggle-btn');
  const form = document.getElementById('add-layer-form');
  if (toggleBtn && form) {
    toggleBtn.addEventListener('click', () => {
      const wasHidden = !form.classList.contains('active');
      form.classList.toggle('active');
      if (wasHidden) {
        // Form just opened - refresh the reference layer list
        populateReferenceLayerSelect();
      }
    });
  }
});

// Add layer logic (supports GeoJSON/CSV and Satellite imagery)
document.addEventListener('DOMContentLoaded', function() {
  const tabGeodataBtn = document.getElementById('tab-geodata');
  const tabSatelliteBtn = document.getElementById('tab-satellite');
  const geojsonGroup = document.getElementById('geojson-input-group');
  const satelliteGroup = document.getElementById('satellite-input-group');
  const geojsonInput = document.getElementById('new-layer-input');
  const satelliteDateInput = document.getElementById('satellite-date-input');
  const satelliteLatestDateEl = document.getElementById('satellite-latest-date');
  const refSelect = document.getElementById('reference-layer-select');
  const confirmBtn = document.getElementById('add-layer-confirm-btn');
  const errorEl = document.getElementById('add-layer-error');
  
  if (!confirmBtn) {
        return;
  }
  
  let currentTab = 'geodata';

  // Tooltips for tabs and inputs
  if (tabGeodataBtn) tabGeodataBtn.title = 'Add a GeoJSON/CSV data layer';
  if (tabSatelliteBtn) tabSatelliteBtn.title = 'Add a satellite imagery layer (Wayback)';
  if (geojsonInput) {
    geojsonInput.title = 'Type or choose a local filename or URL';
    geojsonInput.addEventListener('input', () => { geojsonInput.title = geojsonInput.value || 'Type or choose a local filename or URL'; });
  }
  if (satelliteDateInput) {
    satelliteDateInput.title = 'Pick a date (YYYY-MM-DD)';
    satelliteDateInput.addEventListener('change', () => { satelliteDateInput.title = satelliteDateInput.value || 'Pick a date (YYYY-MM-DD)'; });
  }
  if (refSelect) {
    const updateRefTitle = () => {
      const selOpt = refSelect.options[refSelect.selectedIndex];
      refSelect.title = selOpt ? (selOpt.textContent || refSelect.title) : refSelect.title;
    };
    updateRefTitle();
    if (!refSelect.dataset.titleHandler) {
      refSelect.addEventListener('change', updateRefTitle);
      refSelect.dataset.titleHandler = '1';
    }
  }
  
  
  // Handle tab switching
  function switchTab(tabName) {
    currentTab = tabName;
    
    // Update tab button states
    if (tabGeodataBtn && tabSatelliteBtn) {
      tabGeodataBtn.classList.toggle('active', tabName === 'geodata');
      tabSatelliteBtn.classList.toggle('active', tabName === 'satellite');
    }
    
    // Show/hide input groups
    if (geojsonGroup) geojsonGroup.style.display = tabName === 'geodata' ? 'block' : 'none';
    if (satelliteGroup) satelliteGroup.style.display = tabName === 'satellite' ? 'block' : 'none';
    
    // Update Wayback link with current map view
    if (tabName === 'satellite') {
      const openLink = document.getElementById('wayback-open-new');
      if (openLink && window.map) {
        const center = window.map.getCenter();
        const zoom = Math.round(window.map.getZoom());
        const url = `https://livingatlas.arcgis.com/wayback/#mapCenter=${center.lng.toFixed(5)}%2C${center.lat.toFixed(5)}%2C${zoom}`;
        openLink.href = url;
      }
    }
  }
  
  // Add click handlers to tabs
  if (tabGeodataBtn) {
    tabGeodataBtn.addEventListener('click', (e) => {
      e.preventDefault();
      switchTab('geodata');
    });
  }
  if (tabSatelliteBtn) {
    tabSatelliteBtn.addEventListener('click', (e) => {
      e.preventDefault();
      switchTab('satellite');
    });
  }
  
  function setError(msg) { if (errorEl) errorEl.textContent = msg || ''; }
  
  confirmBtn.addEventListener('click', function(e) {
    e.preventDefault();
    setError('');
    
  const layerType = currentTab === 'satellite' ? 'satellite' : 'geojson';
    const refLayer = refSelect ? refSelect.value.trim() : '';
    let baseLayerId = '';
    let layerId = '';
    let newToken = '';
    
    // Build layer ID based on type
    if (layerType === 'geojson') {
      const raw = (geojsonInput.value || '').trim();
      if (!raw) { setError('Enter a local filename or URL.'); return; }
      // Accept any input with or without extension - datalist provides suggestions only
      // Files can be specified as 'pois', 'pois.csv', or 'safe-area.geojson'
      if (!availableLocalLayerFiles.includes(raw) && !availableLocalLayerFiles.includes(raw.replace(/\.(geojson|json|csv)$/i, ''))) { 
        // Custom file/URL not in predefined list - allow it
      }
      baseLayerId = raw;
      
    } else if (layerType === 'satellite') {
      const dateValue = ((satelliteDateInput ? satelliteDateInput.value : '') || '').trim();
      if (!dateValue) { setError('Select a satellite image date.'); return; }
      
      // Convert YYYY-MM-DD to YYYYMMDD
      const dateStr = dateValue.replace(/-/g, '');
      baseLayerId = `wayback:${dateStr}`;
    }
    
    // Auto-increment layer ID if base layer already exists
    layerId = baseLayerId;
    let counter = 2;
    while (window.map && window.map.getLayer && window.map.getLayer(layerId)) {
      layerId = `${baseLayerId}#${counter}`;
      counter++;
    }
    
    // Build token with potentially incremented layerId
    newToken = `+${layerId}`;
    if (refLayer) {
      if (layerType === 'satellite' && refLayer === 'satellite') {
        // Omit (satellite) since it's the default sourceHint
        newToken = `+${layerId}`;
      } else {
        newToken = `+${layerId}(${refLayer})`;
      }
    }
    
    // Update hash with new layer
  const existing = window.location.hash.replace('#','');
  const parts = existing.split('/');
  // Keep existing camera string; if none, fall back to current map view
  let cameraStr = parts[0] || '';
  if (!cameraStr && window.map) {
    const c = window.map.getCenter();
    cameraStr = `${c.lat.toFixed(5)},${c.lng.toFixed(5)},${window.map.getZoom().toFixed(2)},${window.map.getBearing().toFixed(1)},${window.map.getPitch().toFixed(1)}`;
  }
    let layersStr = parts[1] || '';
  const tokens = layersStr ? splitLayerTokens(layersStr) : [];
    
  // Check if this exact layer ID already exists in tokens and replace, otherwise prepend
  // Escape special regex chars but preserve # for counter matching
  const escapedLayerId = layerId.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  // New grammar: optional single parentheses group (no square brackets)
  const regex = new RegExp(`^[+~]${escapedLayerId}(?:\\([^)]*\\))?(?::follow(?:\\+\\d*)?)?$`);
    const idx = tokens.findIndex(t => regex.test(t));
    if (idx >= 0) {
      // Layer with this exact ID exists, replace it
      tokens[idx] = newToken;
    } else {
      // New layer - append to end so it appears below existing layers in hash order
      tokens.push(newToken);
    }
    layersStr = tokens.join(',');
  // Preserve any extra trailing segments (e.g., /mapui)
  const existingParts = existing.split('/');
  const trailing = existingParts.slice(2);
  const newHash = `#${cameraStr}` + (layersStr ? `/${layersStr}` : '') + (trailing.length ? `/${trailing.join('/')}` : '');
    // Apply new hash with selected layer and restore previous camera view
    window.location.hash = newHash;
    
    // Clear inputs
    if (geojsonInput) geojsonInput.value = '';
    if (satelliteDateInput) satelliteDateInput.value = '';
    if (refSelect) refSelect.value = '';
    
    // Hide form and Wayback iframe
    const form = document.getElementById('add-layer-form');
    if (form) form.classList.remove('active');
  
  });
});


// Copy link button functionality
document.addEventListener('DOMContentLoaded', function() {
  var copyBtn = document.getElementById('copy-link-btn');
  if (copyBtn) {
    copyBtn.addEventListener('click', function() {
      // Get current URL and extract from 'svg/' or 'map/' onwards (including hash)
      var fullUrl = window.location.href;
      var linkToCopy = null;
      
      try {
        var u = new URL(fullUrl);
        var path = u.pathname || '';
        var hash = u.hash || '';
        
        // Helper to extract relative URL starting from keyword
        function pickRelFromPath(p, keyword) {
          var withSlash = '/' + keyword + '/';
          var idx = p.lastIndexOf(withSlash);
          if (idx >= 0) return p.substring(idx + 1) + (hash || ''); // drop leading '/'
          var endMarker = '/' + keyword;
          if (p.endsWith(endMarker)) return keyword + (hash || '');
          return null;
        }
        
        // Try both svg/ and map/
        linkToCopy = pickRelFromPath(path, 'svg') || pickRelFromPath(path, 'map');
      } catch(e) {
              }
      
      // Fallback to simple extraction if URL parsing failed
      if (!linkToCopy) {
        var svgIndex = fullUrl.indexOf('svg/');
        var mapIndex = fullUrl.indexOf('map/');
        if (svgIndex !== -1 && (mapIndex === -1 || svgIndex < mapIndex)) {
          linkToCopy = fullUrl.substring(svgIndex);
        } else if (mapIndex !== -1) {
          linkToCopy = fullUrl.substring(mapIndex);
        } else {
          linkToCopy = fullUrl;
        }
      }
      
      // Copy to clipboard
      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(linkToCopy).then(function() {
          // Visual feedback
          var originalText = copyBtn.textContent;
          copyBtn.textContent = 'âœ“ Copied!';
          copyBtn.classList.add('copied');
          
          setTimeout(function() {
            copyBtn.textContent = originalText;
            copyBtn.classList.remove('copied');
          }, 2000);
        }).catch(function(err) {
                    alert('Failed to copy link. Please copy manually: ' + linkToCopy);
        });
      } else {
        // Fallback for non-HTTPS or older browsers
        alert('Clipboard API not available. Please copy manually: ' + linkToCopy);
      }
    });
  }
});

// Sample Mapbox access token (replace with your own for production)
mapboxgl.accessToken = 'pk.eyJ1IjoiYnRzZWxlbW9yZyIsImEiOiJjbWhuNnF6djQwNTVlMnNzZjAxd2dqeWFyIn0.jw164iQiqRTNP1QMu-cbTg';

// Enable RTL text plugin for proper display of Arabic, Hebrew, and other RTL languages
mapboxgl.setRTLTextPlugin(
  'https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-rtl-text/v0.2.3/mapbox-gl-rtl-text.js',
  null,
  true // lazy load - only loads when needed
);

// Sample style
const style = 'mapbox://styles/btselemorg/cmhncne5l004p01qu9tpp7ih8';

// Layers to toggle (layer ids must exist in the style)
// Will be populated with all layers from the style after map load
let allStyleLayers = [];
// Expose globally for UI access
window.allStyleLayers = allStyleLayers;

// Will hold the style default visibility for each layer
const styleDefaultVisibility = {};
// Will hold the style default filter for each layer (null means no filter)
const styleDefaultFilter = {};

// Layer types that support filters
const FILTERABLE_LAYER_TYPES = ['fill','line','circle','symbol','heatmap','fill-extrusion'];

function layerSupportsFilter(layerId) {
  try {
    const layer = map && map.getLayer ? map.getLayer(layerId) : null;
    if (!layer) return false;
    return FILTERABLE_LAYER_TYPES.includes(layer.type || '');
  } catch(e) { return false; }
}

// Convert a single filter expression string like "name=jabalia|beit_hanoun" or "type!=boundary" into a Mapbox GL filter array
function parseFilterExprToMapbox(filterExpr) {
  if (!filterExpr) return null;
  const match = filterExpr.match(/^([^=!]+)(=|!=)(.+)$/);
  if (!match) return null;
  const [, property, operator, rawValue] = match;
  const decoded = decodeURIComponent(rawValue);
  const values = decoded.split('|').map(v => (isNaN(v) ? v : Number(v)));
  if (operator === '=') {
    if (values.length === 1) return ['==', ['get', property], values[0]];
    return ['any', ...values.map(val => ['==', ['get', property], val])];
  } else if (operator === '!=') {
    if (values.length === 1) return ['!=', ['get', property], values[0]];
    return ['all', ...values.map(val => ['!=', ['get', property], val])];
  }
  return null;
}

// New syntax helpers for parentheses content
// Parse inside of parentheses: examples:
//   "roads" -> { sourceHint: 'roads', filters: [] }
//   "name=foo" -> { sourceHint: null, filters: ['name=foo'] }
//   "roads,name=foo,type!=bar|baz" -> { sourceHint: 'roads', filters: ['name=foo','type!=bar|baz'] }
//   "name=foo.type=bar" (legacy dot-separated) -> treat dots as separators too
function parseParenArgs(argStr) {
  if (!argStr || typeof argStr !== 'string') return { sourceHint: null, filters: [] };
  // Split by commas first, then split each part by '.' to support legacy multi-expr like a=b.c=d
  const rawParts = argStr.split(',').flatMap(p => p.split('.'))
    .map(s => s.trim()).filter(s => s.length > 0);
  let sourceHint = null;
  const filters = [];
  rawParts.forEach((part) => {
    if (part.includes('=')) filters.push(part);
    else if (!sourceHint) sourceHint = part;
    // Extra non '=' parts beyond the first are ignored
  });
  return { sourceHint, filters };
}

// Build parentheses string from parts; returns '' if nothing to include
function buildParenArgs(sourceHint, filterExprs) {
  const parts = [];
  if (sourceHint) parts.push(sourceHint);
  (filterExprs || []).forEach(expr => { if (expr && expr.trim()) parts.push(expr.trim()); });
  return parts.length ? `(${parts.join(',')})` : '';
}

// Combine multiple simple expressions into a single Mapbox filter array using 'all'
function combineFilterExprsToMapbox(filterExprs) {
  const frags = (filterExprs || [])
    .map(expr => parseFilterExprToMapbox(expr))
    .filter(Boolean);
  if (!frags.length) return null;
  if (frags.length === 1) return frags[0];
  return ['all', ...frags];
}

// Split layer tokens by comma, but respect parentheses (don't split on commas inside parens)
// Also sanitize and decode percent-encoded tokens, and handle edge cases
function splitLayerTokens(str) {
  const tokens = [];
  let current = '';
  let parenDepth = 0;
  for (let i = 0; i < str.length; i++) {
    const ch = str[i];
    if (ch === '(') {
      parenDepth++;
      current += ch;
    } else if (ch === ')') {
      parenDepth--;
      current += ch;
    } else if (ch === ',' && parenDepth === 0) {
      if (current.trim()) tokens.push(current.trim());
      current = '';
    } else {
      current += ch;
    }
  }
  if (current.trim()) tokens.push(current.trim());
  // Sanitize and decode tokens
  return tokens.map(token => {
    let decoded = token;
    try {
      decoded = decodeURIComponent(token);
    } catch (e) {
          }
    // Remove dangerous characters but keep square brackets for filter syntax [name=value]
    decoded = decoded.replace(/[<>"'`]/g, '');
    // Trim whitespace
    decoded = decoded.trim();
    return decoded;
  });
}

// Detect a desktop-ish environment (coarse heuristic: no touch OR fine pointer)
function isDesktopEnvironment() {
  try {
    return (navigator.maxTouchPoints === 0) || window.matchMedia('(pointer: fine)').matches;
  } catch(e) { return true; }
}

// Inject map UI controls (zoom, rotate reset â€“ desktop only; fullscreen â€“ always)
function ensureMapUIControls() {
  if (document.getElementById('map-ui-controls')) return; // already present
  const container = document.createElement('div');
  container.id = 'map-ui-controls';
  container.title = 'Map UI controls';
  const isDesktop = isDesktopEnvironment();
  // Helper to create a button
  function makeBtn(label, title) {
    const btn = document.createElement('button');
    btn.type = 'button';
    btn.textContent = label;
    btn.title = title;
    return btn;
  }
  // Zoom In
  if (isDesktop) {
    const zoomInBtn = makeBtn('+', 'Zoom in');
    zoomInBtn.addEventListener('click', () => { try { window.map && window.map.zoomIn(); } catch(e){} });
    container.appendChild(zoomInBtn);
    // Zoom Out
    const zoomOutBtn = makeBtn('âˆ’', 'Zoom out');
    zoomOutBtn.addEventListener('click', () => { try { window.map && window.map.zoomOut(); } catch(e){} });
    container.appendChild(zoomOutBtn);
    // Rotate reset (bearing & pitch)
    const rotateResetBtn = makeBtn('âŸ³', 'Reset bearing & pitch');
    rotateResetBtn.addEventListener('click', () => {
      try {
        if (window.map) {
          const c = window.map.getCenter();
          window.map.jumpTo({ center: c, zoom: window.map.getZoom(), bearing: 0, pitch: 0 });
        }
      } catch(e){}
    });
    container.appendChild(rotateResetBtn);
  }
  // Fullscreen toggle (always available)
  const fullscreenBtn = makeBtn('â›¶', 'Enter fullscreen');
  fullscreenBtn.addEventListener('click', () => {
    const el = document.documentElement; // Use the document root for broader fullscreen
    if (!document.fullscreenElement) {
      try { el.requestFullscreen(); } catch(e) {}
      fullscreenBtn.classList.add('fullscreen-exit');
      fullscreenBtn.textContent = 'â†™';
      fullscreenBtn.title = 'Exit fullscreen';
    } else {
      try { document.exitFullscreen(); } catch(e) {}
    }
  });
  document.addEventListener('fullscreenchange', () => {
    if (!document.fullscreenElement) {
      fullscreenBtn.classList.remove('fullscreen-exit');
      fullscreenBtn.textContent = 'â›¶';
      fullscreenBtn.title = 'Enter fullscreen';
    } else {
      fullscreenBtn.classList.add('fullscreen-exit');
      fullscreenBtn.textContent = 'â†™';
      fullscreenBtn.title = 'Exit fullscreen';
    }
  });
  container.appendChild(fullscreenBtn);
  document.body.appendChild(container);
}

// Remove map UI controls if present
function removeMapUIControls() {
  const el = document.getElementById('map-ui-controls');
  if (el) {
    el.remove();
  }
}

// Track externally loaded layers (not part of original style)
const externalLayers = new Set();

// Track layers with path geometry (LineString, Polygon) that can be followed
const followableLayers = new Set();

// Default camera
const defaultCamera = {
  center: [34.3537, 31.4238], // Custom view
  zoom: 10,
  bearing: 37.6,
  pitch: 0
};

// Parse hash: #lat,lng,zoom,bearing,pitch/+layer1,-layer2/load:filename
function parseHash() {
  const hash = window.location.hash.replace('#', '');
  if (!hash) return { camera: { ...defaultCamera }, layers: allStyleLayers.map(l => l.id), dynamicGeojsonToLoad: [], followId: null, followOffset: 0, showTicker: false, followHidden: false, showMapUI: false, isStatic: false };
  let cameraStr = '', layersStr = '', followId = null, followOffset = 0, showTicker = false, followHidden = false, showMapUI = false;
  const parts = hash.split('/');
  const restParts = [];
  for (let i = 0; i < parts.length; i++) {
    if (parts[i].startsWith('load:')) {
      continue;
    } else if (parts[i].length > 0) {
      restParts.push(parts[i]);
    }
  }
  cameraStr = restParts[0] || '';
  layersStr = restParts[1] || '';
  // If cameraStr isn't a numeric camera spec and there's no explicit layersStr,
  // treat the first non-empty segment as the layers part (supports hashes like "#/+layer,...")
  const cameraLike = /^-?\d+(?:\.\d+)?,-?\d+(?:\.\d+)?(?:,-?\d+(?:\.\d+)?){0,3}$/;
  if (!layersStr && cameraStr && !cameraLike.test(cameraStr)) {
    layersStr = cameraStr;
    cameraStr = '';
  }
  // Detect optional flags in any additional segments (e.g., /mapui, /embed-ui, /static)
  const extraSegments = parts.slice(2);
  showMapUI = extraSegments.some(seg => {
    const lower = seg.toLowerCase();
    return lower === 'mapui' || lower === 'embed-ui';
  });
  const isStatic = extraSegments.some(seg => seg.toLowerCase() === 'static');
  const cameraParts = cameraStr ? cameraStr.split(',').map(Number) : [];
  let layersOn = allStyleLayers.map(l => l.id);
  let dynamicGeojsonToLoad = [];
  if (layersStr) {
    layersOn = [];
    const layerState = {};
    splitLayerTokens(layersStr).forEach(token => {
      // Support +id:follow, ~id:follow, +id(sourceHint,expr,expr):follow, +id:follow+offset, +wayback:YYYYMMDD, and +id#2 (auto-increment)
      // token examples: +name, ~name, +name:follow, +name:follow+, +name:follow+0, +name:follow+15000, +name(source), +name(name=jabalia), +name(source,name=jabalia,type!=boundary), +gaza.geojson#2, +pois.csv#2
      // Sanitize and trim token before regex parsing
      const safeToken = token.replace(/[<>"'`]/g, '').trim();
      // Updated regex to allow extensions (.geojson, .json, .csv) in baseName before counter/parens
      const match = safeToken.match(/^([+~])([^()]+?)(?:#(\d+))?(?:\(([^)]*)\))?(?::follow(\+(\d*))?)?$/);
      if (!match) {
                return;
      }
      const [, sign, baseName, counterStr, parenContent, plusSign, offset] = match;
      // Reconstruct full layer name with counter if present
      const lname = counterStr ? `${baseName}#${counterStr}` : baseName;
      const hasFollow = token.includes(':follow');
      const hasTickerFlag = !!plusSign; // true if group 6 captured anything (:follow+ or :follow+number)
      const parsedOffset = offset ? parseInt(offset, 10) : 0;
      // Parse parentheses: may include sourceHint and/or one or more filter expressions
      const { sourceHint, filters: filterExprs } = parseParenArgs(parenContent || '');
      const filter = combineFilterExprsToMapbox(filterExprs);
      
      // Always use the id without :follow for loading/toggling
      layerState[lname] = { sign, sourceHint: sourceHint || null, filter, follow: hasFollow, followOffset: parsedOffset, showTicker: hasTickerFlag };
    });
  // Count wayback layers in hash to determine if we need to reposition
  const waybackLayersInHash = Object.entries(layerState).filter(([lname, { sign }]) => 
    sign === '+' && /^wayback:\d{8}$/.test(lname)
  ).map(([lname]) => lname);
  const needWaybackRepositioning = waybackLayersInHash.length > 1;
  
  Object.entries(layerState).forEach(([lname, { sign, sourceHint, filter, follow, followOffset: layerFollowOffset, showTicker: layerShowTicker }]) => {
      if (sign === '+') {
        const isStyleLayer = allStyleLayers.some(l => l.id === lname);
        const isExternalLayer = externalLayers.has(lname);
        
        // Check if this is a Wayback layer (format: wayback:YYYYMMDD)
        const waybackMatch = lname.match(/^wayback:(\d{8})$/);
        const isWaybackLayer = waybackMatch !== null;
        
        // Load layer if:
        // 1. It's not a style layer (new external layer)
        // 2. It's an external layer and has a sourceHint (reload with new style)
        // 3. It's a wayback layer and there are multiple wayback layers (need repositioning)
        if (!isStyleLayer || (isExternalLayer && sourceHint) || (isWaybackLayer && needWaybackRepositioning)) {
          if (isWaybackLayer) {
            const dateStr = waybackMatch[1];
            dynamicGeojsonToLoad.push({ name: lname, sourceHint: sourceHint || 'overlay', filter, isWayback: true, waybackDate: dateStr });
          } else {
            // Regular GeoJSON/CSV layer
            dynamicGeojsonToLoad.push({ name: lname, sourceHint, filter });
          }
        }
        layersOn.push(lname);
        if (follow) {
          followId = lname;
          followOffset = layerFollowOffset;
          showTicker = layerShowTicker;
          followHidden = (sign === '~');
        }
      } else if (sign === '~') {
        // For ~new-id, load as invisible (unchecked) dynamic layer
        const isStyleLayer = allStyleLayers.some(l => l.id === lname);
        const isExternalLayer = externalLayers.has(lname);
        
        if (!isStyleLayer || (isExternalLayer && sourceHint)) {
          dynamicGeojsonToLoad.push({ name: lname, sourceHint, filter });
        }
        if (follow) {
          followId = lname;
          followOffset = layerFollowOffset;
          showTicker = layerShowTicker;
          followHidden = (sign === '~');
        }
        // Do NOT add to layersOn, so it is not visible/checked
      }
    });
  }
  // Helper: treat 0 as a valid numeric value (don't use || which treats 0 as falsy)
  function pickNum(val, def) {
    return (typeof val === 'number' && !isNaN(val)) ? val : def;
  }

  return {
    camera: {
      center: [pickNum(cameraParts[1], defaultCamera.center[0]), pickNum(cameraParts[0], defaultCamera.center[1])],
      zoom: pickNum(cameraParts[2], defaultCamera.zoom),
      bearing: pickNum(cameraParts[3], defaultCamera.bearing),
      pitch: pickNum(cameraParts[4], defaultCamera.pitch)
    },
    layers: layersOn,
    dynamicGeojsonToLoad,
    followId,
    followOffset,
    showTicker,
    followHidden,
    showMapUI,
    isStatic
  };
}

// Helper: load and add GeoJSON (or CSV as fallback) as a top layer or replace source of a layer
// geojsonFile: path or filename (typically name.geojson or name.geojson#2 for auto-incremented layers). If not found, we also try name.csv in the same folder.
// toLayer: optional { visibility } or { sourceHint }
async function loadAndAddOrReplaceGeoJSON(geojsonFile, toLayer) {
  // Extract base filename (without #N counter) for loading, but keep full name for layer ID
  // Pattern: match name, optional counter (#N), optional extension (.geojson/.json/.csv)
  const counterMatch = geojsonFile.match(/^(.+?)(#\d+)?(\.(?:geo)?json|\.csv)?$/);
  const baseName = counterMatch ? counterMatch[1] : geojsonFile.replace(/\.(geo)?json$|\.csv$/i, '');
  const counter = counterMatch ? (counterMatch[2] || '') : '';
  const extension = counterMatch ? (counterMatch[3] || '') : '';
  
  // Reconstruct: baseFile is for loading (includes extension if provided), geojsonFile stays as-is for layer ID
  // If extension was explicitly provided in hash, use baseName + extension directly to avoid double extensions
  const baseFile = extension ? (baseName + extension) : baseName;
  
  // Important: Don't append extensions if file already has one to prevent pois.csv.geojson
  
  // 1) Attempt to fetch and normalize into GeoJSON
  async function loadAsGeoJSONOrCSV(path) {
    const lower = path.toLowerCase();
    const isCSV = lower.endsWith('.csv');
    const isJSON = lower.endsWith('.geojson') || lower.endsWith('.json');
    const hasExtension = isCSV || isJSON;
    // Remove extension to get base name
    const base = path.replace(/\.(geo)?json$/i, '').replace(/\.csv$/i, '');
    const nameOnly = base.split('/').pop();
    // Build paths: if file already has extension, use base for alternate formats
    const sameDirGeo = `${base}.geojson`;
    const sameDirCsv = `${base}.csv`;
    const dataDirCsv = `${base.substring(0, base.lastIndexOf('/')) !== '' ? base.substring(0, base.lastIndexOf('/')) + '/' : ''}data/${nameOnly}.csv`;
    const upDataDirCsv = `../data/${nameOnly}.csv`;

    // If explicit extension provided, try that first with fallbacks
    if (isJSON) {
      try {
        const r = await fetch(path);
        if (!r.ok) throw new Error(`HTTP ${r.status}`);
        return await r.json();
      } catch (e) {
        // Fallback to CSV beside it
        const csvPath = sameDirCsv;
        try {
          const r2 = await fetch(csvPath);
          if (!r2.ok) throw new Error(`HTTP ${r2.status}`);
          const txt = await r2.text();
          return csvTextToGeoJSON(txt);
        } catch (e2) {
          // Try ./data/ and ../data/
          try {
            const r3 = await fetch(dataDirCsv);
            if (!r3.ok) throw new Error(`HTTP ${r3.status}`);
            const txt3 = await r3.text();
            return csvTextToGeoJSON(txt3);
          } catch (e3) {
            try {
              const r4 = await fetch(upDataDirCsv);
              if (!r4.ok) throw new Error(`HTTP ${r4.status}`);
              const txt4 = await r4.text();
              return csvTextToGeoJSON(txt4);
            } catch (e4) {
              throw new Error(`Failed to load as GeoJSON (${path}) or CSV (${csvPath} | ${dataDirCsv} | ${upDataDirCsv}).`);
            }
          }
        }
      }
    } else if (isCSV) {
      try {
        const r = await fetch(path);
        if (!r.ok) throw new Error(`HTTP ${r.status}`);
        const txt = await r.text();
        return csvTextToGeoJSON(txt);
      } catch (e) {
        // Fallback to GeoJSON beside it
        const gjPath = sameDirGeo;
        try {
          const r2 = await fetch(gjPath);
          if (!r2.ok) throw new Error(`HTTP ${r2.status}`);
          return await r2.json();
        } catch (e2) {
          throw new Error(`Failed to load as CSV (${path}) or GeoJSON (${gjPath}).`);
        }
      }
    } else {
      // No extension provided: try .geojson then .csv
      try {
        const r = await fetch(sameDirGeo);
        if (!r.ok) throw new Error(`HTTP ${r.status}`);
        return await r.json();
      } catch (e) {
        try {
          const r2 = await fetch(sameDirCsv);
          if (!r2.ok) throw new Error(`HTTP ${r2.status}`);
          const txt = await r2.text();
          return csvTextToGeoJSON(txt);
        } catch (e2) {
          // Try ./data/ and ../data/
          try {
            const r3 = await fetch(dataDirCsv);
            if (!r3.ok) throw new Error(`HTTP ${r3.status}`);
            const txt3 = await r3.text();
            return csvTextToGeoJSON(txt3);
          } catch (e3) {
            try {
              const r4 = await fetch(upDataDirCsv);
              if (!r4.ok) throw new Error(`HTTP ${r4.status}`);
              const txt4 = await r4.text();
              return csvTextToGeoJSON(txt4);
            } catch (e4) {
              throw new Error(`Failed to load ${nameOnly} as .geojson or .csv (searched: ${sameDirGeo}, ${sameDirCsv}, ${dataDirCsv}, ${upDataDirCsv})`);
            }
          }
        }
      }
    }
  }

  // CSV -> GeoJSON (Point features) using Papa Parse for robust CSV parsing
  function csvTextToGeoJSON(csvText) {
    if (typeof Papa === 'undefined' || !Papa.parse) {
      throw new Error('CSV parsing library not loaded.');
    }
    const res = Papa.parse(csvText, { header: true, dynamicTyping: true, skipEmptyLines: true });
    if (res.errors && res.errors.length) {
          }
    const rows = res.data || [];
    if (!rows.length) return { type: 'FeatureCollection', features: [] };
    // Find lat/lon columns (case-insensitive)
    const keys = Object.keys(rows[0] || {});
    const lowerMap = Object.fromEntries(keys.map(k => [k.toLowerCase(), k]));
    const latCandidates = ['lat', 'latitude', 'y'];
    const lonCandidates = ['lon', 'lng', 'long', 'longitude', 'x'];
    const latKey = latCandidates.map(k => lowerMap[k]).find(Boolean);
    const lonKey = lonCandidates.map(k => lowerMap[k]).find(Boolean);
    if (!latKey || !lonKey) {
      throw new Error('CSV missing latitude/longitude columns');
    }
    const features = [];
    for (const row of rows) {
      const lat = parseFloat(row[latKey]);
      const lon = parseFloat(row[lonKey]);
      if (!isFinite(lat) || !isFinite(lon)) continue;
      const props = { ...row };
      features.push({
        type: 'Feature',
        geometry: { type: 'Point', coordinates: [lon, lat] },
        properties: props
      });
    }
    return { type: 'FeatureCollection', features };
  }

  try {
    const geojson = await loadAsGeoJSONOrCSV(baseFile);
    // 2) Determine ids and clean - use full geojsonFile (with counter) for IDs
    let fileId = geojsonFile.split('/').pop();
    let cleanId = fileId.replace(/(_geojson|\.geojson|\.json|\.csv)$/i, '');
    cleanId = cleanId.replace(/[^a-zA-Z0-9_#-]/g, '_'); // Allow # for counter
    const sourceId = cleanId;
    const layerId = cleanId;

    // 3) Replace existing and add source
    if (map.getLayer(layerId)) map.removeLayer(layerId);
    if (map.getSource(sourceId)) map.removeSource(sourceId);
    map.addSource(sourceId, { type: 'geojson', data: geojson });

    // 4) Extract sourceHint and determine layer type
    let sourceHint = null;
    let filter = null;
    if (typeof toLayer === 'object' && toLayer !== null && toLayer.sourceHint) sourceHint = toLayer.sourceHint;
    if (typeof toLayer === 'object' && toLayer !== null && toLayer.filter) filter = toLayer.filter;
    if (!sourceHint && typeof geojsonFile === 'object' && geojsonFile.sourceHint) sourceHint = geojsonFile.sourceHint;
    if (!filter && typeof geojsonFile === 'object' && geojsonFile.filter) filter = geojsonFile.filter;
    
    let type = 'line';
    let sourceLayerFound = false;
    
    if (sourceHint) {
      const styleLayer = map.getStyle().layers.find(l => l.id === sourceHint);
      if (styleLayer && styleLayer.type) {
        type = styleLayer.type;
        sourceLayerFound = true;
      }
    }
    
    // Fallback: infer from geometry if no source layer found
    if (!sourceLayerFound) {
      if (geojson.features && geojson.features.length) {
        const geomType = geojson.features[0].geometry && geojson.features[0].geometry.type;
        if (geomType === 'Polygon' || geomType === 'MultiPolygon') type = 'fill';
        else if (geomType === 'Point' || geomType === 'MultiPoint') type = 'circle';
      }
    }

    // 5) Visibility
    let visibility = 'visible';
    if (typeof toLayer === 'object' && toLayer !== null && toLayer.visibility === 'none') {
      visibility = 'none';
    }

    // 6) Base paint defaults
    const basePaint = type === 'line' ? { 'line-color': '#fff', 'line-width': 3 } :
                      type === 'fill' ? { 'fill-color': '#f00', 'fill-opacity': 0.5 } :
                      { 'circle-radius': 6, 'circle-color': '#f00' };

    const layerDef = {
      id: layerId,
      type,
      source: sourceId,
      layout: { visibility },
      paint: basePaint
    };
    
    // 7) Copy styling from sourceHint if provided (paint/layout only)
    try {
      if (sourceHint) {
        const styleLayer = map.getStyle().layers.find(l => l.id === sourceHint);
        if (styleLayer) {
          if (styleLayer.paint) layerDef.paint = JSON.parse(JSON.stringify(styleLayer.paint));
          if (styleLayer.layout) {
            const copiedLayout = JSON.parse(JSON.stringify(styleLayer.layout));
            if (typeof copiedLayout.visibility !== 'undefined') delete copiedLayout.visibility;
            layerDef.layout = Object.assign({}, layerDef.layout, copiedLayout);
          }
          // IMPORTANT: Do NOT copy the style layer's filter to external GeoJSON layers.
          // Filters on style layers usually reference properties from the vector tile
          // source (e.g., class, type) that do not exist on the external GeoJSON.
          // Copying them would filter out all features and make the layer invisible.
          // Only explicit filters provided in the hash (parentheses) are applied below.
        }
      }
    } catch (ex) {
      // Failed to apply source hint style
    }
    
    // Add explicit filter if provided in hash (overrides sourceHint filter)
    if (filter) {
      layerDef.filter = filter;
    }

    // 8) Add layer - with beforeId to place right after source layer if sourceHint is provided
    try {
      if (sourceHint) {
        // Find the layer that comes right after the source layer to insert before it
        const allLayers = map.getStyle().layers;
        const sourceIndex = allLayers.findIndex(l => l.id === sourceHint);
        if (sourceIndex >= 0) {
          if (sourceIndex < allLayers.length - 1) {
            const beforeId = allLayers[sourceIndex + 1].id;
            map.addLayer(layerDef, beforeId);
          } else {
            // Source layer is last, add at top
            map.addLayer(layerDef);
          }
        } else {
          // Source layer not found
          map.addLayer(layerDef);
        }
      } else {
        // No source hint, add at top
        map.addLayer(layerDef);
      }
    } catch (ex) {
      // Failed to add layer with positioning, try fallback
      // Fallback: add without beforeId
      try {
        map.addLayer(layerDef);
      } catch (ex2) {
                throw ex2;
      }
    }
    
    // Mark as external layer
    externalLayers.add(layerId);

    // Store the default filter for external layer: never inherit style layer filters.
    // External GeoJSON layers start with no filter unless one is explicitly provided in the hash.
    styleDefaultFilter[layerId] = null;
    
    // Check if this layer has path geometry (followable)
    if (geojson && geojson.features && geojson.features.length > 0) {
      const hasPathGeometry = geojson.features.some(f => {
        if (!f.geometry) return false;
        const gType = f.geometry.type;
        return gType === 'LineString' || gType === 'MultiLineString' || 
               gType === 'Polygon' || gType === 'MultiPolygon';
      });
      if (hasPathGeometry) {
        followableLayers.add(layerId);
      }
    }

    // 9) Follow logic is handled centrally in the hashchange handler to ensure
    // camera and layer flags are applied first. No auto-follow here.

    // 10) Post-load bookkeeping/UI
    if (visibility === 'none') {
      map.setLayoutProperty(layerId, 'visibility', 'none');
    }
    if (!allStyleLayers.some(l => l.id === layerId)) {
      // Insert the layer in the correct position based on actual map layer order
      try {
        if (sourceHint) {
          // Find the source layer's position in allStyleLayers
          const sourceIdx = allStyleLayers.findIndex(l => l.id === sourceHint);
          if (sourceIdx >= 0) {
            // Insert right after the source layer
            allStyleLayers.splice(sourceIdx + 1, 0, { id: layerId, name: cleanId });
          } else {
            // Source not in list, add at end
            allStyleLayers.push({ id: layerId, name: cleanId });
          }
        } else {
          // No source hint, add at end
          allStyleLayers.push({ id: layerId, name: cleanId });
        }
      } catch (ex) {
        // Failed to position layer in list, add at end
        allStyleLayers.push({ id: layerId, name: cleanId });
      }
      styleDefaultVisibility[layerId] = 'visible';
    }
    createLayerControls(map, allStyleLayers.filter(l => map.getLayer(l.id) && map.getLayoutProperty(l.id, 'visibility') === 'visible').map(l => l.id));
  } catch (err) {
      }
}

// Helper: Load Sentinel-2 imagery layer by date
// Helper: Load ESRI Wayback imagery layer by date
// dateStr: YYYYMMDD format (e.g., "20240215")
// toLayer: optional { visibility, sourceHint }
async function loadWaybackLayer(dateStr, toLayer) {
  try {
    const layerId = `wayback:${dateStr}`;
    const sourceId = layerId;
    
    // Validate date format
    if (!/^\d{8}$/.test(dateStr)) {
      throw new Error('Invalid date format. Expected YYYYMMDD, got: ' + dateStr);
    }
    
    // Parse date
    const year = dateStr.substring(0, 4);
    const month = dateStr.substring(4, 6);
    const day = dateStr.substring(6, 8);
    const requestDate = `${year}-${month}-${day}`;
    
    // Fetch Wayback configuration
    const configResponse = await fetch('https://s3-us-west-2.amazonaws.com/config.maptiles.arcgis.com/waybackconfig.json');
    if (!configResponse.ok) {
      throw new Error('Failed to fetch Wayback configuration');
    }
    
    const config = await configResponse.json();
    
    // Parse releases and find closest one to requested date
    const releases = Object.entries(config).map(([releaseId, info]) => {
      // Extract date from title like "World Imagery (Wayback 2024-11-18)"
      const match = info.itemTitle.match(/(\d{4}-\d{2}-\d{2})/);
      if (match) {
        return {
          releaseId,
          date: match[1],
          dateObj: new Date(match[1]),
          title: info.itemTitle
        };
      }
      return null;
    }).filter(r => r !== null);
    
    // Sort by date
    releases.sort((a, b) => a.dateObj - b.dateObj);
    
    // Find closest release to requested date
    const targetDate = new Date(requestDate);
    let closestRelease = releases[0];
    let minDiff = Math.abs(targetDate - releases[0].dateObj);
    
    for (const release of releases) {
      const diff = Math.abs(targetDate - release.dateObj);
      if (diff < minDiff) {
        minDiff = diff;
        closestRelease = release;
      }
      // If we've passed the target date, stop
      if (release.dateObj > targetDate) {
        break;
      }
    }
    
    // ESRI Wayback tile URL
    const tileUrl = `https://wayback.maptiles.arcgis.com/arcgis/rest/services/world_imagery/wmts/1.0.0/default028mm/mapserver/tile/${closestRelease.releaseId}/{z}/{y}/{x}`;
    
    // Extract sourceHint - default to 'satellite' layer for positioning
    let sourceHint = 'satellite';
    if (typeof toLayer === 'object' && toLayer !== null && toLayer.sourceHint) {
      sourceHint = toLayer.sourceHint;
    }
    
    // Remove existing layer/source if present
    if (map.getLayer(layerId)) map.removeLayer(layerId);
    if (map.getSource(sourceId)) map.removeSource(sourceId);
    
    // Add raster source
    map.addSource(sourceId, {
      type: 'raster',
      tiles: [tileUrl],
      tileSize: 256,
      minzoom: 0,
      maxzoom: 22,  // Wayback supports very high zoom levels
      attribution: 'Â© Esri, Maxar, GeoEye, Earthstar Geographics, CNES/Airbus DS, USDA, USGS, AeroGRID, IGN, and the GIS User Community'
    });
    
    // Visibility
    let visibility = 'visible';
    if (typeof toLayer === 'object' && toLayer !== null && toLayer.visibility === 'none') {
      visibility = 'none';
    }
    
    // Create layer definition
    const layerDef = {
      id: layerId,
      type: 'raster',
      source: sourceId,
      layout: { visibility },
      paint: {
        'raster-opacity': 1
      }
    };
    
    // Copy paint properties from source hint if available
    try {
      if (sourceHint) {
        const styleLayer = map.getStyle().layers.find(l => l.id === sourceHint);
        if (styleLayer && styleLayer.paint && styleLayer.paint['raster-opacity'] !== undefined) {
          layerDef.paint['raster-opacity'] = styleLayer.paint['raster-opacity'];
        }
      }
    } catch (ex) {
      // Failed to copy paint from source hint
    }
    
    // Add layer positioned according to hash order
    try {
      const allLayers = map.getStyle().layers;
      let beforeId = null;
      
      // If we have hash order info, use it to determine correct position
      const waybackLayersInHashOrder = (toLayer && toLayer.waybackLayersInHashOrder) || [];
      
            
      if (waybackLayersInHashOrder.length > 0) {
        // Find the position of this layer in the hash order
        const thisLayerHashIndex = waybackLayersInHashOrder.indexOf(layerId);
        
                
        if (thisLayerHashIndex >= 0) {
          // Find the next wayback layer in hash order that already exists in the map
          for (let i = thisLayerHashIndex + 1; i < waybackLayersInHashOrder.length; i++) {
            const nextLayerId = waybackLayersInHashOrder[i];
            if (map.getLayer(nextLayerId)) {
              beforeId = nextLayerId;
                            break;
            }
          }
          
          // If no next wayback layer found, check if there are previous wayback layers
          // If so, position after the last one (find first non-wayback layer after all waybacks)
          if (!beforeId && thisLayerHashIndex > 0) {
                        // Look for previous wayback layers in hash order
            for (let i = thisLayerHashIndex - 1; i >= 0; i--) {
              const prevLayerId = waybackLayersInHashOrder[i];
              if (map.getLayer(prevLayerId)) {
                // Found a previous wayback layer - insert right after it
                const prevLayerIndex = allLayers.findIndex(l => l.id === prevLayerId);
                                if (prevLayerIndex >= 0 && prevLayerIndex < allLayers.length - 1) {
                  beforeId = allLayers[prevLayerIndex + 1].id;
                                  }
                break;
              }
            }
          }
          
          // If still no position found, use sourceHint
          if (!beforeId && sourceHint) {
            const sourceIndex = allLayers.findIndex(l => l.id === sourceHint);
            if (sourceIndex >= 0 && sourceIndex < allLayers.length - 1) {
              beforeId = allLayers[sourceIndex + 1].id;
                          }
          }
        }
      } else {
        // Fallback: manually added layer (not from hash) - insert before topmost wayback
        const existingWaybackLayers = allLayers.filter(l => l.id.startsWith('wayback:'));
        
        if (existingWaybackLayers.length > 0) {
          const topmostWaybackIndex = allLayers.findIndex(l => l.id === existingWaybackLayers[0].id);
          if (topmostWaybackIndex >= 0) {
            beforeId = allLayers[topmostWaybackIndex].id;
          }
        } else if (sourceHint) {
          const sourceIndex = allLayers.findIndex(l => l.id === sourceHint);
          if (sourceIndex >= 0 && sourceIndex < allLayers.length - 1) {
            beforeId = allLayers[sourceIndex + 1].id;
          }
        }
      }
      
            
      if (beforeId) {
        map.addLayer(layerDef, beforeId);
      } else {
        map.addLayer(layerDef);
      }
    } catch (ex) {
      // Failed to add layer with positioning, fallback
            map.addLayer(layerDef);
    }
    
    // Mark as external layer
    externalLayers.add(layerId);
  // Wayback raster layers don't support filters, but store null for consistency
  styleDefaultFilter[layerId] = null;
    
    // Post-load bookkeeping
    if (visibility === 'none') {
      map.setLayoutProperty(layerId, 'visibility', 'none');
    }
    
    // Add to allStyleLayers if not present - respect hash order
    if (!allStyleLayers.some(l => l.id === layerId)) {
      try {
        const waybackLayersInHashOrder = (toLayer && toLayer.waybackLayersInHashOrder) || [];
        
        if (waybackLayersInHashOrder.length > 0) {
          // Use hash order to determine position
          const thisLayerHashIndex = waybackLayersInHashOrder.indexOf(layerId);
          
          if (thisLayerHashIndex >= 0) {
            // Find the next wayback layer in hash order that already exists
            let insertBeforeIndex = -1;
            for (let i = thisLayerHashIndex + 1; i < waybackLayersInHashOrder.length; i++) {
              const nextLayerId = waybackLayersInHashOrder[i];
              const existingIndex = allStyleLayers.findIndex(l => l.id === nextLayerId);
              if (existingIndex >= 0) {
                insertBeforeIndex = existingIndex;
                break;
              }
            }
            
            if (insertBeforeIndex >= 0) {
              allStyleLayers.splice(insertBeforeIndex, 0, { id: layerId, name: `Wayback ${requestDate}` });
            } else if (thisLayerHashIndex > 0) {
              // No next layer found - look for previous layer in hash order
              for (let i = thisLayerHashIndex - 1; i >= 0; i--) {
                const prevLayerId = waybackLayersInHashOrder[i];
                const prevIndex = allStyleLayers.findIndex(l => l.id === prevLayerId);
                if (prevIndex >= 0) {
                  // Insert after the previous layer
                  allStyleLayers.splice(prevIndex + 1, 0, { id: layerId, name: `Wayback ${requestDate}` });
                  insertBeforeIndex = prevIndex; // Mark as handled
                  break;
                }
              }
              // If still not handled, fall back to sourceHint
              if (insertBeforeIndex === -1) {
                if (sourceHint) {
                  const sourceIdx = allStyleLayers.findIndex(l => l.id === sourceHint);
                  if (sourceIdx >= 0) {
                    allStyleLayers.splice(sourceIdx + 1, 0, { id: layerId, name: `Wayback ${requestDate}` });
                  } else {
                    allStyleLayers.push({ id: layerId, name: `Wayback ${requestDate}` });
                  }
                } else {
                  allStyleLayers.push({ id: layerId, name: `Wayback ${requestDate}` });
                }
              }
            } else if (sourceHint) {
              const sourceIdx = allStyleLayers.findIndex(l => l.id === sourceHint);
              if (sourceIdx >= 0) {
                allStyleLayers.splice(sourceIdx + 1, 0, { id: layerId, name: `Wayback ${requestDate}` });
              } else {
                allStyleLayers.push({ id: layerId, name: `Wayback ${requestDate}` });
              }
            } else {
              allStyleLayers.push({ id: layerId, name: `Wayback ${requestDate}` });
            }
          } else {
            allStyleLayers.push({ id: layerId, name: `Wayback ${requestDate}` });
          }
        } else {
          // Fallback for manually added layers
          const existingWaybackIndex = allStyleLayers.findIndex(l => l.id.startsWith('wayback:'));
          
          if (existingWaybackIndex >= 0) {
            allStyleLayers.splice(existingWaybackIndex, 0, { id: layerId, name: `Wayback ${requestDate}` });
          } else if (sourceHint) {
            const sourceIdx = allStyleLayers.findIndex(l => l.id === sourceHint);
            if (sourceIdx >= 0) {
              allStyleLayers.splice(sourceIdx + 1, 0, { id: layerId, name: `Wayback ${requestDate}` });
            } else {
              allStyleLayers.push({ id: layerId, name: `Wayback ${requestDate}` });
            }
          } else {
            allStyleLayers.push({ id: layerId, name: `Wayback ${requestDate}` });
          }
        }
      } catch (ex) {
        // Failed to position layer in list, add at end
        allStyleLayers.push({ id: layerId, name: `Wayback ${requestDate}` });
      }
      styleDefaultVisibility[layerId] = 'visible';
    }
    
    // Update layer controls
    createLayerControls(map, allStyleLayers.filter(l => map.getLayer(l.id) && map.getLayoutProperty(l.id, 'visibility') === 'visible').map(l => l.id));
    
  } catch (err) {
                          }
}

// Update hash from map state
function updateHash(map, visibleLayers) {
  const c = map.getCenter();
  const z = map.getZoom().toFixed(2);
  const b = map.getBearing().toFixed(1);
  const p = map.getPitch().toFixed(1);
  // Preserve existing layer part of hash if present
  const hash = window.location.hash.replace('#', '');
  const parts = hash.split('/');
  const layersStr = parts[1];
  const trailing = parts.slice(2);
  const cameraStr = `${c.lat.toFixed(5)},${c.lng.toFixed(5)},${z},${b},${p}`;
  const newHash = `#${cameraStr}` + (layersStr !== undefined ? `/${layersStr}` : '') + (trailing.length ? `/${trailing.join('/')}` : '');
  window.location.replace(newHash);
}

// Debounce helper for expensive operations
let createLayerControlsTimeout = null;
function createLayerControlsDebounced(map, visibleLayers) {
  if (createLayerControlsTimeout) clearTimeout(createLayerControlsTimeout);
  createLayerControlsTimeout = setTimeout(() => {
    createLayerControls(map, visibleLayers);
  }, 10);
}

// Cache for parsed hash state to avoid redundant parsing
let cachedHashString = '';
let cachedHashState = null;

// Create layer controls
function createLayerControls(map, visibleLayers) {
  const container = document.getElementById('layer-list');
  if (!container) return;
  
  // Performance: Build HTML in array then join once
  const htmlParts = [];
  let foundLayer = false;
  
  // Always reflect the current style visibility for checkboxes
  // Parse current hash for explicit toggles and :follow flags
  const hash = window.location.hash.replace('#', '');
  const [, layersStr] = hash.split('/');
  
  // Performance: Use cached parse result if hash hasn't changed
  let explicitState, followState, followOffsets, showTicker, layerFilters;
  if (cachedHashString === hash && cachedHashState) {
    explicitState = cachedHashState.explicitState;
    followState = cachedHashState.followState;
    followOffsets = cachedHashState.followOffsets;
    showTicker = cachedHashState.showTicker;
    layerFilters = cachedHashState.layerFilters;
  } else {
    explicitState = {};
    followState = {}; // Track which layers have :follow
    followOffsets = {}; // Track follow offset values
    showTicker = {}; // Track whether to show ticker (true if :follow+ or :follow+number)
    layerFilters = {}; // Track filter expressions for layers
    if (layersStr) {
      splitLayerTokens(layersStr).forEach(token => {
        // New grammar: +layerName, +layerName(sourceHint,expr,expr), +layerName:follow(+offset)
        const match = token.match(/^([+~])([^()]+?)(?:\(([^)]*)\))?(?::follow(\+(\d*))?)?$/);
        if (!match) return;
        const [, sign, lname, parenContent, plusSign, offset] = match;
        explicitState[lname] = sign;
        const followFlag = token.includes(':follow');
        if (followFlag) {
          followState[lname] = true;
          // If there's a + sign (even without a number), show ticker
          showTicker[lname] = !!plusSign;
          // Parse the offset value (default to 0 if no digits provided)
          followOffsets[lname] = offset ? parseInt(offset, 10) : 0;
        }
        // Extract filters from parens for UI display (comma-separated)
        const { filters } = parseParenArgs(parenContent || '');
        if (filters && filters.length) layerFilters[lname] = filters.join(',');
      });
    }
    // Cache the result
    cachedHashString = hash;
    cachedHashState = { explicitState, followState, followOffsets, showTicker, layerFilters };
  }
  // Include all style layers and any geojson-above-* layers
  const allLayers = [
    ...allStyleLayers,
    ...map.getStyle().layers
      .filter(l => l.id.startsWith('geojson-above-') && !allStyleLayers.some(s => s.id === l.id))
      .map(l => ({ id: l.id }))
  ];
  // Order from highest (topmost) to lowest (bottommost)
  allLayers.reverse();
  allLayers.forEach(layer => {
    if (map.getLayer(layer.id)) {
      foundLayer = true;
      const vis = map.getLayoutProperty(layer.id, 'visibility');
      const defaultVis = styleDefaultVisibility[layer.id] || 'visible';
      let checked, bold, state, showReset = false;
      if (explicitState[layer.id] === '+') {
        checked = 'checked';
        bold = true;
        state = 'visible';
        showReset = (defaultVis !== 'visible');
      } else if (explicitState[layer.id] === '~') {
        checked = '';
        bold = true;
        state = 'hidden';
        showReset = (defaultVis !== 'none');
      } else {
        checked = (defaultVis === 'visible') ? 'checked' : '';
        bold = false;
        state = 'default';
        showReset = false;
      }
      let label = layer.name || layer.id;
      // Strip file extensions from label for cleaner display
      label = label.replace(/\.(geojson|json|csv)$/i, '');
      // Append sourceHint if present in hash explicit state (parse from token map)
      // We'll parse the hash token for this specific layer to see if it has a (sourceHint)
      let sourceHintForLabel = null;
      if (layersStr) {
        const tokensRaw = splitLayerTokens(layersStr);
        for (const t of tokensRaw) {
          // Match including optional counter (#N) inside name part and single paren group
          const m = t.match(/^([+~])([^()#]+?(?:#\d+)?)(?:\(([^)]*)\))?(?::follow(?:\+\d*)?)?$/);
          if (m) {
            const [, , lnameMaybe, parenContent] = m;
            if (lnameMaybe === layer.id && parenContent) {
              const parsed = parseParenArgs(parenContent);
              if (parsed.sourceHint) sourceHintForLabel = parsed.sourceHint;
              break;
            }
          }
        }
      }
      if (sourceHintForLabel) {
        label += ` (${sourceHintForLabel})`;
      }
      // Check if this is an externally loaded layer
      const isExternalLayer = externalLayers.has(layer.id);
      // Check if this is a followable layer
      const isFollowable = followableLayers.has(layer.id);
      const isFollowing = followState[layer.id] || false;
      const hasTickerFlag = showTicker[layer.id] || false;
      // Check if this layer has a filter
      const layerFilter = layerFilters[layer.id] || '';
      const hasFilter = !!layerFilter;
      // Apply bold blue styling for external layers
      const labelStyle = isExternalLayer ? 'font-weight:bold;color:#4caf50;' : (bold ? 'font-weight:bold;' : '');
      
      // Build button HTML
      let buttonHtml = '';
      
      // Add filter button/input only for external layers (not Mapbox style layers)
      if (isExternalLayer && layerSupportsFilter(layer.id)) {
        const filterClass = hasFilter ? ' class="active"' : '';
        const filterInputClass = hasFilter ? ' class="active"' : '';
  buttonHtml += ` <button data-filter="${layer.id}" title="Add/edit feature filter"${filterClass}>á¯¤</button>`;
    buttonHtml += ` <input type="text" data-filter-input="${layer.id}" value="${layerFilter}" placeholder="key=value[,key=value]"${filterInputClass} class="filter-input" title="Filter expressions (comma-separated), e.g., name=jabalia or name=jabalia|beit_hanoun or name=jabalia,type!=boundary)">`;
    // Common properties dropdown (hidden until filter UI toggled)
        const propSelectActive = hasFilter ? ' active' : '';
        buttonHtml += ` <select data-filter-prop="${layer.id}" class="filter-prop-select${propSelectActive}" title="Common properties for ${layer.id}"><option value="">â€” property â€”</option></select>`;
      }
      
      // Add follow button for followable layers
      if (isFollowable) {
        const followClass = isFollowing ? ' class="active"' : '';
        const offsetValue = followOffsets[layer.id] || 0;
        // Show offset input if following (allow user to add + to enable ticker)
        // OR if ticker flag is already present (:follow+ or :follow+number)
        const shouldShowInput = isFollowing || hasTickerFlag;
        const inputClass = shouldShowInput ? ' class="active"' : '';
        // Set input value to "+" by default when following without ticker, otherwise show offset number
        const inputValue = (isFollowing && !hasTickerFlag) ? '+' : offsetValue;
        buttonHtml += ` <button data-follow="${layer.id}" title="Toggle follow animation"${followClass}>âž </button>`;
        buttonHtml += ` <input type="text" data-follow-offset="${layer.id}" value="${inputValue}" placeholder="+"${inputClass} class="follow-offset-input" title="Distance offset in meters, or + to show ticker from 0">`;
      }
      
      if (isExternalLayer) {
        buttonHtml += ` <button data-delete="${layer.id}" title="Delete layer">Ã—</button>`;
      } else if (explicitState[layer.id]) {
        buttonHtml += ` <button data-reset="${layer.id}" title="Reset to style default">â†»</button>`;
      }
      
      // Performance: Push to array instead of concatenating to innerHTML
      // Build a comprehensive tooltip (title) for this layer item
      const tooltipParts = [];
      tooltipParts.push(`Layer: ${layer.id}`);
      if (sourceHintForLabel) tooltipParts.push(`Source style: ${sourceHintForLabel}`);
      if (isExternalLayer) tooltipParts.push('External data layer');
      if (isFollowable) tooltipParts.push('Path geometry (followable)');
      if (isFollowing) tooltipParts.push(`Following path${showTicker[layer.id] ? ' (ticker active)' : ''}`);
      if (hasFilter) tooltipParts.push(`Filter: ${layerFilter}`);
      const itemTitle = tooltipParts.join(' â€¢ ');
      htmlParts.push(`<span class="layer-list-item" data-layer-item="${layer.id}" title="${itemTitle}"><label style="${labelStyle}" title="${itemTitle}"><input type="checkbox" data-layer="${layer.id}" ${checked} title="Toggle visibility for ${layer.id}"> ${label}</label>${buttonHtml}</span>`);
    }
  });
  
  if (!foundLayer) {
    htmlParts.push('<em>No toggleable layers found in the current style.</em>');
  }
  
  // Performance: Single DOM update instead of multiple
  container.innerHTML = htmlParts.join('');
  // Populate any active property dropdowns immediately
  container.querySelectorAll('select[data-filter-prop].active').forEach(sel => {
    const lid = sel.getAttribute('data-filter-prop');
    populateFilterPropsDropdown(lid, sel);
  });
  // After injecting HTML, property dropdowns exist; listeners added later in this function.
  container.querySelectorAll('input[type=checkbox]').forEach(cb => {
    cb.addEventListener('change', function() {
      const layerId = this.getAttribute('data-layer');
      if (!map.getLayer(layerId)) {
                return;
      }
      // Parse current hash for explicit toggles
      const hash = window.location.hash.replace('#', '');
      const [cameraStr, layersStr] = hash.split('/');
      const tokenMap = {}; // Map layer name to full token
      if (layersStr) {
        splitLayerTokens(layersStr).forEach(token => {
          // Parse token to extract layer name (new parens-based grammar)
          const match = token.match(/^([+~])([^()]+?)(?:\([^)]*\))?(?::follow(?:\+\d*)?)?$/);
          if (!match) return;
          const [, sign, lname] = match;
          tokenMap[lname] = token; // Store full token
        });
      }
      // Toggle + or ~ in hash and set visibility
      if (this.checked) {
        // If token exists, change sign to +, otherwise create new +token
        if (tokenMap[layerId]) {
          tokenMap[layerId] = tokenMap[layerId].replace(/^[+~]/, '+');
        } else {
          tokenMap[layerId] = `+${layerId}`;
        }
        map.setLayoutProperty(layerId, 'visibility', 'visible');
      } else {
        // If token exists, change sign to ~, otherwise create new ~token
        if (tokenMap[layerId]) {
          tokenMap[layerId] = tokenMap[layerId].replace(/^[+~]/, '~');
        } else {
          tokenMap[layerId] = `~${layerId}`;
        }
        map.setLayoutProperty(layerId, 'visibility', 'none');
      }
      // Build new hash from tokens
      const tokens = Object.values(tokenMap);
      const raw = window.location.hash.replace('#','');
      const parts = raw.split('/');
      const trailing = parts.slice(2);
      if (tokens.length > 0) {
        window.location.replace(`#${cameraStr}/${tokens.join(',')}` + (trailing.length ? `/${trailing.join('/')}` : ''));
      } else {
        window.location.replace(`#${cameraStr}` + (trailing.length ? `/${trailing.join('/')}` : ''));
      }
    });
  });

  // Add reset button listeners for style layers
  container.querySelectorAll('button[data-reset]').forEach(btn => {
    btn.addEventListener('click', function(e) {
      e.preventDefault();
      const layerId = this.getAttribute('data-reset');
      // Parse current hash for explicit toggles
      const hash = window.location.hash.replace('#', '');
      const [cameraStr, layersStr] = hash.split('/');
      const explicitState = {};
      if (layersStr) {
        splitLayerTokens(layersStr).forEach(token => {
          const match = token.match(/^([+~])(.+)$/);
          if (!match) return;
          const [, sign, lname] = match;
          explicitState[lname] = sign;
        });
      }
      // Remove explicit toggle for this layer
      delete explicitState[layerId];
      // Style layer: restore style default
      const defaultVis = styleDefaultVisibility[layerId] || 'visible';
      map.setLayoutProperty(layerId, 'visibility', defaultVis);
      // Build new hash
      const tokens = Object.entries(explicitState).map(([lname, sign]) => `${sign}${lname}`);
      const raw = window.location.hash.replace('#','');
      const parts = raw.split('/');
      const trailing = parts.slice(2);
      if (tokens.length > 0) {
        window.location.replace(`#${cameraStr}/${tokens.join(',')}` + (trailing.length ? `/${trailing.join('/')}` : ''));
      } else {
        window.location.replace(`#${cameraStr}` + (trailing.length ? `/${trailing.join('/')}` : ''));
      }
    });
  });

  // Reset all button handler
  const resetAllBtn = document.getElementById('reset-all-btn');
  if (resetAllBtn) {
    resetAllBtn.addEventListener('click', function(e) {
      e.preventDefault();
      // Parse current hash to get camera position
      const hash = window.location.hash.replace('#', '');
      const [cameraStr] = hash.split('/');
      
      // Reset all layers to style defaults
      Object.keys(styleDefaultVisibility).forEach(layerId => {
        const defaultVis = styleDefaultVisibility[layerId];
        if (map.getLayer(layerId)) {
          map.setLayoutProperty(layerId, 'visibility', defaultVis);
        }
      });
      
      // Clear all explicit layer states from hash (keep only camera position)
  const raw = window.location.hash.replace('#','');
  const parts = raw.split('/');
  const trailing = parts.slice(2);
  window.location.replace(`#${cameraStr}` + (trailing.length ? `/${trailing.join('/')}` : ''));
    });
  }

  // Add follow button listeners for followable layers
  container.querySelectorAll('button[data-follow]').forEach(btn => {
    btn.addEventListener('click', function(e) {
      e.preventDefault();
      const layerId = this.getAttribute('data-follow');
      
      // Get offset input for this layer
      const offsetInput = container.querySelector(`input[data-follow-offset="${layerId}"]`);
      const offsetValue = offsetInput ? parseInt(offsetInput.value, 10) || 0 : 0;
      
      // Parse current hash
      const hash = window.location.hash.replace('#', '');
      const [cameraStr, layersStr] = hash.split('/');
      
      if (!layersStr) {
        return;
      }
      
      // Parse layer tokens and toggle :follow for this layer
      const tokens = splitLayerTokens(layersStr).map(token => {
        // New grammar: optional paren content and optional :follow(+offset)
        const match = token.match(/^([+~])([^()]+?)(?:\(([^)]*)\))?(?::follow(\+(\d*))?)?$/);
        if (!match) return token;
        const [, sign, lname, parenContent, followFlag] = match;
        const { sourceHint, filters } = parseParenArgs(parenContent || '');
        
        if (lname === layerId) {
          // Toggle :follow for this layer
          let newToken = `${sign}${lname}`;
          const paren = buildParenArgs(sourceHint, filters);
          if (paren) newToken += paren;
          
          if (followFlag) {
            // Remove :follow
            return newToken;
          } else {
            // Add :follow (no ticker by default)
            // After hash updates, focus the offset input so user can easily add ticker
            setTimeout(() => {
              const input = container.querySelector(`input[data-follow-offset="${layerId}"]`);
              if (input) {
                input.focus();
                // Move cursor to end without selecting text
                const len = input.value.length;
                input.setSelectionRange(len, len);
              }
            }, 100);
            return newToken + ':follow';
          }
        }
        
        return token;
      });
      
      const newLayersStr = tokens.join(',');
      const raw = window.location.hash.replace('#','');
      const parts = raw.split('/');
      const trailing = parts.slice(2);
      const newHash = `#${cameraStr}/${newLayersStr}` + (trailing.length ? `/${trailing.join('/')}` : '');
      window.location.hash = newHash;
    });
  });

  // Add offset input listeners to update hash when changed
  container.querySelectorAll('input[data-follow-offset]').forEach(input => {
    const handleOffsetUpdate = function(e) {
      const layerId = this.getAttribute('data-follow-offset');
      const inputValue = this.value.trim();
      
      // Parse current hash
      const hash = window.location.hash.replace('#', '');
      const [cameraStr, layersStr] = hash.split('/');
      
      if (!layersStr) return;
      
      // Update the offset in the layer token and control ticker visibility
      const tokens = splitLayerTokens(layersStr).map(token => {
        const match = token.match(/^([+~])([^()]+?)(?:\(([^)]*)\))?(?::follow(\+(\d*))?)?$/);
        if (!match) return token;
        const [, sign, lname, parenContent, followFlag] = match;
        const { sourceHint, filters } = parseParenArgs(parenContent || '');
        const hasFollow = !!followFlag;
        
        if (lname === layerId && hasFollow) {
          let newToken = `${sign}${lname}`;
          const paren = buildParenArgs(sourceHint, filters);
          if (paren) newToken += paren;
          
          // Handle different input formats:
          // Empty string '' -> :follow (no ticker, remove +)
          // '+' -> :follow+ (ticker at 0, just +)
          // '0' or '+0' -> :follow+0 (ticker at 0, explicit)
          // '+1000' or '1000' -> :follow+1000 (ticker at 1000m)
          let followSuffix;
          if (inputValue === '') {
            // Empty: remove ticker, just follow
            followSuffix = ':follow';
            this.value = '+'; // Reset input to default
          } else if (inputValue === '+') {
            // Just +: ticker at 0, keep as :follow+
            followSuffix = ':follow+';
            this.value = '+'; // Keep as +
          } else if (inputValue === '0' || inputValue === '+0') {
            // Explicit 0: ticker at 0
            followSuffix = ':follow+0';
            this.value = '0'; // Normalize display
          } else {
            // Parse as number (remove leading + if present)
            const cleanValue = inputValue.startsWith('+') ? inputValue.slice(1) : inputValue;
            const numValue = parseInt(cleanValue, 10);
            if (!isNaN(numValue) && numValue >= 0) {
              followSuffix = `:follow+${numValue}`;
              this.value = numValue.toString(); // Normalize display
            } else {
              // Invalid input, default to +
              followSuffix = ':follow+';
              this.value = '+';
            }
          }
          return newToken + followSuffix;
        }
        
        return token;
      });
      
      const newLayersStr = tokens.join(',');
      const raw2 = window.location.hash.replace('#','');
      const parts2 = raw2.split('/');
      const trailing2 = parts2.slice(2);
      const newHash = `#${cameraStr}/${newLayersStr}` + (trailing2.length ? `/${trailing2.join('/')}` : '');
      window.location.hash = newHash;
    };
    
    // Listen for Enter key
    input.addEventListener('keydown', function(e) {
      if (e.key === 'Enter') {
        e.preventDefault();
        handleOffsetUpdate.call(this, e);
      }
    });
    
    // Also listen for change event (when user tabs away)
    input.addEventListener('change', handleOffsetUpdate);
  });

  // Add delete button listeners for dynamic layers
  container.querySelectorAll('button[data-delete]').forEach(btn => {
    btn.addEventListener('click', function(e) {
      e.preventDefault();
      const layerId = this.getAttribute('data-delete');
      // Parse current hash and remove the token for this layer
      const hash = window.location.hash.replace('#', '');
      const [cameraStr, layersStr] = hash.split('/');
      const tokens = layersStr ? splitLayerTokens(layersStr) : [];
      
      // Remove tokens that match this layerId (handles counter, sourceHint, filter, follow, etc.)
  const escapedLayerId = layerId.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  const regex = new RegExp(`^[+~]${escapedLayerId}(?:\\([^)]*\\))?(?::follow(?:\\+\\d*)?)?$`);
      const filteredTokens = tokens.filter(t => !regex.test(t));
      
      // Remove from map and state
      if (map.getLayer(layerId)) map.removeLayer(layerId);
      if (map.getSource(layerId)) map.removeSource(layerId);
      const idx = allStyleLayers.findIndex(l => l.id === layerId);
      if (idx !== -1) allStyleLayers.splice(idx, 1);
      delete styleDefaultVisibility[layerId];
      externalLayers.delete(layerId);
      followableLayers.delete(layerId);
      // Don't call createLayerControls here - let hashchange handler do it
      // Remove from hash and update URL (hashchange will refresh UI)
      const raw = window.location.hash.replace('#','');
      const parts = raw.split('/');
      const trailing = parts.slice(2);
      if (filteredTokens.length > 0) {
        window.location.replace(`#${cameraStr}/${filteredTokens.join(',')}` + (trailing.length ? `/${trailing.join('/')}` : ''));
      } else {
        window.location.replace(`#${cameraStr}` + (trailing.length ? `/${trailing.join('/')}` : ''));
      }
    });
  });
  
  // Add filter button listeners
  container.querySelectorAll('button[data-filter]').forEach(btn => {
    btn.addEventListener('click', function(e) {
      e.preventDefault();
      const layerId = this.getAttribute('data-filter');
      const filterInput = container.querySelector(`input[data-filter-input="${layerId}"]`);
      const propSelect = container.querySelector(`select[data-filter-prop="${layerId}"]`);
      
      if (filterInput) {
        // Toggle input visibility
        filterInput.classList.toggle('active');
        this.classList.toggle('active');
        
        // Focus input when shown
        if (filterInput.classList.contains('active')) {
          filterInput.focus();
        } else {
          // If hiding input and it has a value, clear the filter from hash
          if (!filterInput.value.trim()) {
            updateFilterInHash(layerId, '');
          }
        }
      }

      // Toggle and populate properties dropdown
      if (propSelect) {
        propSelect.classList.toggle('active');
        if (propSelect.classList.contains('active')) {
          populateFilterPropsDropdown(layerId, propSelect);
        }
      }
    });
  });
  
  // Add filter input listeners to update hash when changed
  container.querySelectorAll('input[data-filter-input]').forEach(input => {
    const handleFilterUpdate = function(e) {
      const layerId = this.getAttribute('data-filter-input');
      const filterExpr = this.value.trim();
      
      updateFilterInHash(layerId, filterExpr);
    };
    
    // Update on blur (when user leaves the input)
    input.addEventListener('blur', handleFilterUpdate);
    
    // Also update on Enter key
    input.addEventListener('keydown', function(e) {
      if (e.key === 'Enter') {
        e.preventDefault();
        this.blur(); // Trigger blur event which calls handleFilterUpdate
      }
    });
  });

  // Add property dropdown listeners: when a property is picked, seed the filter input
  container.querySelectorAll('select[data-filter-prop]').forEach(sel => {
    sel.addEventListener('change', function() {
      const layerId = this.getAttribute('data-filter-prop');
      const prop = this.value;
      if (!prop) return;
      const filterInput = container.querySelector(`input[data-filter-input="${layerId}"]`);
      if (filterInput) {
        // Seed with prop= (preserve any existing expression only when it starts with same prop)
        const prev = (filterInput.value || '').trim();
        if (!prev || !prev.startsWith(prop + '=')) {
          filterInput.value = `${prop}=`;
        }
        filterInput.focus();
        // Move cursor to end
        const len = filterInput.value.length;
        filterInput.setSelectionRange(len, len);
      }
    });
  });
}

// Helper function to update filter in hash
function updateFilterInHash(layerId, filterExpr) {
  // Parse current hash
  const hash = window.location.hash.replace('#', '');
  const [cameraStr, layersStr] = hash.split('/');
  
  if (!layersStr) return;
  
  // Update the filter in the layer token
  const tokens = splitLayerTokens(layersStr).map(token => {
    // New grammar: +layerName or +layerName(parenContent) with optional :follow (supports counters #N)
    const match = token.match(/^([+~])([^()]+?(?:#\d+)?)(?:\(([^)]*)\))?(?::follow(\+(\d*))?)?$/);
    if (!match) return token;
    const [, sign, lname, parenContent, followFlag] = match;
    const { sourceHint, filters } = parseParenArgs(parenContent || '');
    if (lname === layerId) {
      // Rebuild token with new or removed filter (parentheses syntax)
      let newToken = `${sign}${lname}`;
      const newFilters = (filterExpr && filterExpr.trim()) ? filterExpr.split(',').map(s => s.trim()).filter(Boolean) : [];
      const paren = buildParenArgs(sourceHint, newFilters);
      if (paren) newToken += paren;
      if (followFlag) newToken += ':follow' + followFlag;
      return newToken;
    }
    
    return token;
  });
  
  const newLayersStr = tokens.join(',');
  const raw = window.location.hash.replace('#','');
  const parts = raw.split('/');
  const trailing = parts.slice(2);
  const newHash = `#${cameraStr}/${newLayersStr}` + (trailing.length ? `/${trailing.join('/')}` : '');
  window.location.hash = newHash;
}

// Populate common properties dropdown by scanning a subset of features
function populateFilterPropsDropdown(layerId, selectEl) {
  if (!selectEl) return;
  try {
    let feats = [];
    // 1) Prefer rendered features for current viewport (works for style and external layers)
    try {
      feats = map.queryRenderedFeatures(undefined, { layers: [layerId] }) || [];
    } catch(e) { feats = []; }

    // 2) If none, try source data (GeoJSON external layers)
    if (!feats.length) {
      const src = map.getSource(layerId);
      if (src && src._data && src._data.features) {
        feats = src._data.features.map(f => ({ properties: f.properties || {} }));
      }
    }

    // 3) If still none, try vector tile cache via source/source-layer
    if (!feats.length) {
      const styleLayer = (map.getStyle().layers || []).find(l => l.id === layerId);
      if (styleLayer && styleLayer.source && styleLayer['source-layer']) {
        try {
          const srcFeats = map.querySourceFeatures(styleLayer.source, { sourceLayer: styleLayer['source-layer'] }) || [];
          feats = srcFeats.map(f => ({ properties: f.properties || {} }));
        } catch(e) {}
      }
    }

    const sampleSize = Math.min(100, feats.length);
    const propsCount = {};
    for (let i = 0; i < sampleSize; i++) {
      const f = feats[i];
      if (!f || !f.properties) continue;
      Object.keys(f.properties).forEach(k => {
        // Skip geometry-related duplicates and empty keys
        if (!k) return;
        propsCount[k] = (propsCount[k] || 0) + 1;
      });
    }
    const commonProps = Object.entries(propsCount)
      .filter(([, count]) => count > 0)
      .sort((a, b) => b[1] - a[1])
      .map(([key]) => key)
      .slice(0, 30); // limit
    // Preserve first placeholder option
    const placeholder = selectEl.querySelector('option[value=""]');
    selectEl.innerHTML = '';
    if (placeholder) selectEl.appendChild(placeholder);
    else {
      const ph = document.createElement('option');
      ph.value = '';
      ph.textContent = 'â€” property â€”';
      selectEl.appendChild(ph);
    }
    commonProps.forEach(prop => {
      const opt = document.createElement('option');
      opt.value = prop;
      opt.textContent = prop;
      selectEl.appendChild(opt);
    });
  } catch(e) {
      }
}

const { camera, layers } = parseHash();

// Solution 1: Force Device Pixel Ratio in Mapbox
// Prevents mobile scaling issues where map appears zoomed out with tiny labels
if (window.devicePixelRatio > 1) {
  const mapContainer = document.getElementById('map');
  if (mapContainer) {
    mapContainer.style.zoom = '100%';
    mapContainer.style.transform = 'scale(1)';
  }
}

const map = new mapboxgl.Map({
  container: 'map',
  style,
  center: camera.center,
  zoom: camera.zoom,
  bearing: camera.bearing,
  pitch: camera.pitch,
  interactive: true,  // Will be disabled if /static flag is present
  pixelRatio: window.devicePixelRatio || 1  // Force correct pixel ratio for mobile
});
// Expose map globally for add-layer UI logic
window.map = map;

// Solution 5: Force immediate map resize with native resolution on mobile
// This addresses portrait mode scaling where labels appear tiny
if (window.innerWidth <= 1000) {
  // On mobile, force immediate resize before everything settles
  const forceMapResize = () => {
    if (map) {
      map.resize();
      // Force canvas to use device pixel ratio correctly
      const canvas = map.getCanvas();
      if (canvas) {
        canvas.style.imageRendering = 'crisp-edges';
        canvas.width = window.innerWidth * window.devicePixelRatio;
        canvas.height = window.innerHeight * window.devicePixelRatio;
        canvas.style.width = window.innerWidth + 'px';
        canvas.style.height = window.innerHeight + 'px';
      }
          }
  };
  
  // Aggressive: resize multiple times as page loads
  forceMapResize();
  setTimeout(forceMapResize, 50);
  setTimeout(forceMapResize, 100);
  setTimeout(forceMapResize, 200);
}

map.on('load', () => {
  // Immediately resize map on load (critical for portrait mode on mobile)
  if (window.innerWidth <= 1000) {
    map.resize();
      }
  
  // After all layers are loaded, if :follow is present in the hash, trigger follow logic directly (no hashchange event)
  const { camera: camInit, layers: layersInit, dynamicGeojsonToLoad: dynInit, followId: followInit, followOffset: followOffsetInit, showTicker: showTickerInit, followHidden: followHiddenInit, showMapUI, isStatic } = parseHash();
  if (followInit) {
    // Only start follow if not already running (avoid double-trigger)
    if (!window._isFollowStarted) {
      window._isFollowStarted = true;
      const tryStartFollow = () => {
        const src = map.getSource(followInit);
        if (!(src && src._data && src._data.features)) {
          setTimeout(tryStartFollow, 100);
          return;
        }
        // Extract coords
        let coords = [];
        src._data.features.forEach(f => {
          if (!f.geometry) return;
          if (f.geometry.type === 'LineString') coords = coords.concat(f.geometry.coordinates);
          if (f.geometry.type === 'Polygon') coords = coords.concat(f.geometry.coordinates[0]);
          if (f.geometry.type === 'MultiLineString') coords = coords.concat(...f.geometry.coordinates);
          if (f.geometry.type === 'MultiPolygon') coords = coords.concat(...f.geometry.coordinates.map(ring => ring[0]));
        });
        if (coords.length > 1) {
          followPathWithFreeCamera(map, coords, () => {
            // On completion: freeze current camera into the hash and remove :follow to avoid jumping back
            const c = map.getCenter();
            const z = map.getZoom().toFixed(2);
            const b = map.getBearing().toFixed(1);
            const p = map.getPitch().toFixed(1);
            const cameraStr = `${c.lat.toFixed(5)},${c.lng.toFixed(5)},${z},${b},${p}`;
            let hash = window.location.hash.replace('#', '');
            const parts = hash.split('/');
            let layersStr = parts[1] || '';
            if (layersStr) {
              // Remove :follow or :follow+offset or :follow+ allowing optional (source) part
              layersStr = layersStr.replace(new RegExp(`([+~]${followInit})(?:\\([^)]+\\))?(?::follow(?:\\+\\d*)?)`), '$1');
            }
            const trailing = parts.slice(2).filter(Boolean).join('/');
            const newHash = `#${cameraStr}` + (layersStr ? `/${layersStr}` : '') + (trailing ? `/${trailing}` : '');
            window._suppressNextFollowCancel = true;
            window.location.replace(newHash);
            window._isFollowStarted = false;
          }, followInit, followOffsetInit || 0, showTickerInit, followHiddenInit);
        }
      };
      setTimeout(tryStartFollow, 0);
    }
  }
  // Get all layers from the style
  allStyleLayers = map.getStyle().layers.map(l => ({ id: l.id }));
  window.allStyleLayers = allStyleLayers; // Keep window reference in sync
  
  // Store the style default visibility for each layer
  allStyleLayers.forEach(layer => {
    if (map.getLayer(layer.id)) {
      const styleLayer = map.getStyle().layers.find(l => l.id === layer.id);
      let vis = 'visible';
      if (styleLayer && styleLayer.layout && typeof styleLayer.layout.visibility !== 'undefined') {
        vis = styleLayer.layout.visibility;
      }
      styleDefaultVisibility[layer.id] = vis;
      // Store default filter for restoration
      try {
        styleDefaultFilter[layer.id] = (styleLayer && typeof styleLayer.filter !== 'undefined') ? styleLayer.filter : null;
      } catch(e) {
        styleDefaultFilter[layer.id] = null;
      }
    }
  });
  // Apply layer visibility from hash on initial load
  const { layers: hashLayers } = parseHash();
  const hashStr = window.location.hash.replace('#', '');
  const [, layersStr] = hashStr.split('/');
  if (layersStr) {
    const explicitState = {};
    splitLayerTokens(layersStr).forEach(token => {
  const match = token.match(/^([+~])([^:(]+)(?:\(([^)]*)\))?(?::follow)?$/);
      if (!match) return;
      const [, sign, lname] = match;
      explicitState[lname] = sign;
    });
    
    // Helper: Fade wayback layer in/out with opacity animation
    function fadeWaybackLayer(layerId, targetOpacity, duration = 500) {
      if (!map.getLayer(layerId)) return;
      
      const currentOpacity = map.getPaintProperty(layerId, 'raster-opacity') || 0;
      const startTime = performance.now();
      
      function animate(currentTime) {
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / duration, 1);
        
        // Ease-in-out
        const eased = progress < 0.5 
          ? 2 * progress * progress 
          : 1 - Math.pow(-2 * progress + 2, 2) / 2;
        
        const opacity = currentOpacity + (targetOpacity - currentOpacity) * eased;
        
        if (map.getLayer(layerId)) {
          map.setPaintProperty(layerId, 'raster-opacity', opacity);
        }
        
        if (progress < 1) {
          requestAnimationFrame(animate);
        } else {
          // After fade out completes, hide the layer
          if (targetOpacity === 0 && map.getLayer(layerId)) {
            map.setLayoutProperty(layerId, 'visibility', 'none');
          }
        }
      }
      
      // If fading in, make visible first
      if (targetOpacity > 0 && map.getLayoutProperty(layerId, 'visibility') !== 'visible') {
        map.setLayoutProperty(layerId, 'visibility', 'visible');
      }
      
      requestAnimationFrame(animate);
    }
    
    // Apply visibility to all layers based on hash
    allStyleLayers.forEach(layer => {
      const id = layer.id;
      const explicit = explicitState[id];
      const defaultVis = styleDefaultVisibility[id] || 'visible';
      const isWaybackLayer = /^wayback:\d{8}$/.test(id);
      
      if (explicit === '+') {
        // Explicitly shown in hash
        if (map.getLayer(id) && map.getLayoutProperty(id, 'visibility') !== 'visible') {
          if (isWaybackLayer) {
            fadeWaybackLayer(id, 1, 500);
          } else {
            map.setLayoutProperty(id, 'visibility', 'visible');
          }
        }
      } else if (explicit === '~') {
        // Explicitly hidden in hash
        if (map.getLayer(id) && map.getLayoutProperty(id, 'visibility') !== 'none') {
          if (isWaybackLayer) {
            fadeWaybackLayer(id, 0, 500);
          } else {
            map.setLayoutProperty(id, 'visibility', 'none');
          }
        }
      }
      // If not mentioned in hash, keep style default (don't change)
    });
  }
  // If no layers specified in hash, keep all at their style defaults (don't change)
  
  // Update the toggle list to reflect current visibility
  createLayerControls(map, allStyleLayers.filter(l => map.getLayer(l.id) && map.getLayoutProperty(l.id, 'visibility') === 'visible').map(l => l.id));

  // Inject map UI controls if flag present
  if (showMapUI) {
    ensureMapUIControls();
  }
  
  // Disable map interactions if /static flag is present
  if (isStatic) {
    map.boxZoom.disable();
    map.scrollZoom.disable();
    map.dragPan.disable();
    map.dragRotate.disable();
    map.keyboard.disable();
    map.doubleClickZoom.disable();
    map.touchZoomRotate.disable();
  }
  
  // Re-apply camera from hash after style load to ensure bearing/pitch/zoom are honored
  try {
    const { camera: parsedCamera } = parseHash();
    if (parsedCamera) {
      map.jumpTo({
        center: parsedCamera.center,
        zoom: parsedCamera.zoom + (window.innerWidth <= 1000 ? -1 : 0),
        bearing: parsedCamera.bearing,
        pitch: parsedCamera.pitch,
        animate: false
      });
    }
  } catch (e) {
      }
  // Load any dynamic layers requested in the hash
  const { dynamicGeojsonToLoad, layers: layersOn } = parseHash();
  if (dynamicGeojsonToLoad && dynamicGeojsonToLoad.length) {
    dynamicGeojsonToLoad.forEach(entry => {
      let name = null, sourceHint = null, filter = null, isWayback = false, waybackDate = null;
      if (typeof entry === 'string') {
        name = entry;
      } else if (entry && typeof entry === 'object') {
        name = entry.name;
        sourceHint = entry.sourceHint;
        filter = entry.filter;
        isWayback = entry.isWayback || false;
        waybackDate = entry.waybackDate || null;
      }
      if (name) {
        const visibility = (layersOn && layersOn.includes(name)) ? 'visible' : 'none';
        if (isWayback && waybackDate) {
          // Load ESRI Wayback layer
          loadWaybackLayer(waybackDate, { visibility, sourceHint, filter });
        } else {
          // Load GeoJSON/CSV layer
          // Pass the layer name without forcing an extension - loadAndAddOrReplaceGeoJSON will try .geojson then .csv
          loadAndAddOrReplaceGeoJSON(name, { visibility, sourceHint, filter });
        }
      }
    });
  }

  // Do NOT trigger hashchange handler here; let user navigation or manual hash changes do it.
});

// Update hash on camera move
map.on('moveend', () => {
  // Don't update hash if we just applied mobile zoom adjustment (prevents loop)
  if (window._skipNextHashUpdate) {
    window._skipNextHashUpdate = false;
    return;
  }
  // During free-camera follow animation, don't write to the hash â€”
  // it can re-introduce :follow and cause unintended restarts.
  if (isFreeCameraAnimating) return;
  // Also avoid writing while :follow is present in the hash for any layer.
  try {
    const rawHash = window.location.hash.replace('#','');
    const parts = rawHash.split('/');
    const layersStr = parts[1] || '';
  if (splitLayerTokens(layersStr).some(t => /:follow(?:\+\d+)?$/.test(t))) return;
  } catch(e){}
  // Only update camera part of hash, preserve layer toggles
  updateHash(map, []);
});

// Update distance ticker position on any map move (pan, zoom, rotate)
map.on('move', () => {
  const ticker = document.getElementById('distance-ticker');
  if (ticker && ticker.classList.contains('active') && !isFreeCameraAnimating) {
    // If ticker has stored coordinates, update its screen position
    const lng = parseFloat(ticker.dataset.lng);
    const lat = parseFloat(ticker.dataset.lat);
    if (!isNaN(lng) && !isNaN(lat)) {
      const tipPx = map.project({lng, lat});
      ticker.style.left = tipPx.x + 'px';
      ticker.style.top = tipPx.y + 'px';
    }
  }
});

// Listen for hash changes (external navigation)
let isFreeCameraAnimating = false;
let pendingHashUpdate = null;
function followPathWithFreeCamera(map, coords, onComplete, layerId, startOffset = 0, showTicker = false, keepLayerHidden = false) {
  // Periodic check for :follow in the hash
  // Escape layerId for regex
  const safeLayerId = layerId.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  let followCheckInterval = setInterval(() => {
    const rawHash = window.location.hash;
    const hash = rawHash.replace('#', '');
    const [, layersStr] = hash.split('/');
    let stillFollowing = false;
    if (layersStr) {
      const tokens = splitLayerTokens(layersStr);
      // Pattern must account for optional (sourceHint) after layer name and optional ticker flag: +layerId(source):follow or :follow+ or :follow+number
      stillFollowing = tokens.some(token => token.match(new RegExp(`^[+~]${safeLayerId}(?:\\([^)]+\\))?:follow(?:\\+\\d*)?$`)));
    }
    if (!stillFollowing) {
      if (window._follow && typeof window._follow.cancel === 'function') {
        window._follow.cancel();
      } else {
        // Fallback cleanup
        isFreeCameraAnimating = false;
        clearInterval(followCheckInterval);
        try {
          if (layerId && originalData) {
            const src = map.getSource(layerId);
            if (src && src.setData) src.setData(originalData);
          }
        } catch(e) {}
      }
    }
  }, 1000);
  isFreeCameraAnimating = true;
  
  // Capture original visibility and only force-visible if not instructed to keep hidden
  let originalVisibility = null;
  if (layerId && map.getLayer(layerId)) {
    try { originalVisibility = map.getLayoutProperty(layerId, 'visibility'); } catch(e) { originalVisibility = null; }
    if (!keepLayerHidden) {
      map.setLayoutProperty(layerId, 'visibility', 'visible');
    }
  }
  
  // Expose a global cancel to allow immediate stop on hash changes
  if (!window._follow) window._follow = {};
  window._follow.layerId = layerId;
  window._follow.checkIntervalId = followCheckInterval;
  window._follow.cancel = function() {
    try { if (window._follow.checkIntervalId) clearInterval(window._follow.checkIntervalId); } catch(e){}
    isFreeCameraAnimating = false;
    try {
      if (layerId && originalData) {
        const src = map.getSource(layerId);
        if (src && src.setData) src.setData(originalData);
      }
    } catch(e) {}
    // Restore original visibility if we changed it
    try {
      if (layerId && originalVisibility !== null && !keepLayerHidden) {
        map.setLayoutProperty(layerId, 'visibility', originalVisibility);
      }
    } catch(e) {}
    // Hide distance ticker
    const ticker = document.getElementById('distance-ticker');
    if (ticker) ticker.classList.remove('active');
    // Do not modify hash or call onComplete here; caller controls next steps
    // Cleanup handle
    window._follow = null;
  };
  // Calculate total distance for constant speed
  function getDistance(a, b) {
    const R = 6371000;
    const toRad = Math.PI / 180;
    const dLat = (b[1] - a[1]) * toRad;
    const dLng = (b[0] - a[0]) * toRad;
    const lat1 = a[1] * toRad;
    const lat2 = b[1] * toRad;
    const aVal = Math.sin(dLat/2) * Math.sin(dLat/2) + Math.cos(lat1) * Math.cos(lat2) * Math.sin(dLng/2) * Math.sin(dLng/2);
    const c = 2 * Math.atan2(Math.sqrt(aVal), Math.sqrt(1-aVal));
    return R * c;
  }
  let totalDist = 0;
  for (let j = 1; j < coords.length; j++) totalDist += getDistance(coords[j-1], coords[j]);
  const duration = Math.max(2000, totalDist * 2); // ms, 2ms per meter, min 2s
  let startTime = null;
  let originalData = null;
  let representativeProps = {};
  if (layerId) {
    const src = map.getSource(layerId);
    if (src && src._data) originalData = JSON.parse(JSON.stringify(src._data));
    // Capture representative properties from the first path-like feature so
    // filters copied from a sourceHint (e.g., class/type filters) continue to match
    try {
      const feats = (originalData && originalData.features) ? originalData.features : [];
      const rep = feats.find(f => f && f.geometry && (
        f.geometry.type === 'LineString' || f.geometry.type === 'MultiLineString' ||
        f.geometry.type === 'Polygon' || f.geometry.type === 'MultiPolygon'
      ));
      if (rep && rep.properties && typeof rep.properties === 'object') {
        representativeProps = JSON.parse(JSON.stringify(rep.properties));
      }
    } catch(e) { representativeProps = {}; }
  }
  // Store original data reference for external cancel
  if (window._follow) window._follow.originalData = originalData;
  
  // Show distance ticker only if showTicker flag is true
  const ticker = document.getElementById('distance-ticker');
  const totalDistKm = totalDist / 1000;
  const startOffsetKm = startOffset / 1000;
  if (showTicker && ticker && totalDistKm > 0) {
    ticker.classList.add('active');
    ticker.textContent = startOffsetKm.toFixed(1) + ' km';
  } else {
  }
  function getBearing(from, to) {
    // Calculate bearing in radians from point 'from' to point 'to'
    const rad = Math.PI / 180;
    const lat1 = from[1] * rad;
    const lat2 = to[1] * rad;
    const dLon = (to[0] - from[0]) * rad;
    const y = Math.sin(dLon) * Math.cos(lat2);
    const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);
    let brng = Math.atan2(y, x);
    return brng;
  }

  function interpolateLine(coords, t) {
    // t in [0,1], returns the point at t along the line
    let dist = 0, segStart = coords[0], segEnd = coords[1], segIdx = 1;
    let total = 0;
    for (let j = 1; j < coords.length; j++) total += getDistance(coords[j-1], coords[j]);
    let target = t * total;
    for (let j = 1; j < coords.length; j++) {
      let segLen = getDistance(coords[j-1], coords[j]);
      if (dist + segLen >= target) {
        segStart = coords[j-1];
        segEnd = coords[j];
        segIdx = j;
        break;
      }
      dist += segLen;
    }
    let segT = (target - dist) / getDistance(segStart, segEnd);
    return [
      segStart[0] + (segEnd[0] - segStart[0]) * segT,
      segStart[1] + (segEnd[1] - segStart[1]) * segT
    ];
  }

  // Easing function (easeInOutQuad)
  function easeInOutQuad(x) {
    return x < 0.5 ? 2 * x * x : 1 - Math.pow(-2 * x + 2, 2) / 2;
  }

  // Before animation: capture the current camera state at the moment follow starts
  const camBearing = map.getBearing();
  const camPitch = map.getPitch();
  const camZoom = map.getZoom();
  // Get current map center and path start in screen (pixel) coordinates
  const mapCenter = map.getCenter();
  const mapCenterPx = map.project(mapCenter);
  const pathStartPx = map.project({lng: coords[0][0], lat: coords[0][1]});
  // Offset vector in pixels from map center to path start
  const offsetPx = { x: pathStartPx.x - mapCenterPx.x, y: pathStartPx.y - mapCenterPx.y };
  // Camera state for smooth following
  let currentCameraCenter = mapCenter;
  let useOffset = Math.abs(offsetPx.x) > 1e-2 || Math.abs(offsetPx.y) > 1e-2;

  function animate(ts) {
    if (!isFreeCameraAnimating) {
      return;
    }
    // (Hash :follow check now handled by periodic interval)
    // Cleanup interval on animation end
    const originalOnComplete = onComplete;
    onComplete = function() {
      clearInterval(followCheckInterval);
      if (typeof originalOnComplete === 'function') originalOnComplete();
    };
    if (!startTime) startTime = ts;
    let elapsed = ts - startTime;
    let t = Math.min(1, elapsed / duration);
    let tip = interpolateLine(coords, t);
    if (layerId) {
      const src = map.getSource(layerId);
      if (src) {
        // Find the last full point before tip
        let dist = 0, lastIdx = 0, total = 0;
        for (let j = 1; j < coords.length; j++) total += getDistance(coords[j-1], coords[j]);
        let target = t * total;
        for (let j = 1; j < coords.length; j++) {
          let segLen = getDistance(coords[j-1], coords[j]);
          if (dist + segLen >= target) {
            lastIdx = j-1;
            break;
          }
          dist += segLen;
        }
        const partialCoords = coords.slice(0, lastIdx+1).concat([tip]);
        const partialLine = {
          type: 'FeatureCollection',
          features: [
            {
              type: 'Feature',
              geometry: {
                type: 'LineString',
                coordinates: partialCoords
              },
              // Preserve representative properties so style filters keep matching while animating
              properties: representativeProps
            }
          ]
        };
        src.setData(partialLine);
      }
    }
    let targetCameraCenter;
    if (useOffset) {
      // Always keep the same pixel offset from tip as original map center to path start
      const tipPx = map.project({lng: tip[0], lat: tip[1]});
      const desiredCenterPx = { x: tipPx.x - offsetPx.x, y: tipPx.y - offsetPx.y };
      targetCameraCenter = map.unproject(desiredCenterPx);
    } else {
      // Move camera center along the path (classic follow)
      targetCameraCenter = {lng: tip[0], lat: tip[1]};
    }
    // Smoothly ease the camera center
    const ease = 0.15;
    currentCameraCenter = {
      lng: currentCameraCenter.lng + (targetCameraCenter.lng - currentCameraCenter.lng) * ease,
      lat: currentCameraCenter.lat + (targetCameraCenter.lat - currentCameraCenter.lat) * ease
    };
    // Set camera to always keep the same bearing, pitch, and zoom as at start
    map.jumpTo({
      center: currentCameraCenter,
      zoom: camZoom,
      bearing: camBearing,
      pitch: camPitch,
      animate: false
    });
    
    // Update distance ticker position and value
    if (ticker && ticker.classList.contains('active')) {
      const tipPx = map.project({lng: tip[0], lat: tip[1]});
      ticker.style.left = tipPx.x + 'px';
      ticker.style.top = tipPx.y + 'px';
      const currentDistKm = startOffsetKm + (t * totalDistKm);
      ticker.textContent = currentDistKm.toFixed(1) + ' km';
      // Store the current tip coordinates for post-animation updates
      ticker.dataset.lng = tip[0];
      ticker.dataset.lat = tip[1];
    }
    
    if (t < 1) {
      requestAnimationFrame(animate);
    } else {
      if (layerId && originalData) {
        const src = map.getSource(layerId);
        if (src) src.setData(originalData);
      }
      // Restore original visibility if we changed it (only when not keeping hidden)
      try {
        if (layerId && originalVisibility !== null && !keepLayerHidden) {
          map.setLayoutProperty(layerId, 'visibility', originalVisibility);
        }
      } catch(e) {}
      isFreeCameraAnimating = false;
      // Keep ticker visible on completion (don't hide it)
      // Store final position in data attributes so map move handler can update it
      if (ticker && ticker.classList.contains('active')) {
        ticker.dataset.lng = tip[0];
        ticker.dataset.lat = tip[1];
      }
      // if (ticker) ticker.classList.remove('active');
      try { if (followCheckInterval) clearInterval(followCheckInterval); } catch(e){}
      if (typeof onComplete === 'function') onComplete();
      window._follow = null;
    }
  }
  requestAnimationFrame(animate);
}

window.addEventListener('hashchange', () => {
  // Invalidate hash parse cache on hashchange
  cachedHashString = '';
  cachedHashState = null;
  
  // Prevent double follow on initial load
  if (window._suppressNextFollowCancel) {
    window._suppressNextFollowCancel = false;
    return;
  }
  if (!window._lastHashState) window._lastHashState = '';
  const currentHash = window.location.hash;
  if (window._lastHashState === currentHash) return;
  window._lastHashState = currentHash;
  
  // Reset mobile zoom adjustment flag for this new hash
  window._mobileZoomAdjusted = false;

  // Always cancel any running follow immediately so we can apply new state
  if (isFreeCameraAnimating) {
    try { if (window._follow && typeof window._follow.cancel === 'function') window._follow.cancel(); }
    catch(e) { isFreeCameraAnimating = false; }
    window._isFollowStarted = false; // Ensure new hash is processed after cancel
  }
  // Always reset follow started before processing new hash
  window._isFollowStarted = false;

  // ...existing code...

  const { camera, layers, dynamicGeojsonToLoad, followId, followOffset, showTicker, followHidden, showMapUI, isStatic } = parseHash();

  // Apply layer visibility from hash for all existing layers
  const hashStr = window.location.hash.replace('#', '');
  const [, layersStr] = hashStr.split('/');
  if (layersStr) {
    const explicitState = {};
    const filterState = {}; // layerId -> filter array
    const filterExprState = {}; // layerId -> original expr (string)
    splitLayerTokens(layersStr).forEach(token => {
      // Updated regex: handle layer names with colons and single parentheses group
      const match = token.match(/^([+~])([^()]+?)(?:#\d+)?(?:\(([^)]*)\))?(?::follow(?:\+(\d*))?)?$/);
      if (!match) return;
      const [, sign, lname, parenContent] = match;
      explicitState[lname] = sign;
      const { filters } = parseParenArgs(parenContent || '');
      const filt = combineFilterExprsToMapbox(filters);
      if (filt) filterState[lname] = filt;
      if (filters && filters.length) filterExprState[lname] = filters.join(',');
    });
    
    // Apply visibility to all existing style layers based on hash
    allStyleLayers.forEach(layer => {
      const id = layer.id;
      const explicit = explicitState[id];
      const defaultVis = styleDefaultVisibility[id] || 'visible';
      if (map.getLayer(id)) {
        if (explicit === '+') {
          // Explicitly shown in hash
          if (map.getLayoutProperty(id, 'visibility') !== 'visible') {
            map.setLayoutProperty(id, 'visibility', 'visible');
          }
        } else if (explicit === '~') {
          // Explicitly hidden in hash
          if (map.getLayoutProperty(id, 'visibility') !== 'none') {
            map.setLayoutProperty(id, 'visibility', 'none');
          }
        } else {
          // Not mentioned in hash
          if (externalLayers.has(id)) {
            // External layers not in hash should be removed entirely
            if (!explicitState[id]) {

              if (map.getLayer(id)) map.removeLayer(id);
              if (map.getSource(id)) map.removeSource(id);
              const idx = allStyleLayers.findIndex(l => l.id === id);
              if (idx !== -1) allStyleLayers.splice(idx, 1);
              delete styleDefaultVisibility[id];
              externalLayers.delete(id);
              followableLayers.delete(id);
            }
          } else {
            // Style layers - restore to style default
            if (map.getLayoutProperty(id, 'visibility') !== defaultVis) {
              map.setLayoutProperty(id, 'visibility', defaultVis);
            }
            // Always reset filter to style default if not mentioned in hash
            if (layerSupportsFilter(id)) {
              const def = (id in styleDefaultFilter) ? styleDefaultFilter[id] : null;
              try { map.setFilter(id, def); } catch(e) { /* ignore unsupported */ }
            }
          }
        }
      }
    });

    // Apply filters only to external layers according to hash
    // Mapbox style layers maintain their default filters and cannot be modified via hash
    try {
      // Check if style is loaded before applying filters
      if (map.isStyleLoaded()) {
        const allMapLayers = map.getStyle().layers || [];
        allMapLayers.forEach(l => {
          const id = l.id;
          if (!layerSupportsFilter(id)) return;
          
          // Only apply filter modifications to external layers
          if (externalLayers.has(id)) {
            const filterForLayer = filterState[id];
            if (typeof filterForLayer !== 'undefined') {
              try { map.setFilter(id, filterForLayer); } catch(e) { /* ignore unsupported */ }
            } else {
              // Restore default for external layer
              const def = (id in styleDefaultFilter) ? styleDefaultFilter[id] : null;
              try { map.setFilter(id, def); } catch(e) { /* ignore unsupported */ }
            }
          }
          // Style layers always maintain their default filter (no hash modification)
        });
      } else {
        // Style not loaded yet, skipping filter application
      }
    } catch(e) { /* ignore filter errors */ }
  } else {
    // No layers specified in hash - restore all layers to their style defaults
    allStyleLayers.forEach(layer => {
      if (map.getLayer(layer.id)) {
        if (externalLayers.has(layer.id)) {
          // Hide external layers when no layers in hash
          if (map.getLayoutProperty(layer.id, 'visibility') !== 'none') {
            map.setLayoutProperty(layer.id, 'visibility', 'none');
          }
        } else {
          // Restore style layers to defaults
          const defaultVis = styleDefaultVisibility[layer.id] || 'visible';
          if (map.getLayoutProperty(layer.id, 'visibility') !== defaultVis) {
            map.setLayoutProperty(layer.id, 'visibility', defaultVis);
          }
        }
      }
    });
    // Restore filters to defaults for external layers when no layer tokens exist
    // Mapbox style layers always maintain their default filters
    try {
      const allMapLayers = map.getStyle().layers || [];
      allMapLayers.forEach(l => {
        const id = l.id;
        if (!layerSupportsFilter(id)) return;
        
        // Only restore filters for external layers
        if (externalLayers.has(id)) {
          const def = (id in styleDefaultFilter) ? styleDefaultFilter[id] : null;
          try { map.setFilter(id, def); } catch(e) { /* ignore unsupported */ }
        }
        // Style layers always keep their default filter
      });
    } catch(e) {}
  }

  // Update layer controls to reflect current state (after any removals)
  createLayerControls(map, allStyleLayers.filter(l => map.getLayer(l.id) && map.getLayoutProperty(l.id, 'visibility') === 'visible').map(l => l.id));

  // Toggle map UI controls based on flag
  if (showMapUI) ensureMapUIControls();
  else removeMapUIControls();

  // Toggle map interactions based on /static flag
  if (isStatic) {
    map.boxZoom.disable();
    map.scrollZoom.disable();
    map.dragPan.disable();
    map.dragRotate.disable();
    map.keyboard.disable();
    map.doubleClickZoom.disable();
    map.touchZoomRotate.disable();
  } else {
    map.boxZoom.enable();
    map.scrollZoom.enable();
    map.dragPan.enable();
    map.dragRotate.enable();
    map.keyboard.enable();
    map.doubleClickZoom.enable();
    map.touchZoomRotate.enable();
  }

  // Load dynamic layers as needed (GeoJSON/CSV, Sentinel-2, or Wayback)
  if (dynamicGeojsonToLoad && dynamicGeojsonToLoad.length) {
    const layersOn = layers || [];
    // Extract all wayback layer IDs in hash order (for correct positioning)
    const waybackLayersInHashOrder = dynamicGeojsonToLoad
      .filter(entry => entry && entry.isWayback)
      .map(entry => `wayback:${entry.waybackDate}`);
    
        
    // If multiple wayback layers exist, remove all existing ones first to ensure clean repositioning
    if (waybackLayersInHashOrder.length > 1) {
            waybackLayersInHashOrder.forEach(layerId => {
        if (map.getLayer(layerId)) {
          // Store visibility state before removal
          const wasVisible = map.getLayoutProperty(layerId, 'visibility') === 'visible';
          if (!layerId.startsWith('_wayback_state_')) {
            window['_wayback_state_' + layerId] = wasVisible;
          }
                    map.removeLayer(layerId);
        }
        if (map.getSource(layerId)) {
          map.removeSource(layerId);
        }
      });
    }
    
    dynamicGeojsonToLoad.forEach(entry => {
      let name = null, sourceHint = null, filter = null, isWayback = false, waybackDate = null;
      if (typeof entry === 'string') {
        name = entry;
      } else if (entry && typeof entry === 'object') {
        name = entry.name;
        sourceHint = entry.sourceHint;
        filter = entry.filter;
        isWayback = entry.isWayback || false;
        waybackDate = entry.waybackDate || null;
      }
      if (!name) return;
      
      // Check if layer already exists (after potential removal above)
      const layerExists = map.getLayer(name);
      // If this layer will be followed, load it hidden initially - the follow animation will show it
  const isFollowLayer = (name === followId);
  let visibility = isFollowLayer ? 'none' : (layersOn.includes(name) ? 'visible' : 'none');
      
      // Restore visibility for wayback layers that were visible before removal
      if (isWayback && window['_wayback_state_' + name]) {
        visibility = 'visible';
        delete window['_wayback_state_' + name];
      }
      
      if (isWayback && waybackDate) {
        // ESRI Wayback layer - always load if multiple wayback layers in hash
        if (!layerExists || waybackLayersInHashOrder.length > 1) {
                    loadWaybackLayer(waybackDate, { visibility, sourceHint, filter, waybackLayersInHashOrder });
        } else if (sourceHint) {
          loadWaybackLayer(waybackDate, { visibility, sourceHint, filter, waybackLayersInHashOrder });
        }
      } else {
        // GeoJSON/CSV layer
        if (!layerExists) {
          loadAndAddOrReplaceGeoJSON(name + '.geojson', { visibility, sourceHint, filter });
        } else if (sourceHint || filter) {
          loadAndAddOrReplaceGeoJSON(name + '.geojson', { visibility, sourceHint, filter });
        }
      }
    });
  }

  // 5. Fly to hash geolocation (with animation), then start follow only after fly completes
  const flyOpts = {
    center: [camera.center[0], camera.center[1]],
    zoom: camera.zoom + (window.innerWidth <= 1000 && !window._mobileZoomAdjusted ? -1 : 0),
    bearing: camera.bearing,
    pitch: camera.pitch,
    duration: 1200
  };
  
  // Mark that we've applied the mobile zoom adjustment for this hash
  if (window.innerWidth <= 1000 && !window._mobileZoomAdjusted) {
    window._mobileZoomAdjusted = true;
    window._skipNextHashUpdate = true; // Prevent moveend from updating hash with new zoom
  }

  // Always start follow if followId is present after camera update
  map.flyTo(flyOpts);
  if (followId) {
    // Wait for both flyTo and source readiness before starting follow
    let followReady = false;
    let flyDone = false;
    const tryStartFollow = () => {
      if (!flyDone || !followReady) return;
      const src = map.getSource(followId);
      if (!(src && src._data && src._data.features)) {
        return;
      }
      // Extract coords
      let coords = [];
      let geomTypes = [];
      src._data.features.forEach(f => {
        if (!f.geometry) return;
        geomTypes.push(f.geometry.type);
        if (f.geometry.type === 'LineString') coords = coords.concat(f.geometry.coordinates);
        if (f.geometry.type === 'Polygon') coords = coords.concat(f.geometry.coordinates[0]);
        if (f.geometry.type === 'MultiLineString') coords = coords.concat(...f.geometry.coordinates);
        if (f.geometry.type === 'MultiPolygon') coords = coords.concat(...f.geometry.coordinates.map(ring => ring[0]));
      });
      if (coords.length > 1) {
        window._isFollowStarted = true;
  followPathWithFreeCamera(map, coords, () => {
          // On completion: freeze current camera into the hash and remove :follow to avoid jumping back
          const c = map.getCenter();
          const z = map.getZoom().toFixed(2);
          const b = map.getBearing().toFixed(1);
          const p = map.getPitch().toFixed(1);
          const cameraStr = `${c.lat.toFixed(5)},${c.lng.toFixed(5)},${z},${b},${p}`;
          let hash = window.location.hash.replace('#', '');
          const parts = hash.split('/');
          let layersStr = parts[1] || '';
          if (layersStr) {
            // Remove :follow or :follow+offset, allowing optional (source) part
            layersStr = layersStr.replace(new RegExp(`([+~]${followId})(?:\\([^)]+\\))?(?::follow(?:\\+\\d+)?)`), '$1');
          }
          const trailing = parts.slice(2).filter(Boolean).join('/');
          const newHash = `#${cameraStr}` + (layersStr ? `/${layersStr}` : '') + (trailing ? `/${trailing}` : '');
          window._suppressNextFollowCancel = true;
          window.location.replace(newHash);
          window._isFollowStarted = false;
  }, followId, followOffset || 0, showTicker, followHidden);
      } else {
      }
    };
    // Listen for flyend
    map.once('moveend', () => {
      flyDone = true;
      tryStartFollow();
    });
    // Listen for source readiness
    const checkSource = () => {
      const src = map.getSource(followId);
      if (src && src._data && src._data.features) {
        followReady = true;
        tryStartFollow();
        return true;
      }
      return false;
    };
    if (!checkSource()) {
      const onSourceData = (e) => {
        if (e.sourceId === followId && checkSource()) {
          map.off('sourcedata', onSourceData);
        }
      };
      map.on('sourcedata', onSourceData);
    } else {
      followReady = true;
      tryStartFollow();
    }
  } else {
  }
});

// Solution 3: Add Map Resize Observer for orientation changes
// This ensures the map properly recalculates when device rotates or container resizes
const resizeObserver = new ResizeObserver(() => {
  if (window.map && window.map.resize) {
    setTimeout(() => {
      window.map.resize();
          }, 100);
  }
});

// Observe the map container for size changes
const mapContainer = document.getElementById('map');
if (mapContainer) {
  resizeObserver.observe(mapContainer);
}

// Handle orientation change for iOS Safari
window.addEventListener('orientationchange', () => {
    setTimeout(() => {
    if (window.map && window.map.resize) {
      window.map.resize();
          }
  }, 200);
});

// Also trigger resize on window resize (for responsive behavior)
window.addEventListener('resize', () => {
  if (window.map && window.map.resize) {
    window.map.resize();
  }
}, { passive: true });
</script>
</body>
</html>